{
  "70849fb9-49fa-41d8-a4ff-d66d03529fde": {
    "id": "70849fb9-49fa-41d8-a4ff-d66d03529fde",
    "filename": "Maui_Xaml_Binding_Lab_Handout.pdf",
    "file_path": "static/uploads/presentations\\70849fb9-49fa-41d8-a4ff-d66d03529fde\\Maui_Xaml_Binding_Lab_Handout.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "LAB HANDOUT \nMAUI XAML Binding Practice with CommunityToolkit.Mvvm \n \nCourse / Module \nMobile Application Development (.NET MAUI) \nLab Title \nTask Manager – XAML Data Binding & MVVM Toolkit \nDuration \n3 hours (180 minutes) \nLab Type \nIndividual – Hands-on Practice \n \n1. Lab Objectives \nAfter completing this lab, students will be able to: \n• Explain the purpose of data binding in .NET MAUI \n• Apply MVVM pattern using CommunityToolkit.Mvvm \n• Correctly use common binding modes in XAML \n• Bind UI elements to ViewModel properties and commands \n• Use converters and MultiBinding in real UI scenarios \n \n2. Software & Tools \n• Visual Studio 2022 or later \n• .NET MAUI workload installed \n• NuGet package: \no CommunityToolkit.Mvvm",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "3. Problem Description \nYou are required to build a single-screen Task Manager application using .NET MAUI \n(XAML). \nThe application allows users to: - Enter a task name - Add the task to a list - Mark tasks as \ncompleted - View task statistics (total and completed) \n    Constraints - No navigation between pages - No database or API - No code-\nbehind logic for UI behavior - All interactions must be implemented using data \nbinding and commands \n \n4. User Interface Specification \nMain Screen Components \n1. Application title: MY TASKS \n2. Text input for new task \n3. Add button \n4. Task list (CollectionView) \n5. Checkbox for task completion \n6. Summary section displaying: \no Total tasks \no Completed tasks \n \n5. Required Binding Types \nYour solution must demonstrate the following bindings: \nNo Binding Type Required Usage \n1 OneWay Display task title \n2 TwoWay Entry ↔ ViewModel property \n3 OneWayToSource Selected task \n4 Command Add task action \n5 RelativeSource Access ViewModel from item template \n6 x:Reference UI-to-UI binding \n7 Converter Completed task text style \n8 MultiBinding Summary text \n9 ObservableCollection Auto-update task list \n10 INotifyPropertyChanged ViewModel updates",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "6. Data Model \nCreate a TaskItem model that contains: \n• Title (string) \n• IsCompleted (bool) \nThe model must inherit from ObservableObject. \n \n7. ViewModel Requirements \nCreate TasksViewModel with the following: \nProperties \n• NewTaskTitle (string) \n• Tasks (ObservableCollection) \n• SelectedTask (TaskItem) \n• TotalCount (int) \n• CompletedCount (int) \nCommands \n• AddTaskCommand \nUse [ObservableProperty] and [RelayCommand] attributes where applicable. \n \n8. XAML Requirements \n• Bind Entry.Text using TwoWay binding \n• Bind Button.Command to ViewModel command \n• Use CollectionView for task list \n• Bind CheckBox.IsChecked using TwoWay binding \n• Use a Value Converter to apply strikethrough to completed tasks \n• Use MultiBinding for summary text \n• Use x:Reference at least once \n \n9. Suggested Lab Steps \n1. Create a new .NET MAUI project",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "2. Install CommunityToolkit.Mvvm \n3. Create the model class \n4. Create the ViewModel \n5. Design the UI in XAML \n6. Apply required bindings \n7. Test UI behavior \n \n10. Assessment Rubric (10 Marks) \nCriteria Marks \nCorrect MVVM structure 2 \nProper use of binding modes 3 \nCommand implementation 2 \nConverter & MultiBinding 2 \nUI completeness & clarity 1 \n \n11. Submission Requirements \nStudents must submit: \n• Source code folder or Git repository \n• Screenshot of running application \n \n12. Notes \n• Code-behind should be minimal or empty \n• Focus on binding correctness, not UI aesthetics \n• Naming conventions and clean structure are required \n \nEnd of Lab",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-24 14:38:59",
    "avatar_path": null,
    "final_video_path": null
  },
  "a972a9ff-29c4-42e0-8b3e-d4bc4f54e3a4": {
    "id": "a972a9ff-29c4-42e0-8b3e-d4bc4f54e3a4",
    "filename": "Maui_Xaml_Binding_Lab_Handout.pdf",
    "file_path": "static/uploads/presentations\\a972a9ff-29c4-42e0-8b3e-d4bc4f54e3a4\\Maui_Xaml_Binding_Lab_Handout.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "LAB HANDOUT \nMAUI XAML Binding Practice with CommunityToolkit.Mvvm \n \nCourse / Module \nMobile Application Development (.NET MAUI) \nLab Title \nTask Manager – XAML Data Binding & MVVM Toolkit \nDuration \n3 hours (180 minutes) \nLab Type \nIndividual – Hands-on Practice \n \n1. Lab Objectives \nAfter completing this lab, students will be able to: \n• Explain the purpose of data binding in .NET MAUI \n• Apply MVVM pattern using CommunityToolkit.Mvvm \n• Correctly use common binding modes in XAML \n• Bind UI elements to ViewModel properties and commands \n• Use converters and MultiBinding in real UI scenarios \n \n2. Software & Tools \n• Visual Studio 2022 or later \n• .NET MAUI workload installed \n• NuGet package: \no CommunityToolkit.Mvvm",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "3. Problem Description \nYou are required to build a single-screen Task Manager application using .NET MAUI \n(XAML). \nThe application allows users to: - Enter a task name - Add the task to a list - Mark tasks as \ncompleted - View task statistics (total and completed) \n    Constraints - No navigation between pages - No database or API - No code-\nbehind logic for UI behavior - All interactions must be implemented using data \nbinding and commands \n \n4. User Interface Specification \nMain Screen Components \n1. Application title: MY TASKS \n2. Text input for new task \n3. Add button \n4. Task list (CollectionView) \n5. Checkbox for task completion \n6. Summary section displaying: \no Total tasks \no Completed tasks \n \n5. Required Binding Types \nYour solution must demonstrate the following bindings: \nNo Binding Type Required Usage \n1 OneWay Display task title \n2 TwoWay Entry ↔ ViewModel property \n3 OneWayToSource Selected task \n4 Command Add task action \n5 RelativeSource Access ViewModel from item template \n6 x:Reference UI-to-UI binding \n7 Converter Completed task text style \n8 MultiBinding Summary text \n9 ObservableCollection Auto-update task list \n10 INotifyPropertyChanged ViewModel updates",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "6. Data Model \nCreate a TaskItem model that contains: \n• Title (string) \n• IsCompleted (bool) \nThe model must inherit from ObservableObject. \n \n7. ViewModel Requirements \nCreate TasksViewModel with the following: \nProperties \n• NewTaskTitle (string) \n• Tasks (ObservableCollection) \n• SelectedTask (TaskItem) \n• TotalCount (int) \n• CompletedCount (int) \nCommands \n• AddTaskCommand \nUse [ObservableProperty] and [RelayCommand] attributes where applicable. \n \n8. XAML Requirements \n• Bind Entry.Text using TwoWay binding \n• Bind Button.Command to ViewModel command \n• Use CollectionView for task list \n• Bind CheckBox.IsChecked using TwoWay binding \n• Use a Value Converter to apply strikethrough to completed tasks \n• Use MultiBinding for summary text \n• Use x:Reference at least once \n \n9. Suggested Lab Steps \n1. Create a new .NET MAUI project",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "2. Install CommunityToolkit.Mvvm \n3. Create the model class \n4. Create the ViewModel \n5. Design the UI in XAML \n6. Apply required bindings \n7. Test UI behavior \n \n10. Assessment Rubric (10 Marks) \nCriteria Marks \nCorrect MVVM structure 2 \nProper use of binding modes 3 \nCommand implementation 2 \nConverter & MultiBinding 2 \nUI completeness & clarity 1 \n \n11. Submission Requirements \nStudents must submit: \n• Source code folder or Git repository \n• Screenshot of running application \n \n12. Notes \n• Code-behind should be minimal or empty \n• Focus on binding correctness, not UI aesthetics \n• Naming conventions and clean structure are required \n \nEnd of Lab",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-24 14:39:22",
    "avatar_path": null,
    "final_video_path": null
  },
  "59d41985-84f2-4769-bd06-53ab2395ebf9": {
    "id": "59d41985-84f2-4769-bd06-53ab2395ebf9",
    "filename": "Maui_Xaml_Binding_Lab_Handout.pdf",
    "file_path": "static/uploads/presentations\\59d41985-84f2-4769-bd06-53ab2395ebf9\\Maui_Xaml_Binding_Lab_Handout.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "LAB HANDOUT \nMAUI XAML Binding Practice with CommunityToolkit.Mvvm \n \nCourse / Module \nMobile Application Development (.NET MAUI) \nLab Title \nTask Manager – XAML Data Binding & MVVM Toolkit \nDuration \n3 hours (180 minutes) \nLab Type \nIndividual – Hands-on Practice \n \n1. Lab Objectives \nAfter completing this lab, students will be able to: \n• Explain the purpose of data binding in .NET MAUI \n• Apply MVVM pattern using CommunityToolkit.Mvvm \n• Correctly use common binding modes in XAML \n• Bind UI elements to ViewModel properties and commands \n• Use converters and MultiBinding in real UI scenarios \n \n2. Software & Tools \n• Visual Studio 2022 or later \n• .NET MAUI workload installed \n• NuGet package: \no CommunityToolkit.Mvvm",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "3. Problem Description \nYou are required to build a single-screen Task Manager application using .NET MAUI \n(XAML). \nThe application allows users to: - Enter a task name - Add the task to a list - Mark tasks as \ncompleted - View task statistics (total and completed) \n    Constraints - No navigation between pages - No database or API - No code-\nbehind logic for UI behavior - All interactions must be implemented using data \nbinding and commands \n \n4. User Interface Specification \nMain Screen Components \n1. Application title: MY TASKS \n2. Text input for new task \n3. Add button \n4. Task list (CollectionView) \n5. Checkbox for task completion \n6. Summary section displaying: \no Total tasks \no Completed tasks \n \n5. Required Binding Types \nYour solution must demonstrate the following bindings: \nNo Binding Type Required Usage \n1 OneWay Display task title \n2 TwoWay Entry ↔ ViewModel property \n3 OneWayToSource Selected task \n4 Command Add task action \n5 RelativeSource Access ViewModel from item template \n6 x:Reference UI-to-UI binding \n7 Converter Completed task text style \n8 MultiBinding Summary text \n9 ObservableCollection Auto-update task list \n10 INotifyPropertyChanged ViewModel updates",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "6. Data Model \nCreate a TaskItem model that contains: \n• Title (string) \n• IsCompleted (bool) \nThe model must inherit from ObservableObject. \n \n7. ViewModel Requirements \nCreate TasksViewModel with the following: \nProperties \n• NewTaskTitle (string) \n• Tasks (ObservableCollection) \n• SelectedTask (TaskItem) \n• TotalCount (int) \n• CompletedCount (int) \nCommands \n• AddTaskCommand \nUse [ObservableProperty] and [RelayCommand] attributes where applicable. \n \n8. XAML Requirements \n• Bind Entry.Text using TwoWay binding \n• Bind Button.Command to ViewModel command \n• Use CollectionView for task list \n• Bind CheckBox.IsChecked using TwoWay binding \n• Use a Value Converter to apply strikethrough to completed tasks \n• Use MultiBinding for summary text \n• Use x:Reference at least once \n \n9. Suggested Lab Steps \n1. Create a new .NET MAUI project",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "2. Install CommunityToolkit.Mvvm \n3. Create the model class \n4. Create the ViewModel \n5. Design the UI in XAML \n6. Apply required bindings \n7. Test UI behavior \n \n10. Assessment Rubric (10 Marks) \nCriteria Marks \nCorrect MVVM structure 2 \nProper use of binding modes 3 \nCommand implementation 2 \nConverter & MultiBinding 2 \nUI completeness & clarity 1 \n \n11. Submission Requirements \nStudents must submit: \n• Source code folder or Git repository \n• Screenshot of running application \n \n12. Notes \n• Code-behind should be minimal or empty \n• Focus on binding correctness, not UI aesthetics \n• Naming conventions and clean structure are required \n \nEnd of Lab",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-24 15:03:57",
    "avatar_path": null,
    "final_video_path": null
  },
  "c98460a9-7aa0-4c5e-837a-5286874379ad": {
    "id": "c98460a9-7aa0-4c5e-837a-5286874379ad",
    "filename": "Maui_Xaml_Binding_Lab_Handout.pdf",
    "file_path": "static/uploads/presentations\\c98460a9-7aa0-4c5e-837a-5286874379ad\\Maui_Xaml_Binding_Lab_Handout.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "LAB HANDOUT \nMAUI XAML Binding Practice with CommunityToolkit.Mvvm \n \nCourse / Module \nMobile Application Development (.NET MAUI) \nLab Title \nTask Manager – XAML Data Binding & MVVM Toolkit \nDuration \n3 hours (180 minutes) \nLab Type \nIndividual – Hands-on Practice \n \n1. Lab Objectives \nAfter completing this lab, students will be able to: \n• Explain the purpose of data binding in .NET MAUI \n• Apply MVVM pattern using CommunityToolkit.Mvvm \n• Correctly use common binding modes in XAML \n• Bind UI elements to ViewModel properties and commands \n• Use converters and MultiBinding in real UI scenarios \n \n2. Software & Tools \n• Visual Studio 2022 or later \n• .NET MAUI workload installed \n• NuGet package: \no CommunityToolkit.Mvvm",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Chào mừng các bạn đến với buổi thực hành hôm nay! Trong khuôn khổ môn Phát triển Ứng dụng Di động với .NET MAUI, chúng ta sẽ đi sâu vào một phần cực kỳ quan trọng và thiết yếu khi xây dựng các ứng dụng di động hiện đại: đó là Data Binding và mô hình MVVM.\n\nBuổi lab của chúng ta có tên là \"Task Manager – XAML Data Binding & MVVM Toolkit\". Đúng như tên gọi, chúng ta sẽ cùng nhau xây dựng một ứng dụng quản lý tác vụ cơ bản, nơi mà mọi logic và dữ liệu đều được quản lý một cách hiệu quả thông qua các kỹ thuật binding và kiến trúc MVVM. Đây là một buổi thực hành cá nhân kéo dài 3 tiếng, tập trung hoàn toàn vào thực hành trực tiếp, giúp các bạn có cái nhìn sâu sắc và kỹ năng thực tiễn.\n\nVậy sau 3 giờ thực hành này, chúng ta sẽ đạt được những gì?\n\nĐầu tiên, các bạn sẽ hiểu rõ **mục đích thực sự của Data Binding** trong .NET MAUI. Tại sao chúng ta cần nó? Nó giúp tách biệt UI và logic, làm cho code của chúng ta sạch hơn, dễ bảo trì hơn, và quan trọng nhất là tạo ra các ứng dụng phản hồi mượt mà hơn với dữ liệu.\n\nTiếp theo, chúng ta sẽ áp dụng **mô hình MVVM** – Model-View-ViewModel – một kiến trúc đã quá quen thuộc và hiệu quả trong phát triển ứng dụng UI. Đặc biệt, chúng ta sẽ sử dụng **CommunityToolkit.Mvvm**. Đây là một thư viện NuGet rất mạnh mẽ, giúp chúng ta triển khai MVVM một cách dễ dàng và hiệu quả hơn rất nhiều, giảm bớt boilerplate code.\n\nCác bạn cũng sẽ học cách sử dụng các **chế độ binding phổ biến trong XAML** một cách chính xác, từ OneWay, TwoWay cho đến OneTime. Chúng ta sẽ thực hành liên kết các phần tử UI như TextBox, Button với các thuộc tính và lệnh (Commands) trong ViewModel.\n\nVà để làm cho ứng dụng của chúng ta linh hoạt hơn, chúng ta sẽ khám phá cách dùng các **converters** để biến đổi dữ liệu, hoặc sử dụng **MultiBinding** để kết hợp nhiều nguồn dữ liệu khác nhau vào một UI element duy nhất. Tất cả đều là những tình huống thực tế mà bạn sẽ gặp trong quá trình phát triển ứng dụng.\n\nVề mặt công cụ, để buổi lab diễn ra suôn sẻ, các bạn chỉ cần đảm bảo máy tính của mình đã cài đặt Visual Studio 2022 trở lên, có workload .NET MAUI và đã thêm gói NuGet CommunityToolkit.Mvvm vào project của mình.\n\nHy vọng với buổi thực hành này, các bạn sẽ không chỉ nắm vững lý thuyết mà còn có thể tự tin áp dụng Data Binding và MVVM vào các dự án MAUI của mình. Đây là những kỹ năng nền tảng cực kỳ giá trị để xây dựng các ứng dụng di động hiện đại. Bây giờ, chúng ta hãy cùng bắt đầu nhé!",
        "edited_text": "Chào mừng các bạn đến với buổi thực hành hôm nay! Trong khuôn khổ môn Phát triển Ứng dụng Di động với .NET MAUI, chúng ta sẽ đi sâu vào một phần cực kỳ quan trọng và thiết yếu khi xây dựng các ứng dụng di động hiện đại: đó là Data Binding và mô hình MVVM.\n\nBuổi lab của chúng ta có tên là \"Task Manager – XAML Data Binding & MVVM Toolkit\". Đúng như tên gọi, chúng ta sẽ cùng nhau xây dựng một ứng dụng quản lý tác vụ cơ bản, nơi mà mọi logic và dữ liệu đều được quản lý một cách hiệu quả thông qua các kỹ thuật binding và kiến trúc MVVM. Đây là một buổi thực hành cá nhân kéo dài 3 tiếng, tập trung hoàn toàn vào thực hành trực tiếp, giúp các bạn có cái nhìn sâu sắc và kỹ năng thực tiễn.\n\nVậy sau 3 giờ thực hành này, chúng ta sẽ đạt được những gì?\n\nĐầu tiên, các bạn sẽ hiểu rõ **mục đích thực sự của Data Binding** trong .NET MAUI. Tại sao chúng ta cần nó? Nó giúp tách biệt UI và logic, làm cho code của chúng ta sạch hơn, dễ bảo trì hơn, và quan trọng nhất là tạo ra các ứng dụng phản hồi mượt mà hơn với dữ liệu.\n\nTiếp theo, chúng ta sẽ áp dụng **mô hình MVVM** – Model-View-ViewModel – một kiến trúc đã quá quen thuộc và hiệu quả trong phát triển ứng dụng UI. Đặc biệt, chúng ta sẽ sử dụng **CommunityToolkit.Mvvm**. Đây là một thư viện NuGet rất mạnh mẽ, giúp chúng ta triển khai MVVM một cách dễ dàng và hiệu quả hơn rất nhiều, giảm bớt boilerplate code.\n\nCác bạn cũng sẽ học cách sử dụng các **chế độ binding phổ biến trong XAML** một cách chính xác, từ OneWay, TwoWay cho đến OneTime. Chúng ta sẽ thực hành liên kết các phần tử UI như TextBox, Button với các thuộc tính và lệnh (Commands) trong ViewModel.\n\nVà để làm cho ứng dụng của chúng ta linh hoạt hơn, chúng ta sẽ khám phá cách dùng các **converters** để biến đổi dữ liệu, hoặc sử dụng **MultiBinding** để kết hợp nhiều nguồn dữ liệu khác nhau vào một UI element duy nhất. Tất cả đều là những tình huống thực tế mà bạn sẽ gặp trong quá trình phát triển ứng dụng.\n\nVề mặt công cụ, để buổi lab diễn ra suôn sẻ, các bạn chỉ cần đảm bảo máy tính của mình đã cài đặt Visual Studio 2022 trở lên, có workload .NET MAUI và đã thêm gói NuGet CommunityToolkit.Mvvm vào project của mình.\n\nHy vọng với buổi thực hành này, các bạn sẽ không chỉ nắm vững lý thuyết mà còn có thể tự tin áp dụng Data Binding và MVVM vào các dự án MAUI của mình. Đây là những kỹ năng nền tảng cực kỳ giá trị để xây dựng các ứng dụng di động hiện đại. Bây giờ, chúng ta hãy cùng bắt đầu nhé!",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "3. Problem Description \nYou are required to build a single-screen Task Manager application using .NET MAUI \n(XAML). \nThe application allows users to: - Enter a task name - Add the task to a list - Mark tasks as \ncompleted - View task statistics (total and completed) \n    Constraints - No navigation between pages - No database or API - No code-\nbehind logic for UI behavior - All interactions must be implemented using data \nbinding and commands \n \n4. User Interface Specification \nMain Screen Components \n1. Application title: MY TASKS \n2. Text input for new task \n3. Add button \n4. Task list (CollectionView) \n5. Checkbox for task completion \n6. Summary section displaying: \no Total tasks \no Completed tasks \n \n5. Required Binding Types \nYour solution must demonstrate the following bindings: \nNo Binding Type Required Usage \n1 OneWay Display task title \n2 TwoWay Entry ↔ ViewModel property \n3 OneWayToSource Selected task \n4 Command Add task action \n5 RelativeSource Access ViewModel from item template \n6 x:Reference UI-to-UI binding \n7 Converter Completed task text style \n8 MultiBinding Summary text \n9 ObservableCollection Auto-update task list \n10 INotifyPropertyChanged ViewModel updates",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Chào mọi người, hôm nay chúng ta sẽ cùng tìm hiểu về một dự án thú vị: xây dựng ứng dụng quản lý tác vụ (Task Manager) sử dụng .NET MAUI.\n\nMục tiêu của chúng ta là tạo ra một ứng dụng chỉ trên một màn hình duy nhất, nơi người dùng có thể thực hiện mọi thao tác quản lý công việc của mình. Cụ thể, người dùng có thể dễ dàng nhập tên một công việc mới, thêm nó vào danh sách, đánh dấu khi công việc đó hoàn thành, và theo dõi các số liệu thống kê cơ bản như tổng số công việc và số công việc đã hoàn thành.\n\nTuy nhiên, điểm thú vị và cũng là thử thách lớn nhất nằm ở các ràng buộc của dự án này. Đầu tiên, như đã nói, chúng ta không có chuyển trang, mọi thứ diễn ra trên một màn hình. Thứ hai, không sử dụng database hay API bên ngoài – tất cả dữ liệu sẽ được xử lý trong bộ nhớ của ứng dụng. Và quan trọng nhất, để đảm bảo tính minh bạch và dễ bảo trì, chúng ta *không được phép* viết bất kỳ logic xử lý UI nào trong phần code-behind của XAML. Thay vào đó, tất cả các tương tác người dùng phải được triển khai thông qua cơ chế data binding và commands.\n\nĐể đáp ứng các yêu cầu này, giao diện người dùng của chúng ta được thiết kế rất trực quan và đơn giản. Màn hình chính sẽ có tiêu đề rõ ràng là \"MY TASKS\". Phía trên cùng là một ô nhập liệu để người dùng gõ tên công việc mới, và ngay bên cạnh là nút \"Thêm\" để đưa công việc đó vào danh sách. Phần trung tâm sẽ là danh sách các công việc, hiển thị dưới dạng CollectionView. Mỗi công việc trong danh sách sẽ đi kèm một checkbox để người dùng dễ dàng đánh dấu hoàn thành. Cuối cùng, ở phần dưới cùng của màn hình, chúng ta sẽ có một khu vực tóm tắt, hiển thị tổng số công việc và số lượng công việc đã hoàn thành, giúp người dùng nắm bắt tình hình chung một cách nhanh chóng.\n\nĐể hiện thực hóa tất cả các tương tác này mà không cần dùng code-behind, chúng ta sẽ tận dụng triệt để các kiểu Data Binding khác nhau trong .NET MAUI. Ví dụ, kiểu `OneWay` sẽ giúp hiển thị tiêu đề công việc một chiều từ ViewModel ra UI. Kiểu `TwoWay` sẽ cực kỳ hữu ích cho ô nhập liệu, đảm bảo dữ liệu luôn được đồng bộ hai chiều giữa giao diện và ViewModel. Các nút bấm như \"Thêm\" sẽ được xử lý bằng `Command` binding, giúp tách rời logic hành động khỏi UI.\n\nTrong danh sách công việc, chúng ta sẽ cần đến `RelativeSource` để truy cập ViewModel từ bên trong item template, hoặc `x:Reference` để liên kết các thành phần UI với nhau trực tiếp. Để làm cho phần tóm tắt trở nên sống động, chúng ta sẽ dùng `MultiBinding` để kết hợp nhiều giá trị thành một chuỗi hiển thị duy nhất, và `Converter` để thay đổi phong cách hiển thị của văn bản, ví dụ như gạch ngang những công việc đã hoàn thành. Cuối cùng, để danh sách công việc tự động cập nhật mỗi khi có thay đổi, chúng ta sẽ sử dụng `ObservableCollection`, và ViewModel của chúng ta sẽ triển khai interface `INotifyPropertyChanged` để thông báo cho UI biết khi có bất kỳ thuộc tính nào thay đổi.\n\nTóm lại, mặc dù chỉ là một ứng dụng đơn màn hình, dự án này yêu cầu chúng ta phải có sự hiểu biết sâu sắc về các cơ chế Data Binding và MVVM trong .NET MAUI để xây dựng một giải pháp sạch sẽ, hiệu quả và dễ bảo trì.",
        "edited_text": "Chào mọi người, hôm nay chúng ta sẽ cùng tìm hiểu về một dự án thú vị: xây dựng ứng dụng quản lý tác vụ (Task Manager) sử dụng .NET MAUI.\n\nMục tiêu của chúng ta là tạo ra một ứng dụng chỉ trên một màn hình duy nhất, nơi người dùng có thể thực hiện mọi thao tác quản lý công việc của mình. Cụ thể, người dùng có thể dễ dàng nhập tên một công việc mới, thêm nó vào danh sách, đánh dấu khi công việc đó hoàn thành, và theo dõi các số liệu thống kê cơ bản như tổng số công việc và số công việc đã hoàn thành.\n\nTuy nhiên, điểm thú vị và cũng là thử thách lớn nhất nằm ở các ràng buộc của dự án này. Đầu tiên, như đã nói, chúng ta không có chuyển trang, mọi thứ diễn ra trên một màn hình. Thứ hai, không sử dụng database hay API bên ngoài – tất cả dữ liệu sẽ được xử lý trong bộ nhớ của ứng dụng. Và quan trọng nhất, để đảm bảo tính minh bạch và dễ bảo trì, chúng ta *không được phép* viết bất kỳ logic xử lý UI nào trong phần code-behind của XAML. Thay vào đó, tất cả các tương tác người dùng phải được triển khai thông qua cơ chế data binding và commands.\n\nĐể đáp ứng các yêu cầu này, giao diện người dùng của chúng ta được thiết kế rất trực quan và đơn giản. Màn hình chính sẽ có tiêu đề rõ ràng là \"MY TASKS\". Phía trên cùng là một ô nhập liệu để người dùng gõ tên công việc mới, và ngay bên cạnh là nút \"Thêm\" để đưa công việc đó vào danh sách. Phần trung tâm sẽ là danh sách các công việc, hiển thị dưới dạng CollectionView. Mỗi công việc trong danh sách sẽ đi kèm một checkbox để người dùng dễ dàng đánh dấu hoàn thành. Cuối cùng, ở phần dưới cùng của màn hình, chúng ta sẽ có một khu vực tóm tắt, hiển thị tổng số công việc và số lượng công việc đã hoàn thành, giúp người dùng nắm bắt tình hình chung một cách nhanh chóng.\n\nĐể hiện thực hóa tất cả các tương tác này mà không cần dùng code-behind, chúng ta sẽ tận dụng triệt để các kiểu Data Binding khác nhau trong .NET MAUI. Ví dụ, kiểu `OneWay` sẽ giúp hiển thị tiêu đề công việc một chiều từ ViewModel ra UI. Kiểu `TwoWay` sẽ cực kỳ hữu ích cho ô nhập liệu, đảm bảo dữ liệu luôn được đồng bộ hai chiều giữa giao diện và ViewModel. Các nút bấm như \"Thêm\" sẽ được xử lý bằng `Command` binding, giúp tách rời logic hành động khỏi UI.\n\nTrong danh sách công việc, chúng ta sẽ cần đến `RelativeSource` để truy cập ViewModel từ bên trong item template, hoặc `x:Reference` để liên kết các thành phần UI với nhau trực tiếp. Để làm cho phần tóm tắt trở nên sống động, chúng ta sẽ dùng `MultiBinding` để kết hợp nhiều giá trị thành một chuỗi hiển thị duy nhất, và `Converter` để thay đổi phong cách hiển thị của văn bản, ví dụ như gạch ngang những công việc đã hoàn thành. Cuối cùng, để danh sách công việc tự động cập nhật mỗi khi có thay đổi, chúng ta sẽ sử dụng `ObservableCollection`, và ViewModel của chúng ta sẽ triển khai interface `INotifyPropertyChanged` để thông báo cho UI biết khi có bất kỳ thuộc tính nào thay đổi.\n\nTóm lại, mặc dù chỉ là một ứng dụng đơn màn hình, dự án này yêu cầu chúng ta phải có sự hiểu biết sâu sắc về các cơ chế Data Binding và MVVM trong .NET MAUI để xây dựng một giải pháp sạch sẽ, hiệu quả và dễ bảo trì.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "6. Data Model \nCreate a TaskItem model that contains: \n• Title (string) \n• IsCompleted (bool) \nThe model must inherit from ObservableObject. \n \n7. ViewModel Requirements \nCreate TasksViewModel with the following: \nProperties \n• NewTaskTitle (string) \n• Tasks (ObservableCollection) \n• SelectedTask (TaskItem) \n• TotalCount (int) \n• CompletedCount (int) \nCommands \n• AddTaskCommand \nUse [ObservableProperty] and [RelayCommand] attributes where applicable. \n \n8. XAML Requirements \n• Bind Entry.Text using TwoWay binding \n• Bind Button.Command to ViewModel command \n• Use CollectionView for task list \n• Bind CheckBox.IsChecked using TwoWay binding \n• Use a Value Converter to apply strikethrough to completed tasks \n• Use MultiBinding for summary text \n• Use x:Reference at least once \n \n9. Suggested Lab Steps \n1. Create a new .NET MAUI project",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Chào mừng quý vị và các bạn,\n\nVâng, tiếp theo đây, chúng ta sẽ đi sâu hơn vào các yêu cầu kỹ thuật để xây dựng ứng dụng quản lý công việc của mình nhé. Đây là những khối cấu trúc quan trọng sẽ định hình cách ứng dụng của chúng ta hoạt động và tương tác.\n\nĐầu tiên là phần **Data Model**, hay còn gọi là mô hình dữ liệu. Chúng ta sẽ tạo một mô hình đơn giản tên là `TaskItem` để đại diện cho một công việc. Mỗi `TaskItem` sẽ có hai thuộc tính chính: `Title` – là một chuỗi để lưu tên công việc, và `IsCompleted` – một kiểu boolean để biết công việc đã hoàn thành hay chưa. Điều quan trọng ở đây là mô hình này phải kế thừa từ `ObservableObject`. Tại sao lại vậy? Bởi vì khi trạng thái của một công việc thay đổi – ví dụ, bạn đánh dấu nó là hoàn thành – thì giao diện người dùng cần phải tự động cập nhật mà không cần chúng ta phải viết quá nhiều code thủ công. `ObservableObject` chính là công cụ giúp chúng ta làm điều đó một cách hiệu quả.\n\nTiếp theo là trái tim của ứng dụng: **ViewModel** của chúng ta, cụ thể là `TasksViewModel`. ViewModel này sẽ chứa các thuộc tính để quản lý dữ liệu và trạng thái của giao diện. Chúng ta sẽ có `NewTaskTitle` để nhận đầu vào từ người dùng khi họ muốn thêm công việc mới. Một `ObservableCollection` tên là `Tasks` sẽ lưu trữ danh sách các công việc. `ObservableCollection` rất quan trọng vì nó sẽ tự động thông báo cho UI biết mỗi khi có công việc mới được thêm vào, xóa đi, hoặc thay đổi vị trí. Ngoài ra, chúng ta còn có `SelectedTask` để theo dõi công việc đang được chọn, và hai thuộc tính `TotalCount`, `CompletedCount` để hiển thị tóm tắt tổng số công việc và số công việc đã hoàn thành. Về các **Commands** (lệnh), chúng ta sẽ có `AddTaskCommand` để xử lý logic khi người dùng bấm nút thêm công việc. Để đơn giản hóa việc viết code MVVM, chúng ta sẽ tận dụng các thuộc tính `[ObservableProperty]` và `[RelayCommand]` từ MAUI Community Toolkit. Chúng giúp giảm bớt lượng code 'lặp lại' mà vẫn đảm bảo tính năng thông báo thay đổi và thực thi lệnh một cách hiệu quả.\n\nBây giờ đến phần giao diện, hay còn gọi là **XAML Requirements**. Đây là nơi chúng ta kết nối UI với ViewModel. Chúng ta sẽ sử dụng TwoWay binding cho `Entry.Text` để đảm bảo dữ liệu nhập vào từ ô văn bản có thể đi vào ViewModel và ngược lại. Tương tự, `CheckBox.IsChecked` cũng sẽ dùng TwoWay binding để cập nhật trạng thái hoàn thành của công việc. Để hiển thị danh sách công việc, chúng ta sẽ dùng `CollectionView`, một control hiện đại và mạnh mẽ hơn ListView truyền thống. Một điểm nhấn thú vị là chúng ta sẽ dùng một **Value Converter** để tạo hiệu ứng gạch ngang cho các công việc đã hoàn thành, giúp người dùng dễ dàng nhận biết. Và để hiển thị văn bản tóm tắt như \"Tổng số: X, Đã hoàn thành: Y\", chúng ta sẽ cần đến **MultiBinding** để kết hợp nhiều thuộc tính từ ViewModel vào một chuỗi văn bản duy nhất. Cuối cùng, chúng ta cũng sẽ áp dụng `x:Reference` ít nhất một lần để thực hành việc tham chiếu giữa các control trong XAML.\n\nTất nhiên, để bắt đầu tất cả những điều này, bước đầu tiên rất đơn giản: chỉ cần **tạo một dự án .NET MAUI mới**. Đó là nền tảng để chúng ta bắt đầu xây dựng mọi thứ.\n\nĐó là tổng quan về các yêu cầu chính cho mô hình dữ liệu, ViewModel và giao diện người dùng. Khi kết hợp các yếu tố này lại, chúng ta sẽ có một ứng dụng quản lý công việc hoạt động mượt mà và hiệu quả.",
        "edited_text": "Chào mừng quý vị và các bạn,\n\nVâng, tiếp theo đây, chúng ta sẽ đi sâu hơn vào các yêu cầu kỹ thuật để xây dựng ứng dụng quản lý công việc của mình nhé. Đây là những khối cấu trúc quan trọng sẽ định hình cách ứng dụng của chúng ta hoạt động và tương tác.\n\nĐầu tiên là phần **Data Model**, hay còn gọi là mô hình dữ liệu. Chúng ta sẽ tạo một mô hình đơn giản tên là `TaskItem` để đại diện cho một công việc. Mỗi `TaskItem` sẽ có hai thuộc tính chính: `Title` – là một chuỗi để lưu tên công việc, và `IsCompleted` – một kiểu boolean để biết công việc đã hoàn thành hay chưa. Điều quan trọng ở đây là mô hình này phải kế thừa từ `ObservableObject`. Tại sao lại vậy? Bởi vì khi trạng thái của một công việc thay đổi – ví dụ, bạn đánh dấu nó là hoàn thành – thì giao diện người dùng cần phải tự động cập nhật mà không cần chúng ta phải viết quá nhiều code thủ công. `ObservableObject` chính là công cụ giúp chúng ta làm điều đó một cách hiệu quả.\n\nTiếp theo là trái tim của ứng dụng: **ViewModel** của chúng ta, cụ thể là `TasksViewModel`. ViewModel này sẽ chứa các thuộc tính để quản lý dữ liệu và trạng thái của giao diện. Chúng ta sẽ có `NewTaskTitle` để nhận đầu vào từ người dùng khi họ muốn thêm công việc mới. Một `ObservableCollection` tên là `Tasks` sẽ lưu trữ danh sách các công việc. `ObservableCollection` rất quan trọng vì nó sẽ tự động thông báo cho UI biết mỗi khi có công việc mới được thêm vào, xóa đi, hoặc thay đổi vị trí. Ngoài ra, chúng ta còn có `SelectedTask` để theo dõi công việc đang được chọn, và hai thuộc tính `TotalCount`, `CompletedCount` để hiển thị tóm tắt tổng số công việc và số công việc đã hoàn thành. Về các **Commands** (lệnh), chúng ta sẽ có `AddTaskCommand` để xử lý logic khi người dùng bấm nút thêm công việc. Để đơn giản hóa việc viết code MVVM, chúng ta sẽ tận dụng các thuộc tính `[ObservableProperty]` và `[RelayCommand]` từ MAUI Community Toolkit. Chúng giúp giảm bớt lượng code 'lặp lại' mà vẫn đảm bảo tính năng thông báo thay đổi và thực thi lệnh một cách hiệu quả.\n\nBây giờ đến phần giao diện, hay còn gọi là **XAML Requirements**. Đây là nơi chúng ta kết nối UI với ViewModel. Chúng ta sẽ sử dụng TwoWay binding cho `Entry.Text` để đảm bảo dữ liệu nhập vào từ ô văn bản có thể đi vào ViewModel và ngược lại. Tương tự, `CheckBox.IsChecked` cũng sẽ dùng TwoWay binding để cập nhật trạng thái hoàn thành của công việc. Để hiển thị danh sách công việc, chúng ta sẽ dùng `CollectionView`, một control hiện đại và mạnh mẽ hơn ListView truyền thống. Một điểm nhấn thú vị là chúng ta sẽ dùng một **Value Converter** để tạo hiệu ứng gạch ngang cho các công việc đã hoàn thành, giúp người dùng dễ dàng nhận biết. Và để hiển thị văn bản tóm tắt như \"Tổng số: X, Đã hoàn thành: Y\", chúng ta sẽ cần đến **MultiBinding** để kết hợp nhiều thuộc tính từ ViewModel vào một chuỗi văn bản duy nhất. Cuối cùng, chúng ta cũng sẽ áp dụng `x:Reference` ít nhất một lần để thực hành việc tham chiếu giữa các control trong XAML.\n\nTất nhiên, để bắt đầu tất cả những điều này, bước đầu tiên rất đơn giản: chỉ cần **tạo một dự án .NET MAUI mới**. Đó là nền tảng để chúng ta bắt đầu xây dựng mọi thứ.\n\nĐó là tổng quan về các yêu cầu chính cho mô hình dữ liệu, ViewModel và giao diện người dùng. Khi kết hợp các yếu tố này lại, chúng ta sẽ có một ứng dụng quản lý công việc hoạt động mượt mà và hiệu quả.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "2. Install CommunityToolkit.Mvvm \n3. Create the model class \n4. Create the ViewModel \n5. Design the UI in XAML \n6. Apply required bindings \n7. Test UI behavior \n \n10. Assessment Rubric (10 Marks) \nCriteria Marks \nCorrect MVVM structure 2 \nProper use of binding modes 3 \nCommand implementation 2 \nConverter & MultiBinding 2 \nUI completeness & clarity 1 \n \n11. Submission Requirements \nStudents must submit: \n• Source code folder or Git repository \n• Screenshot of running application \n \n12. Notes \n• Code-behind should be minimal or empty \n• Focus on binding correctness, not UI aesthetics \n• Naming conventions and clean structure are required \n \nEnd of Lab",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Chào mừng các bạn đến với buổi hướng dẫn bài lab hôm nay! Chúng ta sẽ cùng nhau điểm qua các bước thực hiện, cũng như những tiêu chí quan trọng để hoàn thành bài tập một cách tốt nhất.\n\nĐầu tiên, để bắt đầu dự án, các bạn hãy **cài đặt thư viện CommunityToolkit.Mvvm** – đây sẽ là nền tảng giúp chúng ta triển khai mô hình MVVM một cách hiệu quả.\n\nTiếp theo, chúng ta sẽ lần lượt **tạo các lớp Model và ViewModel**. Hãy nhớ rằng Model dùng để biểu diễn dữ liệu, còn ViewModel sẽ là nơi chứa logic nghiệp vụ và phơi bày dữ liệu cho giao diện người dùng. Sau khi có Model và ViewModel, các bạn sẽ **thiết kế giao diện người dùng (UI) trong XAML**. Đây là lúc để biến ý tưởng của mình thành hình ảnh.\n\nVà một trong những bước quan trọng nhất chính là **áp dụng các binding cần thiết**. Việc này sẽ giúp UI và ViewModel của chúng ta 'nói chuyện' với nhau, đảm bảo dữ liệu luôn được đồng bộ. Cuối cùng, đừng quên **kiểm tra kỹ lưỡng hành vi của UI** để đảm bảo mọi chức năng đều hoạt động đúng như mong đợi.\n\nBây giờ, hãy nói một chút về cách bài lab này sẽ được đánh giá. Chúng ta có tổng cộng 10 điểm, và đây là những tiêu chí cụ thể:\n\nĐầu tiên là **cấu trúc MVVM chính xác (2 điểm)**. Điều này rất quan trọng vì nó thể hiện sự hiểu biết của các bạn về việc tách biệt các mối quan tâm trong ứng dụng. Kế đến, **việc sử dụng đúng các chế độ binding (3 điểm)** chiếm tỷ trọng cao nhất. Hãy cân nhắc kỹ xem khi nào thì dùng OneWay, TwoWay hay OneTime để đảm bảo luồng dữ liệu hiệu quả.\n\nTiếp theo, **cách các bạn triển khai Command (2 điểm)** cũng sẽ được chấm điểm. Command giúp chúng ta xử lý các hành động từ UI mà không cần can thiệp vào code-behind. Ngoài ra, **việc sử dụng Converter và MultiBinding (2 điểm)** cũng là một điểm cộng lớn, cho thấy các bạn có thể xử lý các tình huống binding phức tạp hơn. Và cuối cùng, **tính đầy đủ và rõ ràng của UI (1 điểm)**. Không cần quá cầu kỳ về mặt thẩm mỹ, nhưng UI cần phải thể hiện đủ các thành phần chức năng được yêu cầu.\n\nVề yêu cầu nộp bài, các bạn cần gửi hai thứ: Thứ nhất là **toàn bộ thư mục mã nguồn hoặc link đến kho Git repository** của các bạn. Và thứ hai là một **ảnh chụp màn hình (screenshot) của ứng dụng đang chạy** để chúng tôi dễ dàng kiểm tra kết quả.\n\nCuối cùng, một vài lưu ý nhỏ nhưng rất quan trọng để bài làm của các bạn đạt chất lượng cao:\n\nHãy cố gắng giữ cho **code-behind của các bạn ở mức tối thiểu hoặc hoàn toàn trống**. Đây là một trong những mục tiêu chính khi chúng ta dùng MVVM. Thứ hai, hãy **tập trung vào tính đúng đắn của binding chứ không phải yếu tố thẩm mỹ của UI**. Điều quan trọng là chức năng hoạt động. Và đừng quên, việc **tuân thủ các quy ước đặt tên và giữ cho cấu trúc dự án gọn gàng, sạch sẽ** luôn được đánh giá cao, vì nó thể hiện sự chuyên nghiệp trong cách làm việc.\n\nĐó là toàn bộ những hướng dẫn và lưu ý cho bài lab này. Chúc các bạn làm bài thật tốt và nếu có bất kỳ thắc mắc nào, đừng ngần ngại hỏi nhé!",
        "edited_text": "Chào mừng các bạn đến với buổi hướng dẫn bài lab hôm nay! Chúng ta sẽ cùng nhau điểm qua các bước thực hiện, cũng như những tiêu chí quan trọng để hoàn thành bài tập một cách tốt nhất.\n\nĐầu tiên, để bắt đầu dự án, các bạn hãy **cài đặt thư viện CommunityToolkit.Mvvm** – đây sẽ là nền tảng giúp chúng ta triển khai mô hình MVVM một cách hiệu quả.\n\nTiếp theo, chúng ta sẽ lần lượt **tạo các lớp Model và ViewModel**. Hãy nhớ rằng Model dùng để biểu diễn dữ liệu, còn ViewModel sẽ là nơi chứa logic nghiệp vụ và phơi bày dữ liệu cho giao diện người dùng. Sau khi có Model và ViewModel, các bạn sẽ **thiết kế giao diện người dùng (UI) trong XAML**. Đây là lúc để biến ý tưởng của mình thành hình ảnh.\n\nVà một trong những bước quan trọng nhất chính là **áp dụng các binding cần thiết**. Việc này sẽ giúp UI và ViewModel của chúng ta 'nói chuyện' với nhau, đảm bảo dữ liệu luôn được đồng bộ. Cuối cùng, đừng quên **kiểm tra kỹ lưỡng hành vi của UI** để đảm bảo mọi chức năng đều hoạt động đúng như mong đợi.\n\nBây giờ, hãy nói một chút về cách bài lab này sẽ được đánh giá. Chúng ta có tổng cộng 10 điểm, và đây là những tiêu chí cụ thể:\n\nĐầu tiên là **cấu trúc MVVM chính xác (2 điểm)**. Điều này rất quan trọng vì nó thể hiện sự hiểu biết của các bạn về việc tách biệt các mối quan tâm trong ứng dụng. Kế đến, **việc sử dụng đúng các chế độ binding (3 điểm)** chiếm tỷ trọng cao nhất. Hãy cân nhắc kỹ xem khi nào thì dùng OneWay, TwoWay hay OneTime để đảm bảo luồng dữ liệu hiệu quả.\n\nTiếp theo, **cách các bạn triển khai Command (2 điểm)** cũng sẽ được chấm điểm. Command giúp chúng ta xử lý các hành động từ UI mà không cần can thiệp vào code-behind. Ngoài ra, **việc sử dụng Converter và MultiBinding (2 điểm)** cũng là một điểm cộng lớn, cho thấy các bạn có thể xử lý các tình huống binding phức tạp hơn. Và cuối cùng, **tính đầy đủ và rõ ràng của UI (1 điểm)**. Không cần quá cầu kỳ về mặt thẩm mỹ, nhưng UI cần phải thể hiện đủ các thành phần chức năng được yêu cầu.\n\nVề yêu cầu nộp bài, các bạn cần gửi hai thứ: Thứ nhất là **toàn bộ thư mục mã nguồn hoặc link đến kho Git repository** của các bạn. Và thứ hai là một **ảnh chụp màn hình (screenshot) của ứng dụng đang chạy** để chúng tôi dễ dàng kiểm tra kết quả.\n\nCuối cùng, một vài lưu ý nhỏ nhưng rất quan trọng để bài làm của các bạn đạt chất lượng cao:\n\nHãy cố gắng giữ cho **code-behind của các bạn ở mức tối thiểu hoặc hoàn toàn trống**. Đây là một trong những mục tiêu chính khi chúng ta dùng MVVM. Thứ hai, hãy **tập trung vào tính đúng đắn của binding chứ không phải yếu tố thẩm mỹ của UI**. Điều quan trọng là chức năng hoạt động. Và đừng quên, việc **tuân thủ các quy ước đặt tên và giữ cho cấu trúc dự án gọn gàng, sạch sẽ** luôn được đánh giá cao, vì nó thể hiện sự chuyên nghiệp trong cách làm việc.\n\nĐó là toàn bộ những hướng dẫn và lưu ý cho bài lab này. Chúc các bạn làm bài thật tốt và nếu có bất kỳ thắc mắc nào, đừng ngần ngại hỏi nhé!",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-24 15:06:27",
    "avatar_path": null,
    "final_video_path": null
  },
  "3e609cb1-e938-4b15-ba5b-e4145086a81e": {
    "id": "3e609cb1-e938-4b15-ba5b-e4145086a81e",
    "filename": "CHUONG_6_DAN_TOC.pptx",
    "file_path": "static/uploads/presentations\\5f39ee09-b261-4fb4-a88d-ee11f075067e\\CHUONG_6_DAN_TOC.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Chương 6\u000bVẤN ĐỀ DÂN TỘC VÀ TÔN GIÁO \nTRONG THỜI KỲ QUÁ ĐỘ \nLÊN CHỦ NGHĨA XÃ HỘI\nGiảng viên: ThS. Đặng Thị Kim Dung",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "1. Dân tộc trong thời kỳ quá độ lên chủ nghĩa xã hội",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "NỘI DUNG BÀI",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Dân tộc quốc gia\n(Nation)",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "ĐẶC TRƯNG CỦA DÂN TỘC",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "ĐẶC TRƯNG \u000bCỦA DÂN TỘC\nKHÔNG GIAN SINH TỒN\nVỊ TRÍ ĐỊA LÝ CỦA DÂN TỘC\nTHỂ HIỆN \nCHỦ QUYỀN CỦA MỘT DÂN TỘC",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "ĐẶC TRƯNG \u000bCỦA DÂN TỘC\nMối quan hệ kinh tế là nền tảng cho sự vững chắc của cộng đồng dân tộc",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "ĐẶC TRƯNG \u000bCỦA DÂN TỘC",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Bản sắc riêng của từng dân tộc\nVăn hóa của các cộng đồng\n tộc người trong một quốc gia\nĐẶC TRƯNG \u000bCỦA DÂN TỘC",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Đây là yếu tố phân biệt dân tộc – quốc gia và dân tộc – tộc người\nNhà nước là đặc trưng cho thể chế chính trị của dân tộc\nĐẶC TRƯNG \u000bCỦA DÂN TỘC",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Khái niệm dân tộc\nDân tộc tộc người (ethnie)",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Đặc trưng Dân tộc – tộc người",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "1.2. Chủ nghĩa Mác – Lênin về vấn đề dân tộc\n1.2.1. Hai xu hướng khách quan của sự phát triển quan hệ dân tộc\n1.2.2. Cương lĩnh dân tộc của chủ nghĩa Mác - Lênin",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Xu hướng thứ nhất\u000bCộng đồng dân cư muốn tách ra \u000bhình thành cộng đồng dân tộc độc lập\nNguyên nhân\nThức tỉnh, trưởng thành về ý thức dân tộc\nQuyền sống của mình\nCác cộng đồng dân cư tách ra thành lập các dân tộc độc lập",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Xu hướng thứ nhất\u000bCộng đồng dân cư muốn tách ra hình thành cộng đồng dân tộc độc lập",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Xu hướng thứ hai\u000bCác dân tộc trong từng quốc gia, dân tộc ở nhiều quốc gia liên hiệp lại\nNguyên nhân\nChủ nghĩa đế quốc đi \nxâm lược các nước thuộc địa",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "NATO (4/4/1949)\nKhối quấn sự Bắc Đại Tây Dương",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Xu hướng thứ hai\u000bCác dân tộc trong từng quốc gia, dân tộc ở nhiều quốc gia liên hiệp lại\nNguyên nhân\nChủ nghĩa đế quốc đi \nxâm lược các nước thuộc địa\nDo sự phát triển của lực lượng sản xuất",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "BIỂU HIỆN CỦA HAI XU HƯỚNG KHÁCH QUAN TRONG PHÁT TRIỂN QUAN HỆ DÂN TỘC TRONG GIAI ĐOẠN HIỆN NAY\nTHẢO LUẬN",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Đôngtimore tách khỏi Inđônêxia 5/2002\nNam Ossetia tách khỏi Gruzia sau sự kiện 8/2008",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Kôsôvô\ntách khỏi Sécbia\n17/2/2008\nNgười dân Kôsôvô \nhân hoan nhân ngày độc lập",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Biểu hiện xu hướng liên hiệp lại giữa \ncác dân tộc trong giai đoạn hiện nay",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "EU\nLiên minh Châu Âu\nASEAN – Hiệp hội các quốc gia ĐNÁ\nUAE\nTiểu vương quốc Ả rập thống nhất",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "1.2.3. Cương lĩnh dân tộc của chủ nghĩa Mác - Lênin",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Quyền thiêng liêng \ncủa các \ndân tộc",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Bình đẳng giữa các dân tộc trong một quốc gia",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "BÌNH ĐẲNG TRONG HIẾN PHÁP VÀ THỰC TIỄN",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Bình đẳng giữa các \nquốc gia\nChống chủ nghĩa \nphân biệt chủng tộc,\n bá quyền",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "HIỆN NAY CÁC\n QUỐC GIA DÂN TỘC TRÊN THẾ GIỚI ĐÃ BÌNH ĐẲNG CHƯA? TẠI SAO?",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Trung Quốc với mưu đồ chiếm biển Đông\nẢnh chụp trên cao cho thấy Trung Quốc đang đẩy mạnh xây dựng trên đảo Phú Lâm thuộc quần đảo Hoàng Sa",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "“Bảo đảm lợi ích tối cao của quốc gia – dân tộc, trên cơ sở các nguyên tắc cơ bản của luật pháp quốc tế, bình đẳng và cùng có lợi, thực hiện nhất quán đường lối đối ngoại độc lập, tự chủ, hòa bình, hợp tác và phát triển”\nĐảng cộng sản Việt Nam: Văn kiện đại hội đại biểu toàn quốc lần thứ XII, HN, 2016, tr.153.",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 36,
        "content": "",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 37,
        "content": "Quyền làm chủ        \n        Quyền tự quyết định con đường phát triển                     \n        Quyền tự do phân lập và quyền tự nguyện liên hiệp",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 38,
        "content": "Sau thất bại mô hình CNXH ở các nước Đông Âu và Liên Xô năm 1991\nĐặt ra yêu cầu gì\n đối với việc lựa chọn \ncon đường phát triển ở Việt Nam \nvà các nước XHCN?",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 39,
        "content": "Đường lối đổi mới từ năm 1986",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 40,
        "content": "Kinh tế thị trường định hướng XHCN\nTăng trưởng kinh tế",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 41,
        "content": "",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 42,
        "content": "Phân tích \u000bvụ việc\u000b Kích động thành lập “Vương quốc Mông” \u000bở Mường Nhé, \u000bĐiện Biên",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 43,
        "content": "CÁC DÂN TỘC \nĐƯỢC QUYỀN TỰ QUYẾT\nQUYỀN ĐƯỢC PHÂN LẬP VÀ \nLIÊN HIỆP \nTHAM GIA \nTỔ CHỨC QUỐC TẾ\nĐỨNG TRÊN QUAN ĐIỂM CNDVLS \nVÀ LẬP TRƯỜNG GIAI CẤP \nCÔNG NHÂN",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 44,
        "content": "Liên hiệp công nhân tất cả các dân tộc\nPhản ánh sự thống nhất giữa giải phóng dân tộc, giải phóng giai cấp\nPhản ánh sự gắn bó tinh thần của CN yêu nước và CN quốc tế chân chinh\nLà cơ sở để đoan kết các tầng lớp nhân dân lao động",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 45,
        "content": "Giá trị lịch sử của Cương lĩnh và việc tiếp thu, vận dụng ở Việt Nam\n- Nêu rõ chính sách của Quốc tế Cộng sản về vấn đề dân tộc và thuộc địa.\n- Động lực to lớn với phong trào giải phóng dân tộc ở các nước thuộc địa.\n- Chủ tịch Hồ Chí Minh đã tiếp thu, vận dụng sáng tạo để giải quyết đúng đắn quan hệ giai cấp - dân tộc, dân tộc, quốc tế ở nước ta.",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 46,
        "content": "1.3. Dân tộc và quan hệ dân tộc ở Việt Nam\n1.3.1. Đặc điểm dân tộc Việt Nam",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 47,
        "content": "1.3.2. Quan điểm, chính sách của Đảng và Nhà nước ta về vấn đề dân tộc và công tác dân tộc trong thời kỳ mới\nNội dung đối nội của chính sách dân tộc\n+ Bình đẳng giữa các dân tộc\n+ Đoàn kết các dân tộc.\n+ Tương trợ nhau cùng phát triển.\nNội dung đối ngoại của chính sách dân tộc\n+ Thực hiện quan hệ dân tộc trên tinh thần độc lập tự chủ, mở rộng, đa phương hóa các quan hệ quốc tế. Việt Nam sẵn sàng là bạn, là đối tác tin cậy của các nước trong cộng đồng quốc tế, phấn đấu vì hòa bình, độc lập và phát triển.",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-28 15:10:35",
    "avatar_path": null,
    "final_video_path": null
  },
  "866a9b9c-e768-44e1-8b8a-dd471dae5022": {
    "id": "866a9b9c-e768-44e1-8b8a-dd471dae5022",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/8f62a5c6-4a0b-4263-b11e-1c05afec02d9/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 15:28:24",
    "avatar_path": null,
    "final_video_path": null
  },
  "d6ad2e2b-458f-405c-a70d-a8951dfd8ceb": {
    "id": "d6ad2e2b-458f-405c-a70d-a8951dfd8ceb",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/ae125ccc-47db-4ed3-9d9b-3df330694f71/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 16:05:45",
    "avatar_path": null,
    "final_video_path": null
  },
  "78131c65-e6af-4757-a4a9-cba2f48f79b0": {
    "id": "78131c65-e6af-4757-a4a9-cba2f48f79b0",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/cf04d0b3-a4f0-43f2-b3b9-24e2efbfc0ab/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 16:06:07",
    "avatar_path": null,
    "final_video_path": null
  },
  "12ec0b2e-10bc-482c-b9a4-63705091a1b5": {
    "id": "12ec0b2e-10bc-482c-b9a4-63705091a1b5",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/57a06e11-9365-4800-98cd-34524f6a169d/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 18:29:54",
    "avatar_path": null,
    "final_video_path": null
  },
  "ad0a346d-d3f9-4b7c-84a7-dafb9e52919e": {
    "id": "ad0a346d-d3f9-4b7c-84a7-dafb9e52919e",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/4c84b539-6d71-4504-a651-5769c30daf68/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 18:48:11",
    "avatar_path": null,
    "final_video_path": null
  },
  "f7e5affb-d423-479a-8960-160ff3bcc24c": {
    "id": "f7e5affb-d423-479a-8960-160ff3bcc24c",
    "filename": "ORAL_EXAM_DESIGN.pdf",
    "file_path": "static/uploads/presentations/8ebb5afa-1f16-487e-a3e5-00a12af66a9c/ORAL_EXAM_DESIGN.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "ORAL EXAM DESIGN \n.NET MAUI – XAML UI & Data Binding (CommunityToolkit.Mvvm) \n \n1. Exam Overview \nExam Type: Practical + Oral Examination \nFormat: Team-based (2 students / team) \nNumber of Teams: 13 teams \nTotal Duration per Team: 2 hours 10 minutes \n• Part 1: Practical UI Project – 2 hours \n• Part 2: Oral Examination – 10 minutes \n \n2. Exam Objectives \nThis oral exam aims to assess students’ ability to: \n• Design UI layouts using XAML in .NET MAUI \n• Correctly apply data binding techniques \n• Implement MVVM pattern using CommunityToolkit.Mvvm \n• Explain and justify technical decisions verbally \n• Demonstrate individual understanding within a team project \n \n3. Allowed Resources \n• Visual Studio 2022 or later \n• .NET MAUI project template \n• Internet access for documentation only \n• NuGet package: CommunityToolkit.Mvvm \n  No pre-written project code allowed \n \n4. Part 1 – Practical Project (2 Hours) \nGeneral Requirements (All Teams) \nEach team must build a single-screen MAUI application with: \n• UI designed in XAML \n• MVVM architecture \n• At least 4 different binding techniques",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "• No navigation between pages \n• No database or API \n \nMandatory Binding Techniques \nEach project must demonstrate: \n1. TwoWay Binding (Entry ↔ ViewModel) \n2. OneWay Binding (Display data) \n3. Command Binding (Button actions) \n4. ObservableCollection Binding (List update) \nAt least ONE advanced binding: \n• Converter \n• MultiBinding \n• RelativeSource \n• x:Reference \n \n5. Personalized Project Topics (14 Teams) \nEach team receives one unique UI scenario to prevent copying while keeping difficulty \nequivalent. \nTeam Assignments \nTeam Project Theme \n1 Grocery Shopping List \n2 Daily Habit Tracker \n3 Student Attendance UI \n4 Expense Tracker (UI only) \n5 Book Reading Tracker \n6 Workout Session Planner \n7 Movie Watchlist \n8 Meeting Agenda Manager \n9 Event Checklist",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Team Project Theme \n10 Smart Home Device Panel \n11 Plant Care Reminder UI \n12 Simple Note Organizer \n13 Classroom Equipment Checklist \nAll projects must follow the same technical constraints, only the UI content differs. \n \n6. Minimum Feature Set (Example) \nEach project should include: \n• Title header \n• Input section (Entry) \n• Action button(s) \n• List display (CollectionView) \n• Status indicator (Label / CheckBox / Switch) \n• Summary section (count, status, or description) \n \n7. Part 2 – Oral Examination (10 Minutes) \nStructure \n• 5 minutes: Project demonstration \n• 5 minutes: Oral questions (individual) \nBoth students must answer questions. \n \n8. Oral Question Bank (Examiner Chooses) \nUI & XAML (Basic) \n• Why did you choose Grid instead of StackLayout? \n• Explain the role of CollectionView in your UI. \nData Binding \n• Explain the difference between OneWay and TwoWay binding. \n• Why is ObservableCollection required? \nMVVM & Toolkit",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "• What problem does CommunityToolkit.Mvvm solve? \n• Explain [ObservableProperty] and [RelayCommand]. \nAdvanced Binding (If Used) \n• Why did you use a converter here? \n• Explain how MultiBinding works in your project. \n \n9. Individual Assessment Strategy \nTo ensure fairness: \n• Examiner asks different questions to each student \n• Each student must explain at least one binding used \n• Examiner may ask one student to modify a binding verbally \n \n10. Grading Rubric (20 Marks) \nPractical Project – 12 Marks \nCriteria Marks \nUI layout correctness 3 \nCorrect binding usage 4 \nMVVM structure 3 \nCode clarity & organization 2 \nOral Examination – 8 Marks \nCriteria Marks \nExplanation of bindings 3 \nMVVM understanding 2 \nIndividual contribution 2 \nCommunication clarity 1 \n \n11. Examiner Notes \n• Focus on understanding, not memorization \n• Penalize code-behind logic",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "• Encourage students to explain design decisions \n• Each team having a team leader, using GitHub to store the project, branch then merge \nfor the final submission \n• Each team must have a brainstorming for the project (visualation using any mindmap \napplication), checkin along with code.  \n \n12. Expected Learning Outcomes \nAfter the exam, students should be able to: \n• Design MAUI UI using XAML confidently \n• Apply data binding correctly \n• Explain MVVM principles verbally \n• Read and reason about XAML code \n \nEnd of Oral Exam Design",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 18:55:51",
    "avatar_path": null,
    "final_video_path": null
  },
  "7b71aa40-651c-41d0-827a-34f2c9917498": {
    "id": "7b71aa40-651c-41d0-827a-34f2c9917498",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/06072422-3657-4968-aeb0-da7fba4912c4/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 19:13:44",
    "avatar_path": null,
    "final_video_path": null
  },
  "6e24eafa-5c61-494b-aa01-1d5b55ade761": {
    "id": "6e24eafa-5c61-494b-aa01-1d5b55ade761",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/6e24eafa-5c61-494b-aa01-1d5b55ade761/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 19:28:10",
    "avatar_path": null,
    "final_video_path": null
  },
  "9fa47167-f1b8-4ad2-a84b-932d471a7221": {
    "id": "9fa47167-f1b8-4ad2-a84b-932d471a7221",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/9fa47167-f1b8-4ad2-a84b-932d471a7221/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "Chào mừng quý vị. Hôm nay chúng ta sẽ cùng tìm hiểu về vai trò cốt lõi của các mẫu thiết kế cấu trúc trong lập trình.\n\nCác mẫu thiết kế cấu trúc tập trung vào cách chúng ta kết hợp các lớp và đối tượng để tạo thành những cấu trúc lớn hơn, đồng thời đảm bảo rằng các cấu trúc này luôn linh hoạt, dễ tái sử dụng và dễ phát triển theo thời gian. Nói cách khác, chúng trả lời một câu hỏi then chốt: Làm thế nào để chúng ta tổ chức các lớp và đối tượng một cách hiệu quả, sao cho khi có thay đổi ở một phần của hệ thống, tác động lên các phần khác là tối thiểu nhất?\n\nĐể đạt được những mục tiêu đó, các mẫu thiết kế cấu trúc đảm nhiệm một số trách nhiệm chính.\n\nĐầu tiên, chúng giúp tách rời các thành phần. Điều này có nghĩa là giảm sự phụ thuộc trực tiếp giữa các lớp, làm cho hệ thống của chúng ta trở nên mạnh mẽ và dễ bảo trì hơn.\n\nThứ hai, chúng thúc đẩy việc tái sử dụng mã nguồn hiện có. Chúng ta có thể tích hợp các thành phần hệ thống cũ hoặc thư viện của bên thứ ba vào hệ thống của mình mà không cần phải sửa đổi mã gốc của chúng.\n\nThứ ba, các mẫu này hỗ trợ quản lý sự phức tạp. Bằng cách cung cấp các lớp trừu tượng đơn giản hơn, chúng ta có thể che giấu đi sự phức tạp bên trong của các hệ thống con, giúp dễ dàng làm việc hơn.\n\nVà cuối cùng, chúng cho phép chúng ta mở rộng hành vi mà không gây ra tình trạng \"bùng nổ kế thừa\". Thay vì tạo ra quá nhiều lớp con, chúng ta sẽ ưu tiên sử dụng phương pháp thành phần hóa hơn là kế thừa để đạt được sự linh hoạt và khả năng mở rộng mong muốn.",
        "edited_text": "\nCác mẫu thiết kế cấu trúc tập trung vào cách chúng ta kết hợp các lớp và đối tượng để tạo thành những cấu trúc lớn hơn, đồng thời đảm bảo rằng các cấu trúc này luôn linh hoạt, dễ tái sử dụng và dễ phát triển theo thời gian. Nói cách khác, chúng trả lời một câu hỏi then chốt: Làm thế nào để chúng ta tổ chức các lớp và đối tượng một cách hiệu quả, sao cho khi có thay đổi ở một phần của hệ thống, tác động lên các phần khác là tối thiểu nhất?\n\nĐể đạt được những mục tiêu đó, các mẫu thiết kế cấu trúc đảm nhiệm một số trách nhiệm chính.\n\nĐầu tiên, chúng giúp tách rời các thành phần. Điều này có nghĩa là giảm sự phụ thuộc trực tiếp giữa các lớp, làm cho hệ thống của chúng ta trở nên mạnh mẽ và dễ bảo trì hơn.\n\nThứ hai, chúng thúc đẩy việc tái sử dụng mã nguồn hiện có. Chúng ta có thể tích hợp các thành phần hệ thống cũ hoặc thư viện của bên thứ ba vào hệ thống của mình mà không cần phải sửa đổi mã gốc của chúng.\n\nThứ ba, các mẫu này hỗ trợ quản lý sự phức tạp. Bằng cách cung cấp các lớp trừu tượng đơn giản hơn, chúng ta có thể che giấu đi sự phức tạp bên trong của các hệ thống con, giúp dễ dàng làm việc hơn.\n\nVà cuối cùng, chúng cho phép chúng ta mở rộng hành vi mà không gây ra tình trạng \"bùng nổ kế thừa\". Thay vì tạo ra quá nhiều lớp con, chúng ta sẽ ưu tiên sử dụng phương pháp thành phần hóa hơn là kế thừa để đạt được sự linh hoạt và khả năng mở rộng mong muốn.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 19:35:03",
    "avatar_path": null,
    "final_video_path": null
  },
  "ae072861-7035-46b7-bdcc-0ede241b9f4d": {
    "id": "ae072861-7035-46b7-bdcc-0ede241b9f4d",
    "filename": "ORAL_EXAM_DESIGN.pdf",
    "file_path": "static/uploads/presentations/ae072861-7035-46b7-bdcc-0ede241b9f4d/ORAL_EXAM_DESIGN.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "ORAL EXAM DESIGN \n.NET MAUI – XAML UI & Data Binding (CommunityToolkit.Mvvm) \n \n1. Exam Overview \nExam Type: Practical + Oral Examination \nFormat: Team-based (2 students / team) \nNumber of Teams: 13 teams \nTotal Duration per Team: 2 hours 10 minutes \n• Part 1: Practical UI Project – 2 hours \n• Part 2: Oral Examination – 10 minutes \n \n2. Exam Objectives \nThis oral exam aims to assess students’ ability to: \n• Design UI layouts using XAML in .NET MAUI \n• Correctly apply data binding techniques \n• Implement MVVM pattern using CommunityToolkit.Mvvm \n• Explain and justify technical decisions verbally \n• Demonstrate individual understanding within a team project \n \n3. Allowed Resources \n• Visual Studio 2022 or later \n• .NET MAUI project template \n• Internet access for documentation only \n• NuGet package: CommunityToolkit.Mvvm \n  No pre-written project code allowed \n \n4. Part 1 – Practical Project (2 Hours) \nGeneral Requirements (All Teams) \nEach team must build a single-screen MAUI application with: \n• UI designed in XAML \n• MVVM architecture \n• At least 4 different binding techniques",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Xin chào quý vị và các bạn. Hôm nay, chúng ta sẽ cùng tìm hiểu về thiết kế bài thi vấn đáp môn .NET MAUI, tập trung vào việc xây dựng giao diện người dùng bằng XAML và kỹ thuật ràng buộc dữ liệu, đặc biệt là việc sử dụng CommunityToolkit.Mvvm.\n\nĐầu tiên, hãy cùng nhìn vào tổng quan về bài thi. Đây là một bài kiểm tra kết hợp giữa thực hành và vấn đáp. Bài thi sẽ được tổ chức theo hình thức làm việc nhóm, mỗi nhóm gồm hai sinh viên. Chúng ta sẽ có tổng cộng mười ba nhóm tham gia. Tổng thời lượng cho mỗi đội là hai giờ mười phút, được chia thành hai phần rõ rệt. Phần một là dự án giao diện người dùng thực hành, kéo dài hai giờ đồng hồ. Tiếp theo, phần hai sẽ là phần vấn đáp, diễn ra trong mười phút.\n\nVậy, mục tiêu của bài thi vấn đáp này là gì? Chúng tôi mong muốn đánh giá khả năng của sinh viên trong việc thiết kế bố cục giao diện người dùng bằng XAML trong .NET MAUI. Đồng thời, bài thi cũng kiểm tra việc các bạn áp dụng đúng các kỹ thuật ràng buộc dữ liệu, triển khai mô hình MVVM sử dụng CommunityToolkit.Mvvm. Hơn nữa, sinh viên cần có khả năng giải thích và bảo vệ các quyết định kỹ thuật của mình một cách rõ ràng bằng lời nói, và quan trọng nhất là thể hiện sự hiểu biết cá nhân trong khuôn khổ một dự án nhóm.\n\nVề tài nguyên được phép sử dụng trong quá trình thi, các bạn có thể dùng Visual Studio 2022 hoặc phiên bản mới hơn, cùng với mẫu dự án .NET MAUI. Đáng chú ý là quyền truy cập internet chỉ được phép để tra cứu tài liệu, không dùng cho bất kỳ mục đích nào khác. Các bạn cũng được phép sử dụng gói NuGet CommunityToolkit.Mvvm. Tuy nhiên, xin lưu ý rằng không được sử dụng bất kỳ mã nguồn dự án nào đã được viết sẵn từ trước.\n\nCuối cùng, hãy đi sâu hơn vào phần một – dự án thực hành kéo dài hai giờ. Các yêu cầu chung cho tất cả các nhóm là mỗi nhóm phải xây dựng một ứng dụng MAUI chỉ với một màn hình. Ứng dụng này cần có giao diện người dùng được thiết kế bằng XAML, tuân thủ kiến trúc MVVM và phải áp dụng ít nhất bốn kỹ thuật ràng buộc dữ liệu khác nhau.\n\nĐó là những thông tin tổng quan về thiết kế bài thi vấn đáp. Chúc các bạn ôn tập tốt và đạt kết quả cao.",
        "edited_text": "Xin chào quý vị và các bạn. Hôm nay, chúng ta sẽ cùng tìm hiểu về thiết kế bài thi vấn đáp môn .NET MAUI, tập trung vào việc xây dựng giao diện người dùng bằng XAML và kỹ thuật ràng buộc dữ liệu, đặc biệt là việc sử dụng CommunityToolkit.Mvvm.\n\nĐầu tiên, hãy cùng nhìn vào tổng quan về bài thi. Đây là một bài kiểm tra kết hợp giữa thực hành và vấn đáp. Bài thi sẽ được tổ chức theo hình thức làm việc nhóm, mỗi nhóm gồm hai sinh viên. Chúng ta sẽ có tổng cộng mười ba nhóm tham gia. Tổng thời lượng cho mỗi đội là hai giờ mười phút, được chia thành hai phần rõ rệt. Phần một là dự án giao diện người dùng thực hành, kéo dài hai giờ đồng hồ. Tiếp theo, phần hai sẽ là phần vấn đáp, diễn ra trong mười phút.\n\nVậy, mục tiêu của bài thi vấn đáp này là gì? Chúng tôi mong muốn đánh giá khả năng của sinh viên trong việc thiết kế bố cục giao diện người dùng bằng XAML trong .NET MAUI. Đồng thời, bài thi cũng kiểm tra việc các bạn áp dụng đúng các kỹ thuật ràng buộc dữ liệu, triển khai mô hình MVVM sử dụng CommunityToolkit.Mvvm. Hơn nữa, sinh viên cần có khả năng giải thích và bảo vệ các quyết định kỹ thuật của mình một cách rõ ràng bằng lời nói, và quan trọng nhất là thể hiện sự hiểu biết cá nhân trong khuôn khổ một dự án nhóm.\n\nVề tài nguyên được phép sử dụng trong quá trình thi, các bạn có thể dùng Visual Studio 2022 hoặc phiên bản mới hơn, cùng với mẫu dự án .NET MAUI. Đáng chú ý là quyền truy cập internet chỉ được phép để tra cứu tài liệu, không dùng cho bất kỳ mục đích nào khác. Các bạn cũng được phép sử dụng gói NuGet CommunityToolkit.Mvvm. Tuy nhiên, xin lưu ý rằng không được sử dụng bất kỳ mã nguồn dự án nào đã được viết sẵn từ trước.\n\nCuối cùng, hãy đi sâu hơn vào phần một – dự án thực hành kéo dài hai giờ. Các yêu cầu chung cho tất cả các nhóm là mỗi nhóm phải xây dựng một ứng dụng MAUI chỉ với một màn hình. Ứng dụng này cần có giao diện người dùng được thiết kế bằng XAML, tuân thủ kiến trúc MVVM và phải áp dụng ít nhất bốn kỹ thuật ràng buộc dữ liệu khác nhau.\n\nĐó là những thông tin tổng quan về thiết kế bài thi vấn đáp. Chúc các bạn ôn tập tốt và đạt kết quả cao.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "• No navigation between pages \n• No database or API \n \nMandatory Binding Techniques \nEach project must demonstrate: \n1. TwoWay Binding (Entry ↔ ViewModel) \n2. OneWay Binding (Display data) \n3. Command Binding (Button actions) \n4. ObservableCollection Binding (List update) \nAt least ONE advanced binding: \n• Converter \n• MultiBinding \n• RelativeSource \n• x:Reference \n \n5. Personalized Project Topics (14 Teams) \nEach team receives one unique UI scenario to prevent copying while keeping difficulty \nequivalent. \nTeam Assignments \nTeam Project Theme \n1 Grocery Shopping List \n2 Daily Habit Tracker \n3 Student Attendance UI \n4 Expense Tracker (UI only) \n5 Book Reading Tracker \n6 Workout Session Planner \n7 Movie Watchlist \n8 Meeting Agenda Manager \n9 Event Checklist",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Team Project Theme \n10 Smart Home Device Panel \n11 Plant Care Reminder UI \n12 Simple Note Organizer \n13 Classroom Equipment Checklist \nAll projects must follow the same technical constraints, only the UI content differs. \n \n6. Minimum Feature Set (Example) \nEach project should include: \n• Title header \n• Input section (Entry) \n• Action button(s) \n• List display (CollectionView) \n• Status indicator (Label / CheckBox / Switch) \n• Summary section (count, status, or description) \n \n7. Part 2 – Oral Examination (10 Minutes) \nStructure \n• 5 minutes: Project demonstration \n• 5 minutes: Oral questions (individual) \nBoth students must answer questions. \n \n8. Oral Question Bank (Examiner Chooses) \nUI & XAML (Basic) \n• Why did you choose Grid instead of StackLayout? \n• Explain the role of CollectionView in your UI. \nData Binding \n• Explain the difference between OneWay and TwoWay binding. \n• Why is ObservableCollection required? \nMVVM & Toolkit",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "• What problem does CommunityToolkit.Mvvm solve? \n• Explain [ObservableProperty] and [RelayCommand]. \nAdvanced Binding (If Used) \n• Why did you use a converter here? \n• Explain how MultiBinding works in your project. \n \n9. Individual Assessment Strategy \nTo ensure fairness: \n• Examiner asks different questions to each student \n• Each student must explain at least one binding used \n• Examiner may ask one student to modify a binding verbally \n \n10. Grading Rubric (20 Marks) \nPractical Project – 12 Marks \nCriteria Marks \nUI layout correctness 3 \nCorrect binding usage 4 \nMVVM structure 3 \nCode clarity & organization 2 \nOral Examination – 8 Marks \nCriteria Marks \nExplanation of bindings 3 \nMVVM understanding 2 \nIndividual contribution 2 \nCommunication clarity 1 \n \n11. Examiner Notes \n• Focus on understanding, not memorization \n• Penalize code-behind logic",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "• Encourage students to explain design decisions \n• Each team having a team leader, using GitHub to store the project, branch then merge \nfor the final submission \n• Each team must have a brainstorming for the project (visualation using any mindmap \napplication), checkin along with code.  \n \n12. Expected Learning Outcomes \nAfter the exam, students should be able to: \n• Design MAUI UI using XAML confidently \n• Apply data binding correctly \n• Explain MVVM principles verbally \n• Read and reason about XAML code \n \nEnd of Oral Exam Design",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-31 14:30:28",
    "avatar_path": null,
    "final_video_path": null
  },
  "88d59cdb-47ab-4d71-a2bb-d451197f728b": {
    "id": "88d59cdb-47ab-4d71-a2bb-d451197f728b",
    "filename": "ORAL_EXAM_DESIGN.pdf",
    "file_path": "static/uploads/presentations/88d59cdb-47ab-4d71-a2bb-d451197f728b/ORAL_EXAM_DESIGN.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "ORAL EXAM DESIGN \n.NET MAUI – XAML UI & Data Binding (CommunityToolkit.Mvvm) \n \n1. Exam Overview \nExam Type: Practical + Oral Examination \nFormat: Team-based (2 students / team) \nNumber of Teams: 13 teams \nTotal Duration per Team: 2 hours 10 minutes \n• Part 1: Practical UI Project – 2 hours \n• Part 2: Oral Examination – 10 minutes \n \n2. Exam Objectives \nThis oral exam aims to assess students’ ability to: \n• Design UI layouts using XAML in .NET MAUI \n• Correctly apply data binding techniques \n• Implement MVVM pattern using CommunityToolkit.Mvvm \n• Explain and justify technical decisions verbally \n• Demonstrate individual understanding within a team project \n \n3. Allowed Resources \n• Visual Studio 2022 or later \n• .NET MAUI project template \n• Internet access for documentation only \n• NuGet package: CommunityToolkit.Mvvm \n  No pre-written project code allowed \n \n4. Part 1 – Practical Project (2 Hours) \nGeneral Requirements (All Teams) \nEach team must build a single-screen MAUI application with: \n• UI designed in XAML \n• MVVM architecture \n• At least 4 different binding techniques",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning, everyone. Today, we're going to dive into the design and specifics of your upcoming oral examination. This assessment focuses squarely on your skills in .NET MAUI, particularly with XAML user interfaces and robust data binding, leveraging the Community Toolkit MVVM for architectural patterns.\n\nFirst, let's cover the exam overview. This will be a combined practical and oral examination, structured as a team-based project. Each team will consist of two students, and we anticipate a total of thirteen teams participating. The entire examination for each team is allocated two hours and ten minutes. This time is distinctly divided into two parts: a two-hour practical UI project, followed immediately by a ten-minute oral examination segment where you will present your work.\n\nMoving on to the objectives, this oral exam is designed to comprehensively assess several key abilities. We want to see your proficiency in designing user interface layouts using XAML within the .NET MAUI framework, your correct application of various data binding techniques, and your implementation of the MVVM pattern utilizing the Community Toolkit MVVM. Furthermore, you'll need to verbally explain and justify your technical decisions, and importantly, demonstrate your individual understanding even within the context of a team project.\n\nRegarding allowed resources, you'll have access to Visual Studio 2022 or a later version, the standard .NET MAUI project template, and internet access strictly for documentation purposes. You are also permitted to use the NuGet package Community Toolkit MVVM. A crucial point to remember is that no pre-written project code is allowed; you will be starting from a blank slate.\n\nFinally, let's detail Part One, the two-hour practical project. For this segment, every team must build a single-screen MAUI application. This application must feature a user interface designed entirely in XAML, adhere strictly to the MVVM architecture, and critically, incorporate at least four different data binding techniques. This ensures a comprehensive demonstration of your practical skills in a focused manner.",
        "edited_text": "Good morning, everyone. Today, we're going to dive into the design and specifics of your upcoming oral examination. This assessment focuses squarely on your skills in .NET MAUI, particularly with XAML user interfaces and robust data binding, leveraging the Community Toolkit MVVM for architectural patterns.\n\nFirst, let's cover the exam overview. This will be a combined practical and oral examination, structured as a team-based project. Each team will consist of two students, and we anticipate a total of thirteen teams participating. The entire examination for each team is allocated two hours and ten minutes. This time is distinctly divided into two parts: a two-hour practical UI project, followed immediately by a ten-minute oral examination segment where you will present your work.\n\nMoving on to the objectives, this oral exam is designed to comprehensively assess several key abilities. We want to see your proficiency in designing user interface layouts using XAML within the .NET MAUI framework, your correct application of various data binding techniques, and your implementation of the MVVM pattern utilizing the Community Toolkit MVVM. Furthermore, you'll need to verbally explain and justify your technical decisions, and importantly, demonstrate your individual understanding even within the context of a team project.\n\nRegarding allowed resources, you'll have access to Visual Studio 2022 or a later version, the standard .NET MAUI project template, and internet access strictly for documentation purposes. You are also permitted to use the NuGet package Community Toolkit MVVM. A crucial point to remember is that no pre-written project code is allowed; you will be starting from a blank slate.\n\nFinally, let's detail Part One, the two-hour practical project. For this segment, every team must build a single-screen MAUI application. This application must feature a user interface designed entirely in XAML, adhere strictly to the MVVM architecture, and critically, incorporate at least four different data binding techniques. This ensures a comprehensive demonstration of your practical skills in a focused manner.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "• No navigation between pages \n• No database or API \n \nMandatory Binding Techniques \nEach project must demonstrate: \n1. TwoWay Binding (Entry ↔ ViewModel) \n2. OneWay Binding (Display data) \n3. Command Binding (Button actions) \n4. ObservableCollection Binding (List update) \nAt least ONE advanced binding: \n• Converter \n• MultiBinding \n• RelativeSource \n• x:Reference \n \n5. Personalized Project Topics (14 Teams) \nEach team receives one unique UI scenario to prevent copying while keeping difficulty \nequivalent. \nTeam Assignments \nTeam Project Theme \n1 Grocery Shopping List \n2 Daily Habit Tracker \n3 Student Attendance UI \n4 Expense Tracker (UI only) \n5 Book Reading Tracker \n6 Workout Session Planner \n7 Movie Watchlist \n8 Meeting Agenda Manager \n9 Event Checklist",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Team Project Theme \n10 Smart Home Device Panel \n11 Plant Care Reminder UI \n12 Simple Note Organizer \n13 Classroom Equipment Checklist \nAll projects must follow the same technical constraints, only the UI content differs. \n \n6. Minimum Feature Set (Example) \nEach project should include: \n• Title header \n• Input section (Entry) \n• Action button(s) \n• List display (CollectionView) \n• Status indicator (Label / CheckBox / Switch) \n• Summary section (count, status, or description) \n \n7. Part 2 – Oral Examination (10 Minutes) \nStructure \n• 5 minutes: Project demonstration \n• 5 minutes: Oral questions (individual) \nBoth students must answer questions. \n \n8. Oral Question Bank (Examiner Chooses) \nUI & XAML (Basic) \n• Why did you choose Grid instead of StackLayout? \n• Explain the role of CollectionView in your UI. \nData Binding \n• Explain the difference between OneWay and TwoWay binding. \n• Why is ObservableCollection required? \nMVVM & Toolkit",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "• What problem does CommunityToolkit.Mvvm solve? \n• Explain [ObservableProperty] and [RelayCommand]. \nAdvanced Binding (If Used) \n• Why did you use a converter here? \n• Explain how MultiBinding works in your project. \n \n9. Individual Assessment Strategy \nTo ensure fairness: \n• Examiner asks different questions to each student \n• Each student must explain at least one binding used \n• Examiner may ask one student to modify a binding verbally \n \n10. Grading Rubric (20 Marks) \nPractical Project – 12 Marks \nCriteria Marks \nUI layout correctness 3 \nCorrect binding usage 4 \nMVVM structure 3 \nCode clarity & organization 2 \nOral Examination – 8 Marks \nCriteria Marks \nExplanation of bindings 3 \nMVVM understanding 2 \nIndividual contribution 2 \nCommunication clarity 1 \n \n11. Examiner Notes \n• Focus on understanding, not memorization \n• Penalize code-behind logic",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "• Encourage students to explain design decisions \n• Each team having a team leader, using GitHub to store the project, branch then merge \nfor the final submission \n• Each team must have a brainstorming for the project (visualation using any mindmap \napplication), checkin along with code.  \n \n12. Expected Learning Outcomes \nAfter the exam, students should be able to: \n• Design MAUI UI using XAML confidently \n• Apply data binding correctly \n• Explain MVVM principles verbally \n• Read and reason about XAML code \n \nEnd of Oral Exam Design",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-31 14:51:19",
    "avatar_path": null,
    "final_video_path": null
  },
  "d92dd1ca-3f62-4aa8-a204-22fa7d274e00": {
    "id": "d92dd1ca-3f62-4aa8-a204-22fa7d274e00",
    "filename": "ORAL_EXAM_DESIGN.pdf",
    "file_path": "static/uploads/presentations/d92dd1ca-3f62-4aa8-a204-22fa7d274e00/ORAL_EXAM_DESIGN.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "ORAL EXAM DESIGN \n.NET MAUI – XAML UI & Data Binding (CommunityToolkit.Mvvm) \n \n1. Exam Overview \nExam Type: Practical + Oral Examination \nFormat: Team-based (2 students / team) \nNumber of Teams: 13 teams \nTotal Duration per Team: 2 hours 10 minutes \n• Part 1: Practical UI Project – 2 hours \n• Part 2: Oral Examination – 10 minutes \n \n2. Exam Objectives \nThis oral exam aims to assess students’ ability to: \n• Design UI layouts using XAML in .NET MAUI \n• Correctly apply data binding techniques \n• Implement MVVM pattern using CommunityToolkit.Mvvm \n• Explain and justify technical decisions verbally \n• Demonstrate individual understanding within a team project \n \n3. Allowed Resources \n• Visual Studio 2022 or later \n• .NET MAUI project template \n• Internet access for documentation only \n• NuGet package: CommunityToolkit.Mvvm \n  No pre-written project code allowed \n \n4. Part 1 – Practical Project (2 Hours) \nGeneral Requirements (All Teams) \nEach team must build a single-screen MAUI application with: \n• UI designed in XAML \n• MVVM architecture \n• At least 4 different binding techniques",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning, everyone. Let's walk through the design of our upcoming oral exam, specifically focusing on .NET MAUI, XAML UI, and data binding with the Community Toolkit MVVM.\n\nFirst, an overview of the exam itself. This will be a combined practical and oral examination, conducted in a team-based format with two students per team. We anticipate having thirteen teams in total. The entire examination process for each team will last two hours and ten minutes. This is broken down into two main parts: a two-hour practical UI project, followed by a concise ten-minute oral examination.\n\nNow, let's clarify the exam objectives. This oral assessment is designed to evaluate your ability to effectively design user interface layouts using XAML within .NET MAUI. We also want to see that you can correctly apply various data binding techniques. Furthermore, a key objective is your ability to implement the MVVM pattern using the Community Toolkit MVVM library. Crucially, we're looking for your capacity to explain and justify your technical decisions verbally, and to demonstrate individual understanding even within a team project setting.\n\nRegarding allowed resources, you will have access to Visual Studio 2022 or later, the standard .NET MAUI project template, and internet access strictly for documentation purposes. You may also use the NuGet package for Community Toolkit MVVM. Please be aware that no pre-written project code is allowed; all development must occur during the exam period.\n\nFinally, let's detail Part One, the two-hour practical project. The general requirement for all teams is to build a single-screen MAUI application. This application must feature a user interface designed entirely in XAML, adhere to an MVVM architecture, and incorporate at least four different data binding techniques.",
        "edited_text": "Good morning, everyone. Let's walk through the design of our upcoming oral exam, specifically focusing on .NET MAUI, XAML UI, and data binding with the Community Toolkit MVVM.\n\nFirst, an overview of the exam itself. This will be a combined practical and oral examination, conducted in a team-based format with two students per team. We anticipate having thirteen teams in total. The entire examination process for each team will last two hours and ten minutes. This is broken down into two main parts: a two-hour practical UI project, followed by a concise ten-minute oral examination.\n\nNow, let's clarify the exam objectives. This oral assessment is designed to evaluate your ability to effectively design user interface layouts using XAML within .NET MAUI. We also want to see that you can correctly apply various data binding techniques. Furthermore, a key objective is your ability to implement the MVVM pattern using the Community Toolkit MVVM library. Crucially, we're looking for your capacity to explain and justify your technical decisions verbally, and to demonstrate individual understanding even within a team project setting.\n\nRegarding allowed resources, you will have access to Visual Studio 2022 or later, the standard .NET MAUI project template, and internet access strictly for documentation purposes. You may also use the NuGet package for Community Toolkit MVVM. Please be aware that no pre-written project code is allowed; all development must occur during the exam period.\n\nFinally, let's detail Part One, the two-hour practical project. The general requirement for all teams is to build a single-screen MAUI application. This application must feature a user interface designed entirely in XAML, adhere to an MVVM architecture, and incorporate at least four different data binding techniques.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "• No navigation between pages \n• No database or API \n \nMandatory Binding Techniques \nEach project must demonstrate: \n1. TwoWay Binding (Entry ↔ ViewModel) \n2. OneWay Binding (Display data) \n3. Command Binding (Button actions) \n4. ObservableCollection Binding (List update) \nAt least ONE advanced binding: \n• Converter \n• MultiBinding \n• RelativeSource \n• x:Reference \n \n5. Personalized Project Topics (14 Teams) \nEach team receives one unique UI scenario to prevent copying while keeping difficulty \nequivalent. \nTeam Assignments \nTeam Project Theme \n1 Grocery Shopping List \n2 Daily Habit Tracker \n3 Student Attendance UI \n4 Expense Tracker (UI only) \n5 Book Reading Tracker \n6 Workout Session Planner \n7 Movie Watchlist \n8 Meeting Agenda Manager \n9 Event Checklist",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Team Project Theme \n10 Smart Home Device Panel \n11 Plant Care Reminder UI \n12 Simple Note Organizer \n13 Classroom Equipment Checklist \nAll projects must follow the same technical constraints, only the UI content differs. \n \n6. Minimum Feature Set (Example) \nEach project should include: \n• Title header \n• Input section (Entry) \n• Action button(s) \n• List display (CollectionView) \n• Status indicator (Label / CheckBox / Switch) \n• Summary section (count, status, or description) \n \n7. Part 2 – Oral Examination (10 Minutes) \nStructure \n• 5 minutes: Project demonstration \n• 5 minutes: Oral questions (individual) \nBoth students must answer questions. \n \n8. Oral Question Bank (Examiner Chooses) \nUI & XAML (Basic) \n• Why did you choose Grid instead of StackLayout? \n• Explain the role of CollectionView in your UI. \nData Binding \n• Explain the difference between OneWay and TwoWay binding. \n• Why is ObservableCollection required? \nMVVM & Toolkit",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "• What problem does CommunityToolkit.Mvvm solve? \n• Explain [ObservableProperty] and [RelayCommand]. \nAdvanced Binding (If Used) \n• Why did you use a converter here? \n• Explain how MultiBinding works in your project. \n \n9. Individual Assessment Strategy \nTo ensure fairness: \n• Examiner asks different questions to each student \n• Each student must explain at least one binding used \n• Examiner may ask one student to modify a binding verbally \n \n10. Grading Rubric (20 Marks) \nPractical Project – 12 Marks \nCriteria Marks \nUI layout correctness 3 \nCorrect binding usage 4 \nMVVM structure 3 \nCode clarity & organization 2 \nOral Examination – 8 Marks \nCriteria Marks \nExplanation of bindings 3 \nMVVM understanding 2 \nIndividual contribution 2 \nCommunication clarity 1 \n \n11. Examiner Notes \n• Focus on understanding, not memorization \n• Penalize code-behind logic",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "• Encourage students to explain design decisions \n• Each team having a team leader, using GitHub to store the project, branch then merge \nfor the final submission \n• Each team must have a brainstorming for the project (visualation using any mindmap \napplication), checkin along with code.  \n \n12. Expected Learning Outcomes \nAfter the exam, students should be able to: \n• Design MAUI UI using XAML confidently \n• Apply data binding correctly \n• Explain MVVM principles verbally \n• Read and reason about XAML code \n \nEnd of Oral Exam Design",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-31 15:54:58",
    "avatar_path": null,
    "final_video_path": null
  },
  "981fb7cf-ba25-4b1b-be5f-6031d4e66105": {
    "id": "981fb7cf-ba25-4b1b-be5f-6031d4e66105",
    "filename": "ORAL_EXAM_DESIGN.pdf",
    "file_path": "static/uploads/presentations/981fb7cf-ba25-4b1b-be5f-6031d4e66105/ORAL_EXAM_DESIGN.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "ORAL EXAM DESIGN \n.NET MAUI – XAML UI & Data Binding (CommunityToolkit.Mvvm) \n \n1. Exam Overview \nExam Type: Practical + Oral Examination \nFormat: Team-based (2 students / team) \nNumber of Teams: 13 teams \nTotal Duration per Team: 2 hours 10 minutes \n• Part 1: Practical UI Project – 2 hours \n• Part 2: Oral Examination – 10 minutes \n \n2. Exam Objectives \nThis oral exam aims to assess students’ ability to: \n• Design UI layouts using XAML in .NET MAUI \n• Correctly apply data binding techniques \n• Implement MVVM pattern using CommunityToolkit.Mvvm \n• Explain and justify technical decisions verbally \n• Demonstrate individual understanding within a team project \n \n3. Allowed Resources \n• Visual Studio 2022 or later \n• .NET MAUI project template \n• Internet access for documentation only \n• NuGet package: CommunityToolkit.Mvvm \n  No pre-written project code allowed \n \n4. Part 1 – Practical Project (2 Hours) \nGeneral Requirements (All Teams) \nEach team must build a single-screen MAUI application with: \n• UI designed in XAML \n• MVVM architecture \n• At least 4 different binding techniques",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning, everyone. Today, we're going to discuss the structure and design of our upcoming oral examination, which focuses on .NET MAUI, XAML UI, and data binding using the Community Toolkit dot MVVM.\n\nFirst, let's go over the exam overview. This assessment is a combined practical and oral examination. You'll be working in teams of two students, and we have a total of thirteen teams participating. Each team will have a total duration of two hours and ten minutes for the entire assessment. This time is split into two distinct parts: a two-hour practical UI project, followed by a ten-minute oral examination.\n\nMoving on to the exam objectives, this oral exam is specifically designed to assess several key abilities. We aim to evaluate your skills in designing user interface layouts using XAML within .NET MAUI, correctly applying various data binding techniques, and implementing the MVVM pattern effectively with the Community Toolkit dot MVVM. Furthermore, we'll be looking at your capacity to verbally explain and justify your technical decisions, and importantly, how you demonstrate your individual understanding within the context of a team project.\n\nRegarding allowed resources, you'll be permitted to use Visual Studio 2022 or later, along with the standard .NET MAUI project template. Internet access is allowed strictly for documentation purposes only. You will also need the NuGet package for Community Toolkit dot MVVM. A critical point to remember is that no pre-written project code is allowed; you must start from scratch.\n\nFinally, let's detail Part 1, the practical project, which spans two hours. The general requirement for all teams is to build a single-screen MAUI application. This application must feature a user interface designed entirely in XAML, adhere to the MVVM architecture, and demonstrate the use of at least four different binding techniques.",
        "edited_text": "Good morning, everyone. Today, we're going to discuss the structure and design of our upcoming oral examination, which focuses on .NET MAUI, XAML UI, and data binding using the Community Toolkit dot MVVM.\n\nFirst, let's go over the exam overview. This assessment is a combined practical and oral examination. You'll be working in teams of two students, and we have a total of thirteen teams participating. Each team will have a total duration of two hours and ten minutes for the entire assessment. This time is split into two distinct parts: a two-hour practical UI project, followed by a ten-minute oral examination.\n\nMoving on to the exam objectives, this oral exam is specifically designed to assess several key abilities. We aim to evaluate your skills in designing user interface layouts using XAML within .NET MAUI, correctly applying various data binding techniques, and implementing the MVVM pattern effectively with the Community Toolkit dot MVVM. Furthermore, we'll be looking at your capacity to verbally explain and justify your technical decisions, and importantly, how you demonstrate your individual understanding within the context of a team project.\n\nRegarding allowed resources, you'll be permitted to use Visual Studio 2022 or later, along with the standard .NET MAUI project template. Internet access is allowed strictly for documentation purposes only. You will also need the NuGet package for Community Toolkit dot MVVM. A critical point to remember is that no pre-written project code is allowed; you must start from scratch.\n\nFinally, let's detail Part 1, the practical project, which spans two hours. The general requirement for all teams is to build a single-screen MAUI application. This application must feature a user interface designed entirely in XAML, adhere to the MVVM architecture, and demonstrate the use of at least four different binding techniques.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "• No navigation between pages \n• No database or API \n \nMandatory Binding Techniques \nEach project must demonstrate: \n1. TwoWay Binding (Entry ↔ ViewModel) \n2. OneWay Binding (Display data) \n3. Command Binding (Button actions) \n4. ObservableCollection Binding (List update) \nAt least ONE advanced binding: \n• Converter \n• MultiBinding \n• RelativeSource \n• x:Reference \n \n5. Personalized Project Topics (14 Teams) \nEach team receives one unique UI scenario to prevent copying while keeping difficulty \nequivalent. \nTeam Assignments \nTeam Project Theme \n1 Grocery Shopping List \n2 Daily Habit Tracker \n3 Student Attendance UI \n4 Expense Tracker (UI only) \n5 Book Reading Tracker \n6 Workout Session Planner \n7 Movie Watchlist \n8 Meeting Agenda Manager \n9 Event Checklist",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Alright, let's go over the project requirements and expectations.\n\nFirst, it is important to understand the scope of these projects. To ensure our focus remains squarely on core UI development and binding techniques, please note that your solutions will not involve navigation between multiple pages. Furthermore, there is no need to integrate with a database or external API. All data will be handled in-memory, allowing us to concentrate purely on the front-end logic and presentation.\n\nNow, let's talk about the mandatory binding techniques that each project must demonstrate. These are fundamental to building responsive and maintainable user interfaces. You will need to implement Two-Way Binding, which allows data to flow seamlessly between your UI entry fields and your ViewModel. One-Way Binding is also required for effectively displaying data from your source. Next, Command Binding will be essential for handling button actions and other interactive elements, connecting user interactions directly to your ViewModel's logic. And finally, Observable Collection Binding is crucial for managing and dynamically updating lists or collections of data in your UI.\n\nBeyond these core requirements, each project must also incorporate at least one advanced binding technique. You have several options to choose from: you could use a Converter to transform data for display, implement Multi-Binding to combine multiple sources into a single target, leverage Relative Source for contextual binding, or utilize X Reference to bind to named elements within your XAML.\n\nTo ensure fairness and encourage unique solutions across all fourteen teams, each group will receive a personalized project topic. This approach prevents direct copying while maintaining an equivalent level of difficulty for everyone. Here are just a few examples of the diverse UI scenarios you might encounter: Team One could be working on a Grocery Shopping List; Team Two might tackle a Daily Habit Tracker; Team Three, a Student Attendance UI; Team Four, an Expense Tracker, focusing purely on the UI aspect; and Team Five, a Book Reading Tracker. There are many more unique topics designed to challenge and engage each team.",
        "edited_text": "Alright, let's go over the project requirements and expectations.\n\nFirst, it is important to understand the scope of these projects. To ensure our focus remains squarely on core UI development and binding techniques, please note that your solutions will not involve navigation between multiple pages. Furthermore, there is no need to integrate with a database or external API. All data will be handled in-memory, allowing us to concentrate purely on the front-end logic and presentation.\n\nNow, let's talk about the mandatory binding techniques that each project must demonstrate. These are fundamental to building responsive and maintainable user interfaces. You will need to implement Two-Way Binding, which allows data to flow seamlessly between your UI entry fields and your ViewModel. One-Way Binding is also required for effectively displaying data from your source. Next, Command Binding will be essential for handling button actions and other interactive elements, connecting user interactions directly to your ViewModel's logic. And finally, Observable Collection Binding is crucial for managing and dynamically updating lists or collections of data in your UI.\n\nBeyond these core requirements, each project must also incorporate at least one advanced binding technique. You have several options to choose from: you could use a Converter to transform data for display, implement Multi-Binding to combine multiple sources into a single target, leverage Relative Source for contextual binding, or utilize X Reference to bind to named elements within your XAML.\n\nTo ensure fairness and encourage unique solutions across all fourteen teams, each group will receive a personalized project topic. This approach prevents direct copying while maintaining an equivalent level of difficulty for everyone. Here are just a few examples of the diverse UI scenarios you might encounter: Team One could be working on a Grocery Shopping List; Team Two might tackle a Daily Habit Tracker; Team Three, a Student Attendance UI; Team Four, an Expense Tracker, focusing purely on the UI aspect; and Team Five, a Book Reading Tracker. There are many more unique topics designed to challenge and engage each team.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Team Project Theme \n10 Smart Home Device Panel \n11 Plant Care Reminder UI \n12 Simple Note Organizer \n13 Classroom Equipment Checklist \nAll projects must follow the same technical constraints, only the UI content differs. \n \n6. Minimum Feature Set (Example) \nEach project should include: \n• Title header \n• Input section (Entry) \n• Action button(s) \n• List display (CollectionView) \n• Status indicator (Label / CheckBox / Switch) \n• Summary section (count, status, or description) \n \n7. Part 2 – Oral Examination (10 Minutes) \nStructure \n• 5 minutes: Project demonstration \n• 5 minutes: Oral questions (individual) \nBoth students must answer questions. \n \n8. Oral Question Bank (Examiner Chooses) \nUI & XAML (Basic) \n• Why did you choose Grid instead of StackLayout? \n• Explain the role of CollectionView in your UI. \nData Binding \n• Explain the difference between OneWay and TwoWay binding. \n• Why is ObservableCollection required? \nMVVM & Toolkit",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Alright everyone, let's go over some important details regarding your team projects and the upcoming oral examination.\n\nFirst, let's look at the project themes. We have four distinct options available: a Smart Home Device Panel, a Plant Care Reminder user interface, a Simple Note Organizer, and a Classroom Equipment Checklist. While the specific user interface content will naturally differ for each of these themes, it's crucial to remember that all projects must adhere to the same underlying technical constraints. This ensures a consistent foundation across all your work, focusing on core development principles rather than just visual variety.\n\nMoving on to the minimum feature set. To ensure every project covers essential components and demonstrates core functionalities, each one is required to incorporate a defined minimum feature set. This includes a clear title header, an input section for data entry, and at least one action button. You'll also need a list display, typically implemented using a CollectionView, a status indicator such as a label, checkbox, or switch, and finally, a summary section that provides a count, status, or description relevant to your project's data. These elements form the core functionality we expect to see.\n\nNow, let's transition to the oral examination, which forms Part Two of this assessment. This will be a ten-minute session structured as follows: the first five minutes will be dedicated to your project demonstration, where you'll showcase your work. This will be followed by five minutes of individual oral questions. Please make a note that both students in a team are expected to actively participate and answer these questions.\n\nTo help you prepare effectively, here's an overview of the types of questions you might encounter during the oral examination. Examiners will choose from a bank of questions covering key areas. For instance, under UI and XAML basics, you could be asked why you chose Grid instead of StackLayout, or to explain the specific role of CollectionView in your user interface. In the Data Binding section, expect questions on the difference between OneWay and TwoWay binding, and why an ObservableCollection is a necessary component in certain scenarios. We will also cover topics related to MVVM and the Toolkit, so please ensure you're familiar with these concepts.",
        "edited_text": "Alright everyone, let's go over some important details regarding your team projects and the upcoming oral examination.\n\nFirst, let's look at the project themes. We have four distinct options available: a Smart Home Device Panel, a Plant Care Reminder user interface, a Simple Note Organizer, and a Classroom Equipment Checklist. While the specific user interface content will naturally differ for each of these themes, it's crucial to remember that all projects must adhere to the same underlying technical constraints. This ensures a consistent foundation across all your work, focusing on core development principles rather than just visual variety.\n\nMoving on to the minimum feature set. To ensure every project covers essential components and demonstrates core functionalities, each one is required to incorporate a defined minimum feature set. This includes a clear title header, an input section for data entry, and at least one action button. You'll also need a list display, typically implemented using a CollectionView, a status indicator such as a label, checkbox, or switch, and finally, a summary section that provides a count, status, or description relevant to your project's data. These elements form the core functionality we expect to see.\n\nNow, let's transition to the oral examination, which forms Part Two of this assessment. This will be a ten-minute session structured as follows: the first five minutes will be dedicated to your project demonstration, where you'll showcase your work. This will be followed by five minutes of individual oral questions. Please make a note that both students in a team are expected to actively participate and answer these questions.\n\nTo help you prepare effectively, here's an overview of the types of questions you might encounter during the oral examination. Examiners will choose from a bank of questions covering key areas. For instance, under UI and XAML basics, you could be asked why you chose Grid instead of StackLayout, or to explain the specific role of CollectionView in your user interface. In the Data Binding section, expect questions on the difference between OneWay and TwoWay binding, and why an ObservableCollection is a necessary component in certain scenarios. We will also cover topics related to MVVM and the Toolkit, so please ensure you're familiar with these concepts.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "• What problem does CommunityToolkit.Mvvm solve? \n• Explain [ObservableProperty] and [RelayCommand]. \nAdvanced Binding (If Used) \n• Why did you use a converter here? \n• Explain how MultiBinding works in your project. \n \n9. Individual Assessment Strategy \nTo ensure fairness: \n• Examiner asks different questions to each student \n• Each student must explain at least one binding used \n• Examiner may ask one student to modify a binding verbally \n \n10. Grading Rubric (20 Marks) \nPractical Project – 12 Marks \nCriteria Marks \nUI layout correctness 3 \nCorrect binding usage 4 \nMVVM structure 3 \nCode clarity & organization 2 \nOral Examination – 8 Marks \nCriteria Marks \nExplanation of bindings 3 \nMVVM understanding 2 \nIndividual contribution 2 \nCommunication clarity 1 \n \n11. Examiner Notes \n• Focus on understanding, not memorization \n• Penalize code-behind logic",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Let's delve into the specific areas we will be assessing, particularly concerning your use of the Community Toolkit MVVM. You should be prepared to articulate what specific problem the Community Toolkit MVVM aims to solve in application development. Following that, we expect you to clearly explain the purpose and usage of key components like Observable Property and Relay Command within your project. If you've employed advanced binding techniques, such as using converters, be ready to explain why you chose a converter in a particular instance. Similarly, if you've implemented Multi Binding, a thorough explanation of its functionality within your project will be expected.\n\nNow, regarding our individual assessment strategy, we've implemented measures to ensure fairness for everyone. The examiner will ask different questions to each student, ensuring we assess individual understanding rather than a shared group response. A mandatory requirement for every student is to explain at least one binding used within your project. Furthermore, to test your practical problem-solving skills, the examiner may ask a student to verbally modify a binding.\n\nLet's turn our attention to the grading rubric, which totals twenty marks. Twelve marks are allocated to the practical project itself. This includes three marks for UI layout correctness, four marks for the correct usage of bindings, three marks for adhering to a sound MVVM structure, and two marks for the overall clarity and organization of your code. The remaining eight marks are for the oral examination. Here, three marks are for your explanation of bindings, two marks for demonstrating your understanding of MVVM principles, another two marks for your individual contribution to the project, and finally, one mark for the clarity of your communication.\n\nFinally, a few important notes from the examiner. The primary focus of this assessment is on your understanding of the concepts, not on mere memorization. We want to see that you truly grasp the \"why\" behind your implementations. And crucially, you will be penalized for the presence of code-behind logic, as this directly contradicts the MVVM principles we expect you to apply.",
        "edited_text": "Let's delve into the specific areas we will be assessing, particularly concerning your use of the Community Toolkit MVVM. You should be prepared to articulate what specific problem the Community Toolkit MVVM aims to solve in application development. Following that, we expect you to clearly explain the purpose and usage of key components like Observable Property and Relay Command within your project. If you've employed advanced binding techniques, such as using converters, be ready to explain why you chose a converter in a particular instance. Similarly, if you've implemented Multi Binding, a thorough explanation of its functionality within your project will be expected.\n\nNow, regarding our individual assessment strategy, we've implemented measures to ensure fairness for everyone. The examiner will ask different questions to each student, ensuring we assess individual understanding rather than a shared group response. A mandatory requirement for every student is to explain at least one binding used within your project. Furthermore, to test your practical problem-solving skills, the examiner may ask a student to verbally modify a binding.\n\nLet's turn our attention to the grading rubric, which totals twenty marks. Twelve marks are allocated to the practical project itself. This includes three marks for UI layout correctness, four marks for the correct usage of bindings, three marks for adhering to a sound MVVM structure, and two marks for the overall clarity and organization of your code. The remaining eight marks are for the oral examination. Here, three marks are for your explanation of bindings, two marks for demonstrating your understanding of MVVM principles, another two marks for your individual contribution to the project, and finally, one mark for the clarity of your communication.\n\nFinally, a few important notes from the examiner. The primary focus of this assessment is on your understanding of the concepts, not on mere memorization. We want to see that you truly grasp the \"why\" behind your implementations. And crucially, you will be penalized for the presence of code-behind logic, as this directly contradicts the MVVM principles we expect you to apply.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "• Encourage students to explain design decisions \n• Each team having a team leader, using GitHub to store the project, branch then merge \nfor the final submission \n• Each team must have a brainstorming for the project (visualation using any mindmap \napplication), checkin along with code.  \n \n12. Expected Learning Outcomes \nAfter the exam, students should be able to: \n• Design MAUI UI using XAML confidently \n• Apply data binding correctly \n• Explain MVVM principles verbally \n• Read and reason about XAML code \n \nEnd of Oral Exam Design",
        "notes": "",
        "total_slides": 5,
        "generated_text": "To ensure a structured and effective project development process, we strongly encourage students to clearly explain their design decisions. This isn't just about showing your work, but about articulating the 'why' behind your choices, fostering critical thinking and communication skills.\n\nFor team dynamics, each group will designate a team leader to coordinate efforts. We expect professional version control practices to be followed, specifically using GitHub to store your project. This includes utilizing branching for individual work and then merging these branches for the final submission, mirroring industry standards for collaborative development.\n\nA crucial first step for every team is a thorough brainstorming session for their project. We recommend visualizing these ideas using any mind-mapping application. The output of this creative process should be documented and submitted alongside your code, demonstrating your initial thought process and planning.\n\nNow, let's turn our attention to the expected learning outcomes from this module. Upon successful completion, students should confidently be able to design MAUI user interfaces using XAML. This includes creating intuitive and responsive layouts. You will also demonstrate the ability to apply data binding correctly, a fundamental skill for building dynamic and maintainable applications. Furthermore, you will be able to articulate and explain MVVM principles verbally, showcasing your understanding of this essential architectural pattern. Finally, you will develop the skill to read and reason effectively about existing XAML code, which is vital for debugging, collaboration, and understanding complex UI structures.\n\nThis concludes the overview of our oral exam design and project guidelines. Thank you.",
        "edited_text": "To ensure a structured and effective project development process, we strongly encourage students to clearly explain their design decisions. This isn't just about showing your work, but about articulating the 'why' behind your choices, fostering critical thinking and communication skills.\n\nFor team dynamics, each group will designate a team leader to coordinate efforts. We expect professional version control practices to be followed, specifically using GitHub to store your project. This includes utilizing branching for individual work and then merging these branches for the final submission, mirroring industry standards for collaborative development.\n\nA crucial first step for every team is a thorough brainstorming session for their project. We recommend visualizing these ideas using any mind-mapping application. The output of this creative process should be documented and submitted alongside your code, demonstrating your initial thought process and planning.\n\nNow, let's turn our attention to the expected learning outcomes from this module. Upon successful completion, students should confidently be able to design MAUI user interfaces using XAML. This includes creating intuitive and responsive layouts. You will also demonstrate the ability to apply data binding correctly, a fundamental skill for building dynamic and maintainable applications. Furthermore, you will be able to articulate and explain MVVM principles verbally, showcasing your understanding of this essential architectural pattern. Finally, you will develop the skill to read and reason effectively about existing XAML code, which is vital for debugging, collaboration, and understanding complex UI structures.\n\nThis concludes the overview of our oral exam design and project guidelines. Thank you.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-31 16:13:36",
    "avatar_path": null,
    "final_video_path": null
  },
  "9b57f887-1786-4dae-988e-646ab414c030": {
    "id": "9b57f887-1786-4dae-988e-646ab414c030",
    "filename": "ORAL_EXAM_DESIGN.pdf",
    "file_path": "static/uploads/presentations/9b57f887-1786-4dae-988e-646ab414c030/ORAL_EXAM_DESIGN.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "ORAL EXAM DESIGN \n.NET MAUI – XAML UI & Data Binding (CommunityToolkit.Mvvm) \n \n1. Exam Overview \nExam Type: Practical + Oral Examination \nFormat: Team-based (2 students / team) \nNumber of Teams: 13 teams \nTotal Duration per Team: 2 hours 10 minutes \n• Part 1: Practical UI Project – 2 hours \n• Part 2: Oral Examination – 10 minutes \n \n2. Exam Objectives \nThis oral exam aims to assess students’ ability to: \n• Design UI layouts using XAML in .NET MAUI \n• Correctly apply data binding techniques \n• Implement MVVM pattern using CommunityToolkit.Mvvm \n• Explain and justify technical decisions verbally \n• Demonstrate individual understanding within a team project \n \n3. Allowed Resources \n• Visual Studio 2022 or later \n• .NET MAUI project template \n• Internet access for documentation only \n• NuGet package: CommunityToolkit.Mvvm \n  No pre-written project code allowed \n \n4. Part 1 – Practical Project (2 Hours) \nGeneral Requirements (All Teams) \nEach team must build a single-screen MAUI application with: \n• UI designed in XAML \n• MVVM architecture \n• At least 4 different binding techniques",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning, everyone. Today, we're going to walk through the design of your upcoming oral exam, which focuses specifically on .NET MAUI, XAML UI, and data binding, leveraging the Community Toolkit MVVM.\n\nFirst, let's cover the exam overview. This will be a practical plus oral examination, conducted in teams of two students. We have thirteen teams in total participating. Each team will have a total duration of two hours and ten minutes. This time is divided into two distinct parts: a two-hour practical UI project, followed by a ten-minute oral examination.\n\nNow, regarding the objectives of this oral exam. We aim to assess your ability to design user interface layouts using XAML within .NET MAUI, correctly apply various data binding techniques, and implement the MVVM pattern effectively, utilizing the Community Toolkit MVVM. Beyond technical implementation, you'll also be expected to verbally explain and justify your technical decisions, and importantly, demonstrate your individual understanding even within the context of a team project.\n\nLet's clarify the resources you're allowed to use during the exam. You may use Visual Studio 2022 or later, the standard .NET MAUI project template, and importantly, internet access is permitted strictly for documentation purposes only. You will also need the NuGet package for Community Toolkit MVVM. Please note, no pre-written project code is allowed; all development must be done during the exam.\n\nMoving on to Part One, the practical project, which spans two hours. The general requirements for all teams are to build a single-screen MAUI application. This application must feature a UI designed entirely in XAML, adhere to an MVVM architecture, and demonstrate the use of at least four different binding techniques.",
        "edited_text": "Good morning, everyone. Today, we're going to walk through the design of your upcoming oral exam, which focuses specifically on .NET MAUI, XAML UI, and data binding, leveraging the Community Toolkit MVVM.\n\nFirst, let's cover the exam overview. This will be a practical plus oral examination, conducted in teams of two students. We have thirteen teams in total participating. Each team will have a total duration of two hours and ten minutes. This time is divided into two distinct parts: a two-hour practical UI project, followed by a ten-minute oral examination.\n\nNow, regarding the objectives of this oral exam. We aim to assess your ability to design user interface layouts using XAML within .NET MAUI, correctly apply various data binding techniques, and implement the MVVM pattern effectively, utilizing the Community Toolkit MVVM. Beyond technical implementation, you'll also be expected to verbally explain and justify your technical decisions, and importantly, demonstrate your individual understanding even within the context of a team project.\n\nLet's clarify the resources you're allowed to use during the exam. You may use Visual Studio 2022 or later, the standard .NET MAUI project template, and importantly, internet access is permitted strictly for documentation purposes only. You will also need the NuGet package for Community Toolkit MVVM. Please note, no pre-written project code is allowed; all development must be done during the exam.\n\nMoving on to Part One, the practical project, which spans two hours. The general requirements for all teams are to build a single-screen MAUI application. This application must feature a UI designed entirely in XAML, adhere to an MVVM architecture, and demonstrate the use of at least four different binding techniques.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "• No navigation between pages \n• No database or API \n \nMandatory Binding Techniques \nEach project must demonstrate: \n1. TwoWay Binding (Entry ↔ ViewModel) \n2. OneWay Binding (Display data) \n3. Command Binding (Button actions) \n4. ObservableCollection Binding (List update) \nAt least ONE advanced binding: \n• Converter \n• MultiBinding \n• RelativeSource \n• x:Reference \n \n5. Personalized Project Topics (14 Teams) \nEach team receives one unique UI scenario to prevent copying while keeping difficulty \nequivalent. \nTeam Assignments \nTeam Project Theme \n1 Grocery Shopping List \n2 Daily Habit Tracker \n3 Student Attendance UI \n4 Expense Tracker (UI only) \n5 Book Reading Tracker \n6 Workout Session Planner \n7 Movie Watchlist \n8 Meeting Agenda Manager \n9 Event Checklist",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning everyone. Let's discuss some important guidelines and requirements for our upcoming projects.\n\nFirst, to keep our focus sharp and development streamlined, we'll be working within a single-page context, meaning no navigation between different screens or pages. Furthermore, to emphasize front-end UI skills, projects will not involve external databases or APIs. All data handling will be managed within the application itself.\n\nNow, let's move on to the mandatory binding techniques you must demonstrate in your projects. Each project needs to clearly show:\n\nFirst, Two-Way Binding, which is crucial for user input fields where data flows both from the UI to the view model and vice versa.\nSecond, One-Way Binding, perfect for efficiently displaying data that doesn't need to be edited directly by the user.\nThird, Command Binding, which is essential for handling button clicks and other interactive actions within your application.\nAnd fourth, Observable Collection Binding, which is vital for dynamically updating lists or collections of items as data changes.\n\nBeyond these core techniques, each project must also demonstrate proficiency in at least one advanced binding concept. You'll have the flexibility to choose from powerful options like Converters, Multi-binding, Relative Source, or x:Reference. This allows you to explore more sophisticated data presentation and manipulation.\n\nFinally, regarding project topics, we have fourteen teams, and each team will receive a personalized, unique UI scenario. This approach guarantees an equivalent level of difficulty across all projects while fostering individual creativity and preventing any copying. For instance, topics range from a Grocery Shopping List to a Daily Habit Tracker, a Student Attendance UI, or even a Movie Watchlist, ensuring a diverse and engaging set of challenges for everyone.",
        "edited_text": "Good morning everyone. Let's discuss some important guidelines and requirements for our upcoming projects.\n\nFirst, to keep our focus sharp and development streamlined, we'll be working within a single-page context, meaning no navigation between different screens or pages. Furthermore, to emphasize front-end UI skills, projects will not involve external databases or APIs. All data handling will be managed within the application itself.\n\nNow, let's move on to the mandatory binding techniques you must demonstrate in your projects. Each project needs to clearly show:\n\nFirst, Two-Way Binding, which is crucial for user input fields where data flows both from the UI to the view model and vice versa.\nSecond, One-Way Binding, perfect for efficiently displaying data that doesn't need to be edited directly by the user.\nThird, Command Binding, which is essential for handling button clicks and other interactive actions within your application.\nAnd fourth, Observable Collection Binding, which is vital for dynamically updating lists or collections of items as data changes.\n\nBeyond these core techniques, each project must also demonstrate proficiency in at least one advanced binding concept. You'll have the flexibility to choose from powerful options like Converters, Multi-binding, Relative Source, or x:Reference. This allows you to explore more sophisticated data presentation and manipulation.\n\nFinally, regarding project topics, we have fourteen teams, and each team will receive a personalized, unique UI scenario. This approach guarantees an equivalent level of difficulty across all projects while fostering individual creativity and preventing any copying. For instance, topics range from a Grocery Shopping List to a Daily Habit Tracker, a Student Attendance UI, or even a Movie Watchlist, ensuring a diverse and engaging set of challenges for everyone.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Team Project Theme \n10 Smart Home Device Panel \n11 Plant Care Reminder UI \n12 Simple Note Organizer \n13 Classroom Equipment Checklist \nAll projects must follow the same technical constraints, only the UI content differs. \n \n6. Minimum Feature Set (Example) \nEach project should include: \n• Title header \n• Input section (Entry) \n• Action button(s) \n• List display (CollectionView) \n• Status indicator (Label / CheckBox / Switch) \n• Summary section (count, status, or description) \n \n7. Part 2 – Oral Examination (10 Minutes) \nStructure \n• 5 minutes: Project demonstration \n• 5 minutes: Oral questions (individual) \nBoth students must answer questions. \n \n8. Oral Question Bank (Examiner Chooses) \nUI & XAML (Basic) \n• Why did you choose Grid instead of StackLayout? \n• Explain the role of CollectionView in your UI. \nData Binding \n• Explain the difference between OneWay and TwoWay binding. \n• Why is ObservableCollection required? \nMVVM & Toolkit",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning everyone. Let's go over some important details for your upcoming team project. You have four distinct themes to choose from: a Smart Home Device Panel, a Plant Care Reminder user interface, a Simple Note Organizer, or a Classroom Equipment Checklist. While the specific UI content will differ based on your chosen theme, it's crucial to remember that all projects must adhere to the same underlying technical constraints.\n\nNow, regarding the minimum feature set, each project, regardless of its theme, must include several core components. This means every application should feature a clear title header, an input section for user entry, and at least one action button. You'll also need a list display, typically implemented using a CollectionView, a status indicator such as a label, checkbox, or switch, and a summary section that provides a count, status, or description.\n\nMoving on to Part Two, the oral examination. This segment will be ten minutes in total. The first five minutes are allocated for your project demonstration, where you'll showcase your application's functionality. This will be followed by five minutes of individual oral questions. It's very important to note that both students on the team must be prepared to answer these questions.\n\nTo help you prepare, here is a glimpse into the types of questions you might encounter, though the examiner will choose from a broader bank. We'll be looking at your understanding of UI and XAML basics. For instance, you might be asked to explain your design choices, such as why you opted for a Grid layout instead of a StackLayout, or to elaborate on the specific role of a CollectionView in your user interface. Data binding is another key area. Be ready to explain the difference between OneWay and TwoWay binding, and why an ObservableCollection is a necessary component in certain scenarios. Finally, expect questions related to MVVM and the Toolkit. Make sure you understand these architectural patterns and tools thoroughly.",
        "edited_text": "Good morning everyone. Let's go over some important details for your upcoming team project. You have four distinct themes to choose from: a Smart Home Device Panel, a Plant Care Reminder user interface, a Simple Note Organizer, or a Classroom Equipment Checklist. While the specific UI content will differ based on your chosen theme, it's crucial to remember that all projects must adhere to the same underlying technical constraints.\n\nNow, regarding the minimum feature set, each project, regardless of its theme, must include several core components. This means every application should feature a clear title header, an input section for user entry, and at least one action button. You'll also need a list display, typically implemented using a CollectionView, a status indicator such as a label, checkbox, or switch, and a summary section that provides a count, status, or description.\n\nMoving on to Part Two, the oral examination. This segment will be ten minutes in total. The first five minutes are allocated for your project demonstration, where you'll showcase your application's functionality. This will be followed by five minutes of individual oral questions. It's very important to note that both students on the team must be prepared to answer these questions.\n\nTo help you prepare, here is a glimpse into the types of questions you might encounter, though the examiner will choose from a broader bank. We'll be looking at your understanding of UI and XAML basics. For instance, you might be asked to explain your design choices, such as why you opted for a Grid layout instead of a StackLayout, or to elaborate on the specific role of a CollectionView in your user interface. Data binding is another key area. Be ready to explain the difference between OneWay and TwoWay binding, and why an ObservableCollection is a necessary component in certain scenarios. Finally, expect questions related to MVVM and the Toolkit. Make sure you understand these architectural patterns and tools thoroughly.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "• What problem does CommunityToolkit.Mvvm solve? \n• Explain [ObservableProperty] and [RelayCommand]. \nAdvanced Binding (If Used) \n• Why did you use a converter here? \n• Explain how MultiBinding works in your project. \n \n9. Individual Assessment Strategy \nTo ensure fairness: \n• Examiner asks different questions to each student \n• Each student must explain at least one binding used \n• Examiner may ask one student to modify a binding verbally \n \n10. Grading Rubric (20 Marks) \nPractical Project – 12 Marks \nCriteria Marks \nUI layout correctness 3 \nCorrect binding usage 4 \nMVVM structure 3 \nCode clarity & organization 2 \nOral Examination – 8 Marks \nCriteria Marks \nExplanation of bindings 3 \nMVVM understanding 2 \nIndividual contribution 2 \nCommunication clarity 1 \n \n11. Examiner Notes \n• Focus on understanding, not memorization \n• Penalize code-behind logic",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Let's begin by outlining some key discussion points. First, we'll explore the fundamental problem that CommunityToolkit dot M V V M is designed to address. Then, we'll delve into the specifics of key components like Observable Property and Relay Command, understanding their roles and how they function. If advanced binding techniques were employed, be prepared to explain your rationale. For instance, why did you opt to use a converter in a particular scenario? And if MultiBinding was utilized, please elaborate on its implementation within your project.\n\nMoving on to the individual assessment strategy, designed to ensure fairness and a comprehensive evaluation. The examiner will pose distinct questions to each student. Every student is expected to explain at least one binding they've implemented. Additionally, the examiner might ask a student to verbally describe how they would modify an existing binding.\n\nNext, let's clarify the grading rubric, which totals twenty marks. The practical project accounts for twelve of these marks. Three marks are allocated for the correctness of your user interface layout. Four marks are for the correct usage of bindings. Your M V V M structure will earn you three marks, and two marks are for code clarity and organization. The oral examination contributes the remaining eight marks. Three marks here are for your explanation of bindings. Two marks for your understanding of M V V M principles, another two marks for your individual contribution, and finally, one mark for the clarity of your communication.\n\nFinally, a few important notes for the examiner. The primary focus should be on assessing genuine understanding, rather than rote memorization. And it's crucial to penalize the use of logic within code-behind files, reinforcing best practices.",
        "edited_text": "Let's begin by outlining some key discussion points. First, we'll explore the fundamental problem that CommunityToolkit dot M V V M is designed to address. Then, we'll delve into the specifics of key components like Observable Property and Relay Command, understanding their roles and how they function. If advanced binding techniques were employed, be prepared to explain your rationale. For instance, why did you opt to use a converter in a particular scenario? And if MultiBinding was utilized, please elaborate on its implementation within your project.\n\nMoving on to the individual assessment strategy, designed to ensure fairness and a comprehensive evaluation. The examiner will pose distinct questions to each student. Every student is expected to explain at least one binding they've implemented. Additionally, the examiner might ask a student to verbally describe how they would modify an existing binding.\n\nNext, let's clarify the grading rubric, which totals twenty marks. The practical project accounts for twelve of these marks. Three marks are allocated for the correctness of your user interface layout. Four marks are for the correct usage of bindings. Your M V V M structure will earn you three marks, and two marks are for code clarity and organization. The oral examination contributes the remaining eight marks. Three marks here are for your explanation of bindings. Two marks for your understanding of M V V M principles, another two marks for your individual contribution, and finally, one mark for the clarity of your communication.\n\nFinally, a few important notes for the examiner. The primary focus should be on assessing genuine understanding, rather than rote memorization. And it's crucial to penalize the use of logic within code-behind files, reinforcing best practices.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "• Encourage students to explain design decisions \n• Each team having a team leader, using GitHub to store the project, branch then merge \nfor the final submission \n• Each team must have a brainstorming for the project (visualation using any mindmap \napplication), checkin along with code.  \n \n12. Expected Learning Outcomes \nAfter the exam, students should be able to: \n• Design MAUI UI using XAML confidently \n• Apply data binding correctly \n• Explain MVVM principles verbally \n• Read and reason about XAML code \n \nEnd of Oral Exam Design",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Let's delve into some crucial aspects of our project methodology and the expected learning outcomes from the upcoming oral examination.\n\nTo foster a deeper understanding and critical thinking, students will be encouraged to articulate and justify their design decisions. This isn't just about presenting work, but explaining the rationale and thought process behind every choice made.\n\nRegarding team dynamics and project management, each team will designate a team leader. This leader will guide the collaboration, which will primarily utilize GitHub for project storage. The workflow will involve standard branching and merging procedures, culminating in a final merge for the submission. This approach reinforces industry-standard version control practices and collaborative development skills.\n\nFurthermore, a vital initial step for every team is thorough brainstorming for the project. We expect a clear visualization of your project ideas, perhaps through a mind-mapping application, to be documented and checked in alongside your code. This ensures a well-thought-out foundation and a transparent development process from conception to completion.\n\nMoving on, let's look at the expected learning outcomes. After successfully completing this exam, students should confidently demonstrate several key abilities.\n\nFirstly, you should be able to design intuitive and functional MAUI user interfaces using XAML with confidence. This showcases your practical application skills in modern UI development.\n\nSecondly, the correct application of data binding is crucial, ensuring your applications are robust, responsive, and maintainable.\n\nThirdly, we expect you to be able to verbally explain the principles of the Model-View-ViewModel, or MVVM, architectural pattern. This demonstrates your theoretical understanding and ability to articulate complex software design concepts.\n\nAnd finally, a core skill is the ability to read and critically reason about XAML code. This involves not just understanding what the code does, but why it is structured a certain way and how it can be improved or maintained.\n\nThese are the core competencies we aim for you to achieve by the conclusion of this oral exam design. We look forward to seeing your progress and understanding.",
        "edited_text": "Let's delve into some crucial aspects of our project methodology and the expected learning outcomes from the upcoming oral examination.\n\nTo foster a deeper understanding and critical thinking, students will be encouraged to articulate and justify their design decisions. This isn't just about presenting work, but explaining the rationale and thought process behind every choice made.\n\nRegarding team dynamics and project management, each team will designate a team leader. This leader will guide the collaboration, which will primarily utilize GitHub for project storage. The workflow will involve standard branching and merging procedures, culminating in a final merge for the submission. This approach reinforces industry-standard version control practices and collaborative development skills.\n\nFurthermore, a vital initial step for every team is thorough brainstorming for the project. We expect a clear visualization of your project ideas, perhaps through a mind-mapping application, to be documented and checked in alongside your code. This ensures a well-thought-out foundation and a transparent development process from conception to completion.\n\nMoving on, let's look at the expected learning outcomes. After successfully completing this exam, students should confidently demonstrate several key abilities.\n\nFirstly, you should be able to design intuitive and functional MAUI user interfaces using XAML with confidence. This showcases your practical application skills in modern UI development.\n\nSecondly, the correct application of data binding is crucial, ensuring your applications are robust, responsive, and maintainable.\n\nThirdly, we expect you to be able to verbally explain the principles of the Model-View-ViewModel, or MVVM, architectural pattern. This demonstrates your theoretical understanding and ability to articulate complex software design concepts.\n\nAnd finally, a core skill is the ability to read and critically reason about XAML code. This involves not just understanding what the code does, but why it is structured a certain way and how it can be improved or maintained.\n\nThese are the core competencies we aim for you to achieve by the conclusion of this oral exam design. We look forward to seeing your progress and understanding.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-31 16:24:52",
    "avatar_path": null,
    "final_video_path": null
  },
  "d63adb86-5f32-41aa-ab03-682efa489599": {
    "id": "d63adb86-5f32-41aa-ab03-682efa489599",
    "filename": "ORAL_EXAM_DESIGN.pdf",
    "file_path": "static/uploads/presentations/d63adb86-5f32-41aa-ab03-682efa489599/ORAL_EXAM_DESIGN.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "ORAL EXAM DESIGN \n.NET MAUI – XAML UI & Data Binding (CommunityToolkit.Mvvm) \n \n1. Exam Overview \nExam Type: Practical + Oral Examination \nFormat: Team-based (2 students / team) \nNumber of Teams: 13 teams \nTotal Duration per Team: 2 hours 10 minutes \n• Part 1: Practical UI Project – 2 hours \n• Part 2: Oral Examination – 10 minutes \n \n2. Exam Objectives \nThis oral exam aims to assess students’ ability to: \n• Design UI layouts using XAML in .NET MAUI \n• Correctly apply data binding techniques \n• Implement MVVM pattern using CommunityToolkit.Mvvm \n• Explain and justify technical decisions verbally \n• Demonstrate individual understanding within a team project \n \n3. Allowed Resources \n• Visual Studio 2022 or later \n• .NET MAUI project template \n• Internet access for documentation only \n• NuGet package: CommunityToolkit.Mvvm \n  No pre-written project code allowed \n \n4. Part 1 – Practical Project (2 Hours) \nGeneral Requirements (All Teams) \nEach team must build a single-screen MAUI application with: \n• UI designed in XAML \n• MVVM architecture \n• At least 4 different binding techniques",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning, everyone. Today, I'd like to walk you through the design of our upcoming oral examination, specifically focusing on .NET MAUI, XAML UI, and Data Binding, utilizing the Community Toolkit MVVM.\n\nFirst, let's cover the exam overview. This assessment is a hybrid approach, combining a practical project with an oral examination. You'll be working in teams of two students, and we have a total of thirteen teams participating. Each team will have a dedicated two hours and ten minutes for the entire process. This duration is split into two distinct parts: a two-hour practical UI project, followed by a ten-minute oral examination.\n\nOur primary goal with this exam is to assess your proficiency in several key areas. We want to see your ability to design user interface layouts effectively using XAML within .NET MAUI, and to correctly apply various data binding techniques. Furthermore, we'll be evaluating your skill in implementing the MVVM pattern using the Community Toolkit MVVM. Beyond technical implementation, you'll also need to verbally explain and justify your technical decisions, and importantly, demonstrate your individual understanding within the context of your team's project.\n\nNow, regarding allowed resources. During the exam, you'll have access to Visual Studio 2022 or later, along with the standard .NET MAUI project template. Internet access is permitted strictly for documentation purposes only; no other web browsing is allowed. You may also use the NuGet package for Community Toolkit MVVM. A crucial point to remember is that no pre-written project code is allowed; all development must occur during the exam period.\n\nFinally, let's delve into Part 1: the practical project, which spans a full two hours. The general requirements for all teams are to build a single-screen MAUI application. This application must feature a UI designed entirely in XAML, adhere to the MVVM architectural pattern, and incorporate at least four different data binding techniques.\n\nThank you. I hope this clarifies the structure and expectations for your upcoming exam.",
        "edited_text": "Good morning, everyone. Today, I'd like to walk you through the design of our upcoming oral examination, specifically focusing on .NET MAUI, XAML UI, and Data Binding, utilizing the Community Toolkit MVVM.\n\nFirst, let's cover the exam overview. This assessment is a hybrid approach, combining a practical project with an oral examination. You'll be working in teams of two students, and we have a total of thirteen teams participating. Each team will have a dedicated two hours and ten minutes for the entire process. This duration is split into two distinct parts: a two-hour practical UI project, followed by a ten-minute oral examination.\n\nOur primary goal with this exam is to assess your proficiency in several key areas. We want to see your ability to design user interface layouts effectively using XAML within .NET MAUI, and to correctly apply various data binding techniques. Furthermore, we'll be evaluating your skill in implementing the MVVM pattern using the Community Toolkit MVVM. Beyond technical implementation, you'll also need to verbally explain and justify your technical decisions, and importantly, demonstrate your individual understanding within the context of your team's project.\n\nNow, regarding allowed resources. During the exam, you'll have access to Visual Studio 2022 or later, along with the standard .NET MAUI project template. Internet access is permitted strictly for documentation purposes only; no other web browsing is allowed. You may also use the NuGet package for Community Toolkit MVVM. A crucial point to remember is that no pre-written project code is allowed; all development must occur during the exam period.\n\nFinally, let's delve into Part 1: the practical project, which spans a full two hours. The general requirements for all teams are to build a single-screen MAUI application. This application must feature a UI designed entirely in XAML, adhere to the MVVM architectural pattern, and incorporate at least four different data binding techniques.\n\nThank you. I hope this clarifies the structure and expectations for your upcoming exam.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "• No navigation between pages \n• No database or API \n \nMandatory Binding Techniques \nEach project must demonstrate: \n1. TwoWay Binding (Entry ↔ ViewModel) \n2. OneWay Binding (Display data) \n3. Command Binding (Button actions) \n4. ObservableCollection Binding (List update) \nAt least ONE advanced binding: \n• Converter \n• MultiBinding \n• RelativeSource \n• x:Reference \n \n5. Personalized Project Topics (14 Teams) \nEach team receives one unique UI scenario to prevent copying while keeping difficulty \nequivalent. \nTeam Assignments \nTeam Project Theme \n1 Grocery Shopping List \n2 Daily Habit Tracker \n3 Student Attendance UI \n4 Expense Tracker (UI only) \n5 Book Reading Tracker \n6 Workout Session Planner \n7 Movie Watchlist \n8 Meeting Agenda Manager \n9 Event Checklist",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning, everyone. Let's discuss some important guidelines for our upcoming project. First, to clarify the scope, please note that this project will focus specifically on UI interactions. Therefore, there will be no navigation between different pages, nor will we be integrating with any external databases or APIs. This allows us to concentrate our efforts on mastering the core UI concepts.\n\nNow, regarding mandatory binding techniques, each project must clearly demonstrate proficiency in four key areas. You'll need to implement Two-Way Binding, which allows data synchronization between your entry fields and the ViewModel. We also require One-Way Binding for effectively displaying data to the user. Command Binding is essential for handling button actions and other interactive elements. And finally, Observable Collection Binding will be crucial for dynamically updating lists and collections within your UI.\n\nBeyond these core requirements, each project must also incorporate at least one advanced binding technique. You can choose from options such as a Converter, MultiBinding, RelativeSource, or x:Reference. This ensures you explore more sophisticated UI development patterns.\n\nTo ensure fairness and encourage individual innovation across our fourteen teams, each team will receive a unique UI scenario. This approach prevents direct copying while maintaining an equivalent level of difficulty for everyone. Let me give you a glimpse of some of the diverse project themes assigned. For example, Team 1 will be working on a Grocery Shopping List, while Team 2 has a Daily Habit Tracker. We also have a Student Attendance UI for Team 3, an Expense Tracker for Team 4, and a Book Reading Tracker for Team 5. Other themes include a Workout Session Planner, a Movie Watchlist, a Meeting Agenda Manager, and an Event Checklist. These varied topics will provide rich opportunities to apply your binding knowledge.",
        "edited_text": "Good morning, everyone. Let's discuss some important guidelines for our upcoming project. First, to clarify the scope, please note that this project will focus specifically on UI interactions. Therefore, there will be no navigation between different pages, nor will we be integrating with any external databases or APIs. This allows us to concentrate our efforts on mastering the core UI concepts.\n\nNow, regarding mandatory binding techniques, each project must clearly demonstrate proficiency in four key areas. You'll need to implement Two-Way Binding, which allows data synchronization between your entry fields and the ViewModel. We also require One-Way Binding for effectively displaying data to the user. Command Binding is essential for handling button actions and other interactive elements. And finally, Observable Collection Binding will be crucial for dynamically updating lists and collections within your UI.\n\nBeyond these core requirements, each project must also incorporate at least one advanced binding technique. You can choose from options such as a Converter, MultiBinding, RelativeSource, or x:Reference. This ensures you explore more sophisticated UI development patterns.\n\nTo ensure fairness and encourage individual innovation across our fourteen teams, each team will receive a unique UI scenario. This approach prevents direct copying while maintaining an equivalent level of difficulty for everyone. Let me give you a glimpse of some of the diverse project themes assigned. For example, Team 1 will be working on a Grocery Shopping List, while Team 2 has a Daily Habit Tracker. We also have a Student Attendance UI for Team 3, an Expense Tracker for Team 4, and a Book Reading Tracker for Team 5. Other themes include a Workout Session Planner, a Movie Watchlist, a Meeting Agenda Manager, and an Event Checklist. These varied topics will provide rich opportunities to apply your binding knowledge.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Team Project Theme \n10 Smart Home Device Panel \n11 Plant Care Reminder UI \n12 Simple Note Organizer \n13 Classroom Equipment Checklist \nAll projects must follow the same technical constraints, only the UI content differs. \n \n6. Minimum Feature Set (Example) \nEach project should include: \n• Title header \n• Input section (Entry) \n• Action button(s) \n• List display (CollectionView) \n• Status indicator (Label / CheckBox / Switch) \n• Summary section (count, status, or description) \n \n7. Part 2 – Oral Examination (10 Minutes) \nStructure \n• 5 minutes: Project demonstration \n• 5 minutes: Oral questions (individual) \nBoth students must answer questions. \n \n8. Oral Question Bank (Examiner Chooses) \nUI & XAML (Basic) \n• Why did you choose Grid instead of StackLayout? \n• Explain the role of CollectionView in your UI. \nData Binding \n• Explain the difference between OneWay and TwoWay binding. \n• Why is ObservableCollection required? \nMVVM & Toolkit",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Let's review some important details regarding your upcoming team project, covering the available themes, required features, and the structure of the oral examination.\n\nFirst, for your team project theme, you have several options. These include developing a Smart Home Device Panel, a Plant Care Reminder user interface, a Simple Note Organizer, or a Classroom Equipment Checklist. It's crucial to understand that while the specific user interface content will naturally differ across these projects, all of them must adhere to the exact same technical constraints.\n\nTo ensure consistency and a baseline level of functionality, each project is expected to incorporate a minimum set of features. This includes a clear title header, an input section for data entry, and one or more action buttons for user interaction. You will also need a list display, often implemented using a CollectionView, a status indicator such as a label, checkbox, or switch, and a summary section to provide a count, status, or description of the project's content.\n\nMoving on to the oral examination, this second part of your assessment will be ten minutes in total. It will be structured into two distinct five-minute segments. The first five minutes are dedicated to a demonstration of your project, showcasing its functionality. Following that, there will be five minutes for individual oral questions. Please note that both students from each team are expected to answer questions during this segment.\n\nTo help you prepare, we've provided an example question bank, from which the examiner will choose. Questions will cover topics such as UI and XAML basics; for instance, you might be asked why you chose Grid instead of StackLayout, or to explain the role of CollectionView in your UI. We'll also delve into data binding concepts, like the difference between OneWay and TwoWay binding, and why an ObservableCollection is required. Finally, be ready for questions related to MVVM and the Toolkit.\n\nThis covers the essential details for your team project and oral examination. Please review these points carefully as you prepare.",
        "edited_text": "Let's review some important details regarding your upcoming team project, covering the available themes, required features, and the structure of the oral examination.\n\nFirst, for your team project theme, you have several options. These include developing a Smart Home Device Panel, a Plant Care Reminder user interface, a Simple Note Organizer, or a Classroom Equipment Checklist. It's crucial to understand that while the specific user interface content will naturally differ across these projects, all of them must adhere to the exact same technical constraints.\n\nTo ensure consistency and a baseline level of functionality, each project is expected to incorporate a minimum set of features. This includes a clear title header, an input section for data entry, and one or more action buttons for user interaction. You will also need a list display, often implemented using a CollectionView, a status indicator such as a label, checkbox, or switch, and a summary section to provide a count, status, or description of the project's content.\n\nMoving on to the oral examination, this second part of your assessment will be ten minutes in total. It will be structured into two distinct five-minute segments. The first five minutes are dedicated to a demonstration of your project, showcasing its functionality. Following that, there will be five minutes for individual oral questions. Please note that both students from each team are expected to answer questions during this segment.\n\nTo help you prepare, we've provided an example question bank, from which the examiner will choose. Questions will cover topics such as UI and XAML basics; for instance, you might be asked why you chose Grid instead of StackLayout, or to explain the role of CollectionView in your UI. We'll also delve into data binding concepts, like the difference between OneWay and TwoWay binding, and why an ObservableCollection is required. Finally, be ready for questions related to MVVM and the Toolkit.\n\nThis covers the essential details for your team project and oral examination. Please review these points carefully as you prepare.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "• What problem does CommunityToolkit.Mvvm solve? \n• Explain [ObservableProperty] and [RelayCommand]. \nAdvanced Binding (If Used) \n• Why did you use a converter here? \n• Explain how MultiBinding works in your project. \n \n9. Individual Assessment Strategy \nTo ensure fairness: \n• Examiner asks different questions to each student \n• Each student must explain at least one binding used \n• Examiner may ask one student to modify a binding verbally \n \n10. Grading Rubric (20 Marks) \nPractical Project – 12 Marks \nCriteria Marks \nUI layout correctness 3 \nCorrect binding usage 4 \nMVVM structure 3 \nCode clarity & organization 2 \nOral Examination – 8 Marks \nCriteria Marks \nExplanation of bindings 3 \nMVVM understanding 2 \nIndividual contribution 2 \nCommunication clarity 1 \n \n11. Examiner Notes \n• Focus on understanding, not memorization \n• Penalize code-behind logic",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning everyone. Today, we're going to walk through some key areas and the assessment strategy for your project. First, we'll be exploring the core problem that Community Toolkit MVVM aims to solve, and we'll delve into the practical applications of ObservableProperty and RelayCommand. These are fundamental to building responsive and maintainable applications.\n\nMoving on to advanced binding techniques, if you've used them, be prepared to explain your choices. Specifically, we'll discuss why you might have opted for a converter in a particular scenario and how MultiBinding functions within your project. Understanding the 'why' behind your implementation is just as crucial as the 'how'.\n\nNow, let's look at the individual assessment strategy, designed to ensure fairness for everyone. The examiner will ask different questions to each student, tailoring the discussion to your specific project. Each of you must be ready to explain at least one binding you've used in your work. Furthermore, the examiner may ask one student to verbally modify a binding to assess your understanding and adaptability.\n\nRegarding the grading rubric, your project will be assessed out of a total of twenty marks. Twelve marks are allocated to the practical project itself. This breaks down as follows: three marks for UI layout correctness, four marks for correct binding usage, three marks for your MVVM structure, and two marks for the overall clarity and organization of your code. The remaining eight marks are for the oral examination. Here, three marks are for your explanation of bindings, two marks for your understanding of MVVM principles, two marks for your individual contribution to the project, and one mark for the clarity of your communication.\n\nFinally, a few important notes for the examiner, which are also good guidelines for you. The focus will always be on your understanding of the concepts, not on memorization. We want to see that you grasp the principles. Additionally, please be aware that code-behind logic will be penalized, as we are emphasizing adherence to the MVVM pattern.",
        "edited_text": "Good morning everyone. Today, we're going to walk through some key areas and the assessment strategy for your project. First, we'll be exploring the core problem that Community Toolkit MVVM aims to solve, and we'll delve into the practical applications of ObservableProperty and RelayCommand. These are fundamental to building responsive and maintainable applications.\n\nMoving on to advanced binding techniques, if you've used them, be prepared to explain your choices. Specifically, we'll discuss why you might have opted for a converter in a particular scenario and how MultiBinding functions within your project. Understanding the 'why' behind your implementation is just as crucial as the 'how'.\n\nNow, let's look at the individual assessment strategy, designed to ensure fairness for everyone. The examiner will ask different questions to each student, tailoring the discussion to your specific project. Each of you must be ready to explain at least one binding you've used in your work. Furthermore, the examiner may ask one student to verbally modify a binding to assess your understanding and adaptability.\n\nRegarding the grading rubric, your project will be assessed out of a total of twenty marks. Twelve marks are allocated to the practical project itself. This breaks down as follows: three marks for UI layout correctness, four marks for correct binding usage, three marks for your MVVM structure, and two marks for the overall clarity and organization of your code. The remaining eight marks are for the oral examination. Here, three marks are for your explanation of bindings, two marks for your understanding of MVVM principles, two marks for your individual contribution to the project, and one mark for the clarity of your communication.\n\nFinally, a few important notes for the examiner, which are also good guidelines for you. The focus will always be on your understanding of the concepts, not on memorization. We want to see that you grasp the principles. Additionally, please be aware that code-behind logic will be penalized, as we are emphasizing adherence to the MVVM pattern.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "• Encourage students to explain design decisions \n• Each team having a team leader, using GitHub to store the project, branch then merge \nfor the final submission \n• Each team must have a brainstorming for the project (visualation using any mindmap \napplication), checkin along with code.  \n \n12. Expected Learning Outcomes \nAfter the exam, students should be able to: \n• Design MAUI UI using XAML confidently \n• Apply data binding correctly \n• Explain MVVM principles verbally \n• Read and reason about XAML code \n \nEnd of Oral Exam Design",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning everyone. Let's delve into some key aspects of our project and the expected outcomes.\n\nTo foster a deeper understanding and critical thinking, students will be actively encouraged to articulate and justify their design decisions throughout the project. This is crucial for developing strong problem-solving skills.\n\nRegarding team dynamics and project management, each team will operate with a designated team leader. They will utilize industry-standard practices, leveraging GitHub to store their project, employing branching for individual work, and then merging for the final submission. This approach ensures effective collaboration and adherence to best practices in version control. Furthermore, every team is required to conduct a thorough brainstorming session for their project, visualizing their ideas using a mind map application. This initial planning documentation must be checked in along with their code, emphasizing the importance of a well-defined development process.\n\nMoving on, let's outline the expected learning outcomes from this examination. After completing the assessment, students should confidently be able to design MAUI user interfaces using XAML. They will also demonstrate the ability to apply data binding correctly within their applications. A key outcome is the capacity to explain MVVM principles verbally, showcasing a clear understanding of this architectural pattern. Finally, students will develop the critical skill of reading and reasoning effectively about XAML code, enabling them to comprehend and debug complex UI structures.\n\nThis concludes our overview of the oral exam design.",
        "edited_text": "Good morning everyone. Let's delve into some key aspects of our project and the expected outcomes.\n\nTo foster a deeper understanding and critical thinking, students will be actively encouraged to articulate and justify their design decisions throughout the project. This is crucial for developing strong problem-solving skills.\n\nRegarding team dynamics and project management, each team will operate with a designated team leader. They will utilize industry-standard practices, leveraging GitHub to store their project, employing branching for individual work, and then merging for the final submission. This approach ensures effective collaboration and adherence to best practices in version control. Furthermore, every team is required to conduct a thorough brainstorming session for their project, visualizing their ideas using a mind map application. This initial planning documentation must be checked in along with their code, emphasizing the importance of a well-defined development process.\n\nMoving on, let's outline the expected learning outcomes from this examination. After completing the assessment, students should confidently be able to design MAUI user interfaces using XAML. They will also demonstrate the ability to apply data binding correctly within their applications. A key outcome is the capacity to explain MVVM principles verbally, showcasing a clear understanding of this architectural pattern. Finally, students will develop the critical skill of reading and reasoning effectively about XAML code, enabling them to comprehend and debug complex UI structures.\n\nThis concludes our overview of the oral exam design.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-31 16:34:55",
    "avatar_path": null,
    "final_video_path": null
  },
  "60900d9f-bfcb-46d7-aa75-fa6593a2dcf3": {
    "id": "60900d9f-bfcb-46d7-aa75-fa6593a2dcf3",
    "filename": "ORAL_EXAM_DESIGN.pdf",
    "file_path": "static/uploads/presentations/60900d9f-bfcb-46d7-aa75-fa6593a2dcf3/ORAL_EXAM_DESIGN.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "ORAL EXAM DESIGN \n.NET MAUI – XAML UI & Data Binding (CommunityToolkit.Mvvm) \n \n1. Exam Overview \nExam Type: Practical + Oral Examination \nFormat: Team-based (2 students / team) \nNumber of Teams: 13 teams \nTotal Duration per Team: 2 hours 10 minutes \n• Part 1: Practical UI Project – 2 hours \n• Part 2: Oral Examination – 10 minutes \n \n2. Exam Objectives \nThis oral exam aims to assess students’ ability to: \n• Design UI layouts using XAML in .NET MAUI \n• Correctly apply data binding techniques \n• Implement MVVM pattern using CommunityToolkit.Mvvm \n• Explain and justify technical decisions verbally \n• Demonstrate individual understanding within a team project \n \n3. Allowed Resources \n• Visual Studio 2022 or later \n• .NET MAUI project template \n• Internet access for documentation only \n• NuGet package: CommunityToolkit.Mvvm \n  No pre-written project code allowed \n \n4. Part 1 – Practical Project (2 Hours) \nGeneral Requirements (All Teams) \nEach team must build a single-screen MAUI application with: \n• UI designed in XAML \n• MVVM architecture \n• At least 4 different binding techniques",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning, everyone. Today, we're going to walk through the design of your upcoming oral examination, focusing on .NET MAUI, XAML UI, and Data Binding, specifically using the Community Toolkit Dot MVVM.\n\nLet's start with an overview of the exam structure. This will be a combined practical and oral examination, conducted in teams of two students. We'll have thirteen teams participating. Each team will have a total of two hours and ten minutes. The bulk of this, two hours, is dedicated to the practical UI project, followed by a concise ten-minute oral examination where you'll present your work.\n\nMoving on to the objectives, this oral exam is designed to assess several key abilities. First, your proficiency in designing user interface layouts using XAML within the .NET MAUI framework. Second, your capability to correctly apply various data binding techniques. Third, we'll be looking at your implementation of the MVVM pattern, specifically utilizing the Community Toolkit Dot MVVM. Beyond the code, we also want to see your ability to verbally explain and justify your technical decisions, and importantly, how you demonstrate your individual understanding and contribution within your team project.\n\nRegarding resources, you are permitted to use Visual Studio 2022 or a later version, along with the standard .NET MAUI project template. Internet access will be provided strictly for documentation purposes only, meaning you can look up syntax or API references, but absolutely no pre-written project code or full solutions are allowed. You will also have access to the Community Toolkit Dot MVVM NuGet package.\n\nNow, let's look closer at Part 1, the two-hour practical project. Each team is required to build a single-screen MAUI application. This application must feature a user interface designed entirely in XAML, adhere to the MVVM architecture, and crucially, demonstrate the use of at least four different data binding techniques.\n\nThat concludes our overview of the oral exam design. Thank you.",
        "edited_text": "Good morning, everyone. Today, we're going to walk through the design of your upcoming oral examination, focusing on .NET MAUI, XAML UI, and Data Binding, specifically using the Community Toolkit Dot MVVM.\n\nLet's start with an overview of the exam structure. This will be a combined practical and oral examination, conducted in teams of two students. We'll have thirteen teams participating. Each team will have a total of two hours and ten minutes. The bulk of this, two hours, is dedicated to the practical UI project, followed by a concise ten-minute oral examination where you'll present your work.\n\nMoving on to the objectives, this oral exam is designed to assess several key abilities. First, your proficiency in designing user interface layouts using XAML within the .NET MAUI framework. Second, your capability to correctly apply various data binding techniques. Third, we'll be looking at your implementation of the MVVM pattern, specifically utilizing the Community Toolkit Dot MVVM. Beyond the code, we also want to see your ability to verbally explain and justify your technical decisions, and importantly, how you demonstrate your individual understanding and contribution within your team project.\n\nRegarding resources, you are permitted to use Visual Studio 2022 or a later version, along with the standard .NET MAUI project template. Internet access will be provided strictly for documentation purposes only, meaning you can look up syntax or API references, but absolutely no pre-written project code or full solutions are allowed. You will also have access to the Community Toolkit Dot MVVM NuGet package.\n\nNow, let's look closer at Part 1, the two-hour practical project. Each team is required to build a single-screen MAUI application. This application must feature a user interface designed entirely in XAML, adhere to the MVVM architecture, and crucially, demonstrate the use of at least four different data binding techniques.\n\nThat concludes our overview of the oral exam design. Thank you.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "• No navigation between pages \n• No database or API \n \nMandatory Binding Techniques \nEach project must demonstrate: \n1. TwoWay Binding (Entry ↔ ViewModel) \n2. OneWay Binding (Display data) \n3. Command Binding (Button actions) \n4. ObservableCollection Binding (List update) \nAt least ONE advanced binding: \n• Converter \n• MultiBinding \n• RelativeSource \n• x:Reference \n \n5. Personalized Project Topics (14 Teams) \nEach team receives one unique UI scenario to prevent copying while keeping difficulty \nequivalent. \nTeam Assignments \nTeam Project Theme \n1 Grocery Shopping List \n2 Daily Habit Tracker \n3 Student Attendance UI \n4 Expense Tracker (UI only) \n5 Book Reading Tracker \n6 Workout Session Planner \n7 Movie Watchlist \n8 Meeting Agenda Manager \n9 Event Checklist",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Alright everyone, let's discuss some important guidelines and requirements for our upcoming projects. First, it's crucial to understand a couple of fundamental constraints. For these projects, there will be no navigation between pages. We are focusing on single-page user interface designs. Additionally, you will not be interacting with any external databases or APIs; all data handling should be managed locally within your application.\n\nNow, let's move on to the mandatory binding techniques that each project must clearly demonstrate. You are required to implement Two-Way Binding, which is essential for ensuring data synchronization between your user interface entry fields and your ViewModel. Next, One-Way Binding must be used, primarily for effectively displaying data from your ViewModel to the UI. Command Binding is also mandatory to handle various button actions and user interactions within your application. And finally, for dynamic lists and collections, you must utilize Observable Collection Binding, ensuring that your user interface lists update automatically whenever the underlying data changes.\n\nBeyond these core techniques, each project must also incorporate at least one advanced binding method. You have several excellent options to choose from, including Converters, which are great for transforming data before display, MultiBinding, allowing you to combine multiple sources into a single target, RelativeSource binding for locating elements within the visual tree, or x:Reference for direct element referencing.\n\nTo ensure fairness and encourage individual creativity, we have personalized project topics for all fourteen teams. Each team will receive one unique UI scenario. This approach prevents direct copying while maintaining an equivalent level of difficulty across all assignments. For instance, some of the exciting project themes include creating a Grocery Shopping List, a Daily Habit Tracker, a Student Attendance UI, an Expense Tracker, a Book Reading Tracker, a Workout Session Planner, a Movie Watchlist, a Meeting Agenda Manager, or even an Event Checklist. These diverse topics will provide ample opportunity to apply all the required binding techniques effectively.",
        "edited_text": "Alright everyone, let's discuss some important guidelines and requirements for our upcoming projects. First, it's crucial to understand a couple of fundamental constraints. For these projects, there will be no navigation between pages. We are focusing on single-page user interface designs. Additionally, you will not be interacting with any external databases or APIs; all data handling should be managed locally within your application.\n\nNow, let's move on to the mandatory binding techniques that each project must clearly demonstrate. You are required to implement Two-Way Binding, which is essential for ensuring data synchronization between your user interface entry fields and your ViewModel. Next, One-Way Binding must be used, primarily for effectively displaying data from your ViewModel to the UI. Command Binding is also mandatory to handle various button actions and user interactions within your application. And finally, for dynamic lists and collections, you must utilize Observable Collection Binding, ensuring that your user interface lists update automatically whenever the underlying data changes.\n\nBeyond these core techniques, each project must also incorporate at least one advanced binding method. You have several excellent options to choose from, including Converters, which are great for transforming data before display, MultiBinding, allowing you to combine multiple sources into a single target, RelativeSource binding for locating elements within the visual tree, or x:Reference for direct element referencing.\n\nTo ensure fairness and encourage individual creativity, we have personalized project topics for all fourteen teams. Each team will receive one unique UI scenario. This approach prevents direct copying while maintaining an equivalent level of difficulty across all assignments. For instance, some of the exciting project themes include creating a Grocery Shopping List, a Daily Habit Tracker, a Student Attendance UI, an Expense Tracker, a Book Reading Tracker, a Workout Session Planner, a Movie Watchlist, a Meeting Agenda Manager, or even an Event Checklist. These diverse topics will provide ample opportunity to apply all the required binding techniques effectively.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Team Project Theme \n10 Smart Home Device Panel \n11 Plant Care Reminder UI \n12 Simple Note Organizer \n13 Classroom Equipment Checklist \nAll projects must follow the same technical constraints, only the UI content differs. \n \n6. Minimum Feature Set (Example) \nEach project should include: \n• Title header \n• Input section (Entry) \n• Action button(s) \n• List display (CollectionView) \n• Status indicator (Label / CheckBox / Switch) \n• Summary section (count, status, or description) \n \n7. Part 2 – Oral Examination (10 Minutes) \nStructure \n• 5 minutes: Project demonstration \n• 5 minutes: Oral questions (individual) \nBoth students must answer questions. \n \n8. Oral Question Bank (Examiner Chooses) \nUI & XAML (Basic) \n• Why did you choose Grid instead of StackLayout? \n• Explain the role of CollectionView in your UI. \nData Binding \n• Explain the difference between OneWay and TwoWay binding. \n• Why is ObservableCollection required? \nMVVM & Toolkit",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Alright team, let's go over some key details for your upcoming project.\n\nFirst, regarding the Team Project Theme, you have a selection of options to choose from. For example, you could develop a Smart Home Device Panel, a Plant Care Reminder user interface, a Simple Note Organizer, or a Classroom Equipment Checklist. It's important to remember that while the user interface content will differ across these projects, all of them must adhere to the same underlying technical constraints.\n\nMoving on to the Minimum Feature Set, each project is expected to include several core components. This includes a clear title header, an input section, typically an Entry field, for user interaction, and at least one action button. You'll also need a list display, which will likely be implemented using a CollectionView, and a status indicator, which could be a Label, CheckBox, or Switch. Finally, each project should incorporate a summary section, perhaps displaying a count, overall status, or a brief description.\n\nNow, let's talk about Part Two of the assessment, which is your Oral Examination. This will be a ten-minute session structured into two equal parts. The first five minutes will be dedicated to a demonstration of your project. Following this, the next five minutes will involve individual oral questions. Please note that both students in the team are expected to answer questions during this segment.\n\nTo give you an idea of the types of questions you might encounter, we have an Oral Question Bank from which the examiner will choose. In the UI and XAML basic category, you might be asked to explain your design choices, such as \"Why did you choose Grid instead of StackLayout?\" or \"Explain the role of CollectionView in your UI.\" When it comes to Data Binding, expect questions like \"Explain the difference between OneWay and TwoWay binding,\" or \"Why is ObservableCollection required?\" We also anticipate questions related to MVVM and the Toolkit, so be prepared in those areas as well.",
        "edited_text": "Alright team, let's go over some key details for your upcoming project.\n\nFirst, regarding the Team Project Theme, you have a selection of options to choose from. For example, you could develop a Smart Home Device Panel, a Plant Care Reminder user interface, a Simple Note Organizer, or a Classroom Equipment Checklist. It's important to remember that while the user interface content will differ across these projects, all of them must adhere to the same underlying technical constraints.\n\nMoving on to the Minimum Feature Set, each project is expected to include several core components. This includes a clear title header, an input section, typically an Entry field, for user interaction, and at least one action button. You'll also need a list display, which will likely be implemented using a CollectionView, and a status indicator, which could be a Label, CheckBox, or Switch. Finally, each project should incorporate a summary section, perhaps displaying a count, overall status, or a brief description.\n\nNow, let's talk about Part Two of the assessment, which is your Oral Examination. This will be a ten-minute session structured into two equal parts. The first five minutes will be dedicated to a demonstration of your project. Following this, the next five minutes will involve individual oral questions. Please note that both students in the team are expected to answer questions during this segment.\n\nTo give you an idea of the types of questions you might encounter, we have an Oral Question Bank from which the examiner will choose. In the UI and XAML basic category, you might be asked to explain your design choices, such as \"Why did you choose Grid instead of StackLayout?\" or \"Explain the role of CollectionView in your UI.\" When it comes to Data Binding, expect questions like \"Explain the difference between OneWay and TwoWay binding,\" or \"Why is ObservableCollection required?\" We also anticipate questions related to MVVM and the Toolkit, so be prepared in those areas as well.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "• What problem does CommunityToolkit.Mvvm solve? \n• Explain [ObservableProperty] and [RelayCommand]. \nAdvanced Binding (If Used) \n• Why did you use a converter here? \n• Explain how MultiBinding works in your project. \n \n9. Individual Assessment Strategy \nTo ensure fairness: \n• Examiner asks different questions to each student \n• Each student must explain at least one binding used \n• Examiner may ask one student to modify a binding verbally \n \n10. Grading Rubric (20 Marks) \nPractical Project – 12 Marks \nCriteria Marks \nUI layout correctness 3 \nCorrect binding usage 4 \nMVVM structure 3 \nCode clarity & organization 2 \nOral Examination – 8 Marks \nCriteria Marks \nExplanation of bindings 3 \nMVVM understanding 2 \nIndividual contribution 2 \nCommunication clarity 1 \n \n11. Examiner Notes \n• Focus on understanding, not memorization \n• Penalize code-behind logic",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "• Encourage students to explain design decisions \n• Each team having a team leader, using GitHub to store the project, branch then merge \nfor the final submission \n• Each team must have a brainstorming for the project (visualation using any mindmap \napplication), checkin along with code.  \n \n12. Expected Learning Outcomes \nAfter the exam, students should be able to: \n• Design MAUI UI using XAML confidently \n• Apply data binding correctly \n• Explain MVVM principles verbally \n• Read and reason about XAML code \n \nEnd of Oral Exam Design",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-31 16:50:46",
    "avatar_path": null,
    "final_video_path": null
  },
  "47960495-fced-4cc0-9a85-0bef4a347b91": {
    "id": "47960495-fced-4cc0-9a85-0bef4a347b91",
    "filename": "ORAL_EXAM_DESIGN.pdf",
    "file_path": "static/uploads/presentations/47960495-fced-4cc0-9a85-0bef4a347b91/ORAL_EXAM_DESIGN.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "ORAL EXAM DESIGN \n.NET MAUI – XAML UI & Data Binding (CommunityToolkit.Mvvm) \n \n1. Exam Overview \nExam Type: Practical + Oral Examination \nFormat: Team-based (2 students / team) \nNumber of Teams: 13 teams \nTotal Duration per Team: 2 hours 10 minutes \n• Part 1: Practical UI Project – 2 hours \n• Part 2: Oral Examination – 10 minutes \n \n2. Exam Objectives \nThis oral exam aims to assess students’ ability to: \n• Design UI layouts using XAML in .NET MAUI \n• Correctly apply data binding techniques \n• Implement MVVM pattern using CommunityToolkit.Mvvm \n• Explain and justify technical decisions verbally \n• Demonstrate individual understanding within a team project \n \n3. Allowed Resources \n• Visual Studio 2022 or later \n• .NET MAUI project template \n• Internet access for documentation only \n• NuGet package: CommunityToolkit.Mvvm \n  No pre-written project code allowed \n \n4. Part 1 – Practical Project (2 Hours) \nGeneral Requirements (All Teams) \nEach team must build a single-screen MAUI application with: \n• UI designed in XAML \n• MVVM architecture \n• At least 4 different binding techniques",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning everyone. Today, we're going to walk through the design of our upcoming oral examination, focusing on .NET MAUI, XAML UI, and Data Binding with the Community Toolkit for MVVM.\n\nFirst, let's cover the exam overview. This will be a practical and oral examination, designed to assess both your hands-on skills and your understanding. It's a team-based format, with each team consisting of two students. We anticipate a total of thirteen teams participating. The total duration allocated per team is two hours and ten minutes. This time is divided into two parts: a two-hour practical UI project, followed by a concise ten-minute oral examination.\n\nMoving on to the core objectives. This oral exam aims to thoroughly assess your ability to design user interface layouts effectively using XAML within the .NET MAUI framework. You'll also be evaluated on your skill in correctly applying various data binding techniques. A key objective is your implementation of the MVVM pattern, specifically utilizing the Community Toolkit for MVVM. Furthermore, we want to see your capability to explain and justify your technical decisions verbally, and to demonstrate your individual understanding even within the context of a collaborative team project.\n\nRegarding the allowed resources for the exam, you will have access to Visual Studio 2022 or later, the standard .NET MAUI project template, and internet access strictly for documentation purposes only. You are also permitted to use the NuGet package for the Community Toolkit for MVVM. Please note, and this is crucial, no pre-written project code is allowed. You must start from scratch.\n\nFinally, for Part One, the two-hour practical project, here are the general requirements for all teams. Each team is tasked with building a single-screen MAUI application. This application must feature a user interface designed entirely in XAML, adhere to the MVVM architecture, and crucially, demonstrate the use of at least four different binding techniques.\n\nThank you.",
        "edited_text": "Good morning everyone. Today, we're going to walk through the design of our upcoming oral examination, focusing on .NET MAUI, XAML UI, and Data Binding with the Community Toolkit for MVVM.\n\nFirst, let's cover the exam overview. This will be a practical and oral examination, designed to assess both your hands-on skills and your understanding. It's a team-based format, with each team consisting of two students. We anticipate a total of thirteen teams participating. The total duration allocated per team is two hours and ten minutes. This time is divided into two parts: a two-hour practical UI project, followed by a concise ten-minute oral examination.\n\nMoving on to the core objectives. This oral exam aims to thoroughly assess your ability to design user interface layouts effectively using XAML within the .NET MAUI framework. You'll also be evaluated on your skill in correctly applying various data binding techniques. A key objective is your implementation of the MVVM pattern, specifically utilizing the Community Toolkit for MVVM. Furthermore, we want to see your capability to explain and justify your technical decisions verbally, and to demonstrate your individual understanding even within the context of a collaborative team project.\n\nRegarding the allowed resources for the exam, you will have access to Visual Studio 2022 or later, the standard .NET MAUI project template, and internet access strictly for documentation purposes only. You are also permitted to use the NuGet package for the Community Toolkit for MVVM. Please note, and this is crucial, no pre-written project code is allowed. You must start from scratch.\n\nFinally, for Part One, the two-hour practical project, here are the general requirements for all teams. Each team is tasked with building a single-screen MAUI application. This application must feature a user interface designed entirely in XAML, adhere to the MVVM architecture, and crucially, demonstrate the use of at least four different binding techniques.\n\nThank you.",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/47960495-fced-4cc0-9a85-0bef4a347b91/slide_1.wav",
        "audio_file_path": "/app/app/../static/audio/47960495-fced-4cc0-9a85-0bef4a347b91/slide_1.wav"
      },
      {
        "slide_num": 2,
        "content": "• No navigation between pages \n• No database or API \n \nMandatory Binding Techniques \nEach project must demonstrate: \n1. TwoWay Binding (Entry ↔ ViewModel) \n2. OneWay Binding (Display data) \n3. Command Binding (Button actions) \n4. ObservableCollection Binding (List update) \nAt least ONE advanced binding: \n• Converter \n• MultiBinding \n• RelativeSource \n• x:Reference \n \n5. Personalized Project Topics (14 Teams) \nEach team receives one unique UI scenario to prevent copying while keeping difficulty \nequivalent. \nTeam Assignments \nTeam Project Theme \n1 Grocery Shopping List \n2 Daily Habit Tracker \n3 Student Attendance UI \n4 Expense Tracker (UI only) \n5 Book Reading Tracker \n6 Workout Session Planner \n7 Movie Watchlist \n8 Meeting Agenda Manager \n9 Event Checklist",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Team Project Theme \n10 Smart Home Device Panel \n11 Plant Care Reminder UI \n12 Simple Note Organizer \n13 Classroom Equipment Checklist \nAll projects must follow the same technical constraints, only the UI content differs. \n \n6. Minimum Feature Set (Example) \nEach project should include: \n• Title header \n• Input section (Entry) \n• Action button(s) \n• List display (CollectionView) \n• Status indicator (Label / CheckBox / Switch) \n• Summary section (count, status, or description) \n \n7. Part 2 – Oral Examination (10 Minutes) \nStructure \n• 5 minutes: Project demonstration \n• 5 minutes: Oral questions (individual) \nBoth students must answer questions. \n \n8. Oral Question Bank (Examiner Chooses) \nUI & XAML (Basic) \n• Why did you choose Grid instead of StackLayout? \n• Explain the role of CollectionView in your UI. \nData Binding \n• Explain the difference between OneWay and TwoWay binding. \n• Why is ObservableCollection required? \nMVVM & Toolkit",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "• What problem does CommunityToolkit.Mvvm solve? \n• Explain [ObservableProperty] and [RelayCommand]. \nAdvanced Binding (If Used) \n• Why did you use a converter here? \n• Explain how MultiBinding works in your project. \n \n9. Individual Assessment Strategy \nTo ensure fairness: \n• Examiner asks different questions to each student \n• Each student must explain at least one binding used \n• Examiner may ask one student to modify a binding verbally \n \n10. Grading Rubric (20 Marks) \nPractical Project – 12 Marks \nCriteria Marks \nUI layout correctness 3 \nCorrect binding usage 4 \nMVVM structure 3 \nCode clarity & organization 2 \nOral Examination – 8 Marks \nCriteria Marks \nExplanation of bindings 3 \nMVVM understanding 2 \nIndividual contribution 2 \nCommunication clarity 1 \n \n11. Examiner Notes \n• Focus on understanding, not memorization \n• Penalize code-behind logic",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "• Encourage students to explain design decisions \n• Each team having a team leader, using GitHub to store the project, branch then merge \nfor the final submission \n• Each team must have a brainstorming for the project (visualation using any mindmap \napplication), checkin along with code.  \n \n12. Expected Learning Outcomes \nAfter the exam, students should be able to: \n• Design MAUI UI using XAML confidently \n• Apply data binding correctly \n• Explain MVVM principles verbally \n• Read and reason about XAML code \n \nEnd of Oral Exam Design",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-31 18:57:45",
    "avatar_path": null,
    "final_video_path": null
  },
  "b5a3dd0c-4c01-41aa-bc30-fc3a9731d0c6": {
    "id": "b5a3dd0c-4c01-41aa-bc30-fc3a9731d0c6",
    "filename": "Maui_Xaml_Binding_Lab_Handout.pdf",
    "file_path": "static/uploads/presentations\\b5a3dd0c-4c01-41aa-bc30-fc3a9731d0c6\\Maui_Xaml_Binding_Lab_Handout.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "LAB HANDOUT \nMAUI XAML Binding Practice with CommunityToolkit.Mvvm \n \nCourse / Module \nMobile Application Development (.NET MAUI) \nLab Title \nTask Manager – XAML Data Binding & MVVM Toolkit \nDuration \n3 hours (180 minutes) \nLab Type \nIndividual – Hands-on Practice \n \n1. Lab Objectives \nAfter completing this lab, students will be able to: \n• Explain the purpose of data binding in .NET MAUI \n• Apply MVVM pattern using CommunityToolkit.Mvvm \n• Correctly use common binding modes in XAML \n• Bind UI elements to ViewModel properties and commands \n• Use converters and MultiBinding in real UI scenarios \n \n2. Software & Tools \n• Visual Studio 2022 or later \n• .NET MAUI workload installed \n• NuGet package: \no CommunityToolkit.Mvvm",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "3. Problem Description \nYou are required to build a single-screen Task Manager application using .NET MAUI \n(XAML). \nThe application allows users to: - Enter a task name - Add the task to a list - Mark tasks as \ncompleted - View task statistics (total and completed) \n    Constraints - No navigation between pages - No database or API - No code-\nbehind logic for UI behavior - All interactions must be implemented using data \nbinding and commands \n \n4. User Interface Specification \nMain Screen Components \n1. Application title: MY TASKS \n2. Text input for new task \n3. Add button \n4. Task list (CollectionView) \n5. Checkbox for task completion \n6. Summary section displaying: \no Total tasks \no Completed tasks \n \n5. Required Binding Types \nYour solution must demonstrate the following bindings: \nNo Binding Type Required Usage \n1 OneWay Display task title \n2 TwoWay Entry ↔ ViewModel property \n3 OneWayToSource Selected task \n4 Command Add task action \n5 RelativeSource Access ViewModel from item template \n6 x:Reference UI-to-UI binding \n7 Converter Completed task text style \n8 MultiBinding Summary text \n9 ObservableCollection Auto-update task list \n10 INotifyPropertyChanged ViewModel updates",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "6. Data Model \nCreate a TaskItem model that contains: \n• Title (string) \n• IsCompleted (bool) \nThe model must inherit from ObservableObject. \n \n7. ViewModel Requirements \nCreate TasksViewModel with the following: \nProperties \n• NewTaskTitle (string) \n• Tasks (ObservableCollection) \n• SelectedTask (TaskItem) \n• TotalCount (int) \n• CompletedCount (int) \nCommands \n• AddTaskCommand \nUse [ObservableProperty] and [RelayCommand] attributes where applicable. \n \n8. XAML Requirements \n• Bind Entry.Text using TwoWay binding \n• Bind Button.Command to ViewModel command \n• Use CollectionView for task list \n• Bind CheckBox.IsChecked using TwoWay binding \n• Use a Value Converter to apply strikethrough to completed tasks \n• Use MultiBinding for summary text \n• Use x:Reference at least once \n \n9. Suggested Lab Steps \n1. Create a new .NET MAUI project",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "2. Install CommunityToolkit.Mvvm \n3. Create the model class \n4. Create the ViewModel \n5. Design the UI in XAML \n6. Apply required bindings \n7. Test UI behavior \n \n10. Assessment Rubric (10 Marks) \nCriteria Marks \nCorrect MVVM structure 2 \nProper use of binding modes 3 \nCommand implementation 2 \nConverter & MultiBinding 2 \nUI completeness & clarity 1 \n \n11. Submission Requirements \nStudents must submit: \n• Source code folder or Git repository \n• Screenshot of running application \n \n12. Notes \n• Code-behind should be minimal or empty \n• Focus on binding correctness, not UI aesthetics \n• Naming conventions and clean structure are required \n \nEnd of Lab",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-02-01 06:50:52",
    "avatar_path": null,
    "final_video_path": null
  },
  "815d3ecd-a2e8-4a2e-adf4-40109b636b16": {
    "id": "815d3ecd-a2e8-4a2e-adf4-40109b636b16",
    "filename": "Maui_Xaml_Binding_Lab_Handout.pdf",
    "file_path": "static/uploads/presentations\\815d3ecd-a2e8-4a2e-adf4-40109b636b16\\Maui_Xaml_Binding_Lab_Handout.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "LAB HANDOUT \nMAUI XAML Binding Practice with CommunityToolkit.Mvvm \n \nCourse / Module \nMobile Application Development (.NET MAUI) \nLab Title \nTask Manager – XAML Data Binding & MVVM Toolkit \nDuration \n3 hours (180 minutes) \nLab Type \nIndividual – Hands-on Practice \n \n1. Lab Objectives \nAfter completing this lab, students will be able to: \n• Explain the purpose of data binding in .NET MAUI \n• Apply MVVM pattern using CommunityToolkit.Mvvm \n• Correctly use common binding modes in XAML \n• Bind UI elements to ViewModel properties and commands \n• Use converters and MultiBinding in real UI scenarios \n \n2. Software & Tools \n• Visual Studio 2022 or later \n• .NET MAUI workload installed \n• NuGet package: \no CommunityToolkit.Mvvm",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "3. Problem Description \nYou are required to build a single-screen Task Manager application using .NET MAUI \n(XAML). \nThe application allows users to: - Enter a task name - Add the task to a list - Mark tasks as \ncompleted - View task statistics (total and completed) \n    Constraints - No navigation between pages - No database or API - No code-\nbehind logic for UI behavior - All interactions must be implemented using data \nbinding and commands \n \n4. User Interface Specification \nMain Screen Components \n1. Application title: MY TASKS \n2. Text input for new task \n3. Add button \n4. Task list (CollectionView) \n5. Checkbox for task completion \n6. Summary section displaying: \no Total tasks \no Completed tasks \n \n5. Required Binding Types \nYour solution must demonstrate the following bindings: \nNo Binding Type Required Usage \n1 OneWay Display task title \n2 TwoWay Entry ↔ ViewModel property \n3 OneWayToSource Selected task \n4 Command Add task action \n5 RelativeSource Access ViewModel from item template \n6 x:Reference UI-to-UI binding \n7 Converter Completed task text style \n8 MultiBinding Summary text \n9 ObservableCollection Auto-update task list \n10 INotifyPropertyChanged ViewModel updates",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "6. Data Model \nCreate a TaskItem model that contains: \n• Title (string) \n• IsCompleted (bool) \nThe model must inherit from ObservableObject. \n \n7. ViewModel Requirements \nCreate TasksViewModel with the following: \nProperties \n• NewTaskTitle (string) \n• Tasks (ObservableCollection) \n• SelectedTask (TaskItem) \n• TotalCount (int) \n• CompletedCount (int) \nCommands \n• AddTaskCommand \nUse [ObservableProperty] and [RelayCommand] attributes where applicable. \n \n8. XAML Requirements \n• Bind Entry.Text using TwoWay binding \n• Bind Button.Command to ViewModel command \n• Use CollectionView for task list \n• Bind CheckBox.IsChecked using TwoWay binding \n• Use a Value Converter to apply strikethrough to completed tasks \n• Use MultiBinding for summary text \n• Use x:Reference at least once \n \n9. Suggested Lab Steps \n1. Create a new .NET MAUI project",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "2. Install CommunityToolkit.Mvvm \n3. Create the model class \n4. Create the ViewModel \n5. Design the UI in XAML \n6. Apply required bindings \n7. Test UI behavior \n \n10. Assessment Rubric (10 Marks) \nCriteria Marks \nCorrect MVVM structure 2 \nProper use of binding modes 3 \nCommand implementation 2 \nConverter & MultiBinding 2 \nUI completeness & clarity 1 \n \n11. Submission Requirements \nStudents must submit: \n• Source code folder or Git repository \n• Screenshot of running application \n \n12. Notes \n• Code-behind should be minimal or empty \n• Focus on binding correctness, not UI aesthetics \n• Naming conventions and clean structure are required \n \nEnd of Lab",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-02-01 06:52:48",
    "avatar_path": null,
    "final_video_path": null
  },
  "458bc704-7fbd-4521-9388-2b0b6638d388": {
    "id": "458bc704-7fbd-4521-9388-2b0b6638d388",
    "filename": "Maui_Xaml_Binding_Lab_Handout.pdf",
    "file_path": "static/uploads/presentations\\458bc704-7fbd-4521-9388-2b0b6638d388\\Maui_Xaml_Binding_Lab_Handout.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "LAB HANDOUT \nMAUI XAML Binding Practice with CommunityToolkit.Mvvm \n \nCourse / Module \nMobile Application Development (.NET MAUI) \nLab Title \nTask Manager – XAML Data Binding & MVVM Toolkit \nDuration \n3 hours (180 minutes) \nLab Type \nIndividual – Hands-on Practice \n \n1. Lab Objectives \nAfter completing this lab, students will be able to: \n• Explain the purpose of data binding in .NET MAUI \n• Apply MVVM pattern using CommunityToolkit.Mvvm \n• Correctly use common binding modes in XAML \n• Bind UI elements to ViewModel properties and commands \n• Use converters and MultiBinding in real UI scenarios \n \n2. Software & Tools \n• Visual Studio 2022 or later \n• .NET MAUI workload installed \n• NuGet package: \no CommunityToolkit.Mvvm",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Welcome everyone. Today, we are introducing an important hands-on lab focused on .NET MAUI XAML Binding practice, specifically utilizing the Community Toolkit MVVM. This lab is an integral part of our Mobile Application Development course, designed to enhance your skills in building robust mobile applications.\n\nThe title of this particular lab is \"Task Manager – XAML Data Binding & MVVM Toolkit.\" It is structured as an individual, hands-on practice session, and we anticipate it will take approximately three hours, or one hundred and eighty minutes, to complete thoroughly.\n\nLet's quickly go over the key objectives for this lab. By the end of this session, you will be able to clearly explain the fundamental purpose of data binding within the .NET MAUI framework. You will also gain practical experience in applying the MVVM pattern effectively using the Community Toolkit MVVM. Furthermore, you will learn to correctly implement common binding modes in XAML, and expertly bind various UI elements to ViewModel properties and commands. Finally, we will explore how to integrate converters and MultiBinding in real-world user interface scenarios, providing you with a comprehensive understanding of advanced data binding techniques.\n\nTo successfully complete this lab, you will need a few essential software and tools. Please ensure you have Visual Studio 2022 or a later version installed on your system. It is also crucial to have the .NET MAUI workload properly installed within Visual Studio. Lastly, you will need to install a specific NuGet package, which is the Community Toolkit Dot MVVM. This toolkit is central to our MVVM implementation in this lab.\n\nWe are excited for you to dive into this practical exercise and strengthen your .NET MAUI development skills.",
        "edited_text": "Welcome everyone. Today, we are introducing an important hands-on lab focused on .NET MAUI XAML Binding practice, specifically utilizing the Community Toolkit MVVM. This lab is an integral part of our Mobile Application Development course, designed to enhance your skills in building robust mobile applications.\n\nThe title of this particular lab is \"Task Manager – XAML Data Binding & MVVM Toolkit.\" It is structured as an individual, hands-on practice session, and we anticipate it will take approximately three hours, or one hundred and eighty minutes, to complete thoroughly.\n\nLet's quickly go over the key objectives for this lab. By the end of this session, you will be able to clearly explain the fundamental purpose of data binding within the .NET MAUI framework. You will also gain practical experience in applying the MVVM pattern effectively using the Community Toolkit MVVM. Furthermore, you will learn to correctly implement common binding modes in XAML, and expertly bind various UI elements to ViewModel properties and commands. Finally, we will explore how to integrate converters and MultiBinding in real-world user interface scenarios, providing you with a comprehensive understanding of advanced data binding techniques.\n\nTo successfully complete this lab, you will need a few essential software and tools. Please ensure you have Visual Studio 2022 or a later version installed on your system. It is also crucial to have the .NET MAUI workload properly installed within Visual Studio. Lastly, you will need to install a specific NuGet package, which is the Community Toolkit Dot MVVM. This toolkit is central to our MVVM implementation in this lab.\n\nWe are excited for you to dive into this practical exercise and strengthen your .NET MAUI development skills.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "3. Problem Description \nYou are required to build a single-screen Task Manager application using .NET MAUI \n(XAML). \nThe application allows users to: - Enter a task name - Add the task to a list - Mark tasks as \ncompleted - View task statistics (total and completed) \n    Constraints - No navigation between pages - No database or API - No code-\nbehind logic for UI behavior - All interactions must be implemented using data \nbinding and commands \n \n4. User Interface Specification \nMain Screen Components \n1. Application title: MY TASKS \n2. Text input for new task \n3. Add button \n4. Task list (CollectionView) \n5. Checkbox for task completion \n6. Summary section displaying: \no Total tasks \no Completed tasks \n \n5. Required Binding Types \nYour solution must demonstrate the following bindings: \nNo Binding Type Required Usage \n1 OneWay Display task title \n2 TwoWay Entry ↔ ViewModel property \n3 OneWayToSource Selected task \n4 Command Add task action \n5 RelativeSource Access ViewModel from item template \n6 x:Reference UI-to-UI binding \n7 Converter Completed task text style \n8 MultiBinding Summary text \n9 ObservableCollection Auto-update task list \n10 INotifyPropertyChanged ViewModel updates",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Alright team, let's dive into the specifics of our next project: building a robust Task Manager application.\n\nOur primary objective is to develop a single-screen Task Manager application, leveraging the power of .NET MAUI with XAML. This application is designed to be intuitive and efficient, allowing users to seamlessly manage their daily tasks. Users will be able to easily enter a new task name, add it to their personal list, and then, crucially, mark tasks as completed as they progress. Furthermore, the application will provide immediate insights through a summary of their task statistics, showing both the total number of tasks and those they've successfully completed.\n\nNow, for some key architectural constraints that will shape our development. To maintain simplicity and focus on core MAUI principles, this application will be a single-screen experience, meaning no navigation between pages. We'll also avoid external dependencies, operating without a database or API. Critically, all UI behavior will be implemented without code-behind logic; instead, we'll harness the full potential of data binding and commands for all user interactions.\n\nMoving on to the user interface, our main screen will be clean and functional. It will prominently feature an application title, \"MY TASKS,\" at the top. Below that, we'll have a clear text input field for entering new tasks, accompanied by a dedicated \"Add\" button. The core of our UI will be a CollectionView, displaying the task list, where each item will include a checkbox for marking completion. Finally, a summary section will provide at-a-glance information, showing the total number of tasks and how many have been completed.\n\nTo achieve this robust and responsive application, we're specifically challenged to demonstrate a comprehensive understanding of various data binding types. This solution must actively utilize OneWay binding for displaying task titles, TwoWay binding to seamlessly connect entry fields with our ViewModel properties, and OneWayToSource for handling selected tasks. We'll implement Command bindings for actions like adding a task, and RelativeSource binding will be crucial for accessing the ViewModel from within item templates. Furthermore, we'll use x:Reference for UI-to-UI binding scenarios, incorporate a Converter for styling completed task text, and leverage MultiBinding for our summary text display. Finally, to ensure our task list auto-updates dynamically, we'll rely on ObservableCollection, and for all ViewModel updates, INotifyPropertyChanged will be fundamental.",
        "edited_text": "Alright team, let's dive into the specifics of our next project: building a robust Task Manager application.\n\nOur primary objective is to develop a single-screen Task Manager application, leveraging the power of .NET MAUI with XAML. This application is designed to be intuitive and efficient, allowing users to seamlessly manage their daily tasks. Users will be able to easily enter a new task name, add it to their personal list, and then, crucially, mark tasks as completed as they progress. Furthermore, the application will provide immediate insights through a summary of their task statistics, showing both the total number of tasks and those they've successfully completed.\n\nNow, for some key architectural constraints that will shape our development. To maintain simplicity and focus on core MAUI principles, this application will be a single-screen experience, meaning no navigation between pages. We'll also avoid external dependencies, operating without a database or API. Critically, all UI behavior will be implemented without code-behind logic; instead, we'll harness the full potential of data binding and commands for all user interactions.\n\nMoving on to the user interface, our main screen will be clean and functional. It will prominently feature an application title, \"MY TASKS,\" at the top. Below that, we'll have a clear text input field for entering new tasks, accompanied by a dedicated \"Add\" button. The core of our UI will be a CollectionView, displaying the task list, where each item will include a checkbox for marking completion. Finally, a summary section will provide at-a-glance information, showing the total number of tasks and how many have been completed.\n\nTo achieve this robust and responsive application, we're specifically challenged to demonstrate a comprehensive understanding of various data binding types. This solution must actively utilize OneWay binding for displaying task titles, TwoWay binding to seamlessly connect entry fields with our ViewModel properties, and OneWayToSource for handling selected tasks. We'll implement Command bindings for actions like adding a task, and RelativeSource binding will be crucial for accessing the ViewModel from within item templates. Furthermore, we'll use x:Reference for UI-to-UI binding scenarios, incorporate a Converter for styling completed task text, and leverage MultiBinding for our summary text display. Finally, to ensure our task list auto-updates dynamically, we'll rely on ObservableCollection, and for all ViewModel updates, INotifyPropertyChanged will be fundamental.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "6. Data Model \nCreate a TaskItem model that contains: \n• Title (string) \n• IsCompleted (bool) \nThe model must inherit from ObservableObject. \n \n7. ViewModel Requirements \nCreate TasksViewModel with the following: \nProperties \n• NewTaskTitle (string) \n• Tasks (ObservableCollection) \n• SelectedTask (TaskItem) \n• TotalCount (int) \n• CompletedCount (int) \nCommands \n• AddTaskCommand \nUse [ObservableProperty] and [RelayCommand] attributes where applicable. \n \n8. XAML Requirements \n• Bind Entry.Text using TwoWay binding \n• Bind Button.Command to ViewModel command \n• Use CollectionView for task list \n• Bind CheckBox.IsChecked using TwoWay binding \n• Use a Value Converter to apply strikethrough to completed tasks \n• Use MultiBinding for summary text \n• Use x:Reference at least once \n \n9. Suggested Lab Steps \n1. Create a new .NET MAUI project",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Alright, let's lay out the requirements for building our task application.\n\nFirst, let's define the core data model for our application. You'll need to create a TaskItem model, which will represent each individual task. This model will contain two key properties: a Title, which will be a string, and an IsCompleted boolean, indicating the task's status. Crucially, this TaskItem model must inherit from ObservableObject to ensure that any changes to its properties can be automatically reflected in the user interface.\n\nNow, for the ViewModel requirements. You'll create a TasksViewModel to manage the application's logic and data presentation. This ViewModel will include several essential properties: NewTaskTitle, to hold the text for a new task; an ObservableCollection named Tasks, which will store all your TaskItem objects; SelectedTask, to track the currently chosen task; and finally, TotalCount and CompletedCount, to provide a summary of your tasks. On the command front, you'll implement an AddTaskCommand. Remember to leverage the convenient ObservableProperty and RelayCommand attributes where appropriate to streamline your MVVM implementation.\n\nShifting our focus to the user interface, here are the key XAML requirements. You'll need to bind the Entry dot Text property using two-way binding, allowing users to input new task titles. Connect your Button dot Command to the ViewModel's AddTaskCommand. For displaying your list of tasks, utilize a CollectionView. Ensure the CheckBox dot IsChecked property is also bound two-way, so users can easily mark tasks as complete. To visually differentiate completed tasks, implement a Value Converter to apply a strikethrough effect. For your summary text, you'll employ MultiBinding to combine various pieces of data. And finally, make sure to use x colon Reference at least once within your XAML markup.\n\nTo kick things off with the lab, your very first step will be to create a new dot NET MAUI project.",
        "edited_text": "Alright, let's lay out the requirements for building our task application.\n\nFirst, let's define the core data model for our application. You'll need to create a TaskItem model, which will represent each individual task. This model will contain two key properties: a Title, which will be a string, and an IsCompleted boolean, indicating the task's status. Crucially, this TaskItem model must inherit from ObservableObject to ensure that any changes to its properties can be automatically reflected in the user interface.\n\nNow, for the ViewModel requirements. You'll create a TasksViewModel to manage the application's logic and data presentation. This ViewModel will include several essential properties: NewTaskTitle, to hold the text for a new task; an ObservableCollection named Tasks, which will store all your TaskItem objects; SelectedTask, to track the currently chosen task; and finally, TotalCount and CompletedCount, to provide a summary of your tasks. On the command front, you'll implement an AddTaskCommand. Remember to leverage the convenient ObservableProperty and RelayCommand attributes where appropriate to streamline your MVVM implementation.\n\nShifting our focus to the user interface, here are the key XAML requirements. You'll need to bind the Entry dot Text property using two-way binding, allowing users to input new task titles. Connect your Button dot Command to the ViewModel's AddTaskCommand. For displaying your list of tasks, utilize a CollectionView. Ensure the CheckBox dot IsChecked property is also bound two-way, so users can easily mark tasks as complete. To visually differentiate completed tasks, implement a Value Converter to apply a strikethrough effect. For your summary text, you'll employ MultiBinding to combine various pieces of data. And finally, make sure to use x colon Reference at least once within your XAML markup.\n\nTo kick things off with the lab, your very first step will be to create a new dot NET MAUI project.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "2. Install CommunityToolkit.Mvvm \n3. Create the model class \n4. Create the ViewModel \n5. Design the UI in XAML \n6. Apply required bindings \n7. Test UI behavior \n \n10. Assessment Rubric (10 Marks) \nCriteria Marks \nCorrect MVVM structure 2 \nProper use of binding modes 3 \nCommand implementation 2 \nConverter & MultiBinding 2 \nUI completeness & clarity 1 \n \n11. Submission Requirements \nStudents must submit: \n• Source code folder or Git repository \n• Screenshot of running application \n \n12. Notes \n• Code-behind should be minimal or empty \n• Focus on binding correctness, not UI aesthetics \n• Naming conventions and clean structure are required \n \nEnd of Lab",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Alright everyone, let's continue with the next steps for this lab, followed by a clear understanding of how your work will be assessed, and what you need to submit.\n\nFollowing our initial setup, your first practical task is to install the Community Toolkit dot MVVM package. This will provide the necessary framework for your project. After that, you'll proceed to create your model classes, which define the data structures, and then implement your ViewModels, responsible for presenting data and handling logic for your user interface. Once your backend is taking shape, you'll design the user interface in XAML, ensuring it aligns with your application's purpose. Crucially, you will then apply all the required bindings to connect your UI elements to your ViewModel properties and commands. Finally, make sure to thoroughly test your UI behavior to confirm everything is working as expected.\n\nNow, let's look at the assessment rubric, which accounts for a total of ten marks. Two marks are allocated for a correct MVVM structure, ensuring you've properly separated concerns. Three marks are for the proper use of binding modes, demonstrating your understanding of how data flows efficiently. You'll earn two marks for effective command implementation, showing how user interactions are handled cleanly. Another two marks are for your use of converters and multibinding techniques, which are vital for complex data presentation. Finally, one mark is for the overall completeness and clarity of your user interface.\n\nRegarding submission, students are required to provide two key items. First, either your complete source code folder or a link to your Git repository. Second, a clear screenshot of your running application, demonstrating its functionality.\n\nPlease pay close attention to these important notes. Your code-behind files should be minimal or, ideally, empty, as this reinforces the MVVM pattern. The primary focus of this assessment is on the correctness of your bindings, not necessarily on the aesthetic appeal of your UI. However, maintaining good naming conventions and a clean, organized structure throughout your code is absolutely required. This reflects professional development practices.\n\nAnd with that, we conclude the instructions for this lab. Good luck with your implementation!",
        "edited_text": "Alright everyone, let's continue with the next steps for this lab, followed by a clear understanding of how your work will be assessed, and what you need to submit.\n\nFollowing our initial setup, your first practical task is to install the Community Toolkit dot MVVM package. This will provide the necessary framework for your project. After that, you'll proceed to create your model classes, which define the data structures, and then implement your ViewModels, responsible for presenting data and handling logic for your user interface. Once your backend is taking shape, you'll design the user interface in XAML, ensuring it aligns with your application's purpose. Crucially, you will then apply all the required bindings to connect your UI elements to your ViewModel properties and commands. Finally, make sure to thoroughly test your UI behavior to confirm everything is working as expected.\n\nNow, let's look at the assessment rubric, which accounts for a total of ten marks. Two marks are allocated for a correct MVVM structure, ensuring you've properly separated concerns. Three marks are for the proper use of binding modes, demonstrating your understanding of how data flows efficiently. You'll earn two marks for effective command implementation, showing how user interactions are handled cleanly. Another two marks are for your use of converters and multibinding techniques, which are vital for complex data presentation. Finally, one mark is for the overall completeness and clarity of your user interface.\n\nRegarding submission, students are required to provide two key items. First, either your complete source code folder or a link to your Git repository. Second, a clear screenshot of your running application, demonstrating its functionality.\n\nPlease pay close attention to these important notes. Your code-behind files should be minimal or, ideally, empty, as this reinforces the MVVM pattern. The primary focus of this assessment is on the correctness of your bindings, not necessarily on the aesthetic appeal of your UI. However, maintaining good naming conventions and a clean, organized structure throughout your code is absolutely required. This reflects professional development practices.\n\nAnd with that, we conclude the instructions for this lab. Good luck with your implementation!",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-02-01 06:54:10",
    "avatar_path": null,
    "final_video_path": null
  },
  "f1eec7e0-9844-47f1-b534-921d42c8f87d": {
    "id": "f1eec7e0-9844-47f1-b534-921d42c8f87d",
    "filename": "Maui_Xaml_Binding_Lab_Handout.pdf",
    "file_path": "static/uploads/presentations\\f1eec7e0-9844-47f1-b534-921d42c8f87d\\Maui_Xaml_Binding_Lab_Handout.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "LAB HANDOUT \nMAUI XAML Binding Practice with CommunityToolkit.Mvvm \n \nCourse / Module \nMobile Application Development (.NET MAUI) \nLab Title \nTask Manager – XAML Data Binding & MVVM Toolkit \nDuration \n3 hours (180 minutes) \nLab Type \nIndividual – Hands-on Practice \n \n1. Lab Objectives \nAfter completing this lab, students will be able to: \n• Explain the purpose of data binding in .NET MAUI \n• Apply MVVM pattern using CommunityToolkit.Mvvm \n• Correctly use common binding modes in XAML \n• Bind UI elements to ViewModel properties and commands \n• Use converters and MultiBinding in real UI scenarios \n \n2. Software & Tools \n• Visual Studio 2022 or later \n• .NET MAUI workload installed \n• NuGet package: \no CommunityToolkit.Mvvm",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Hello everyone, and welcome to our latest hands-on lab session. Today, we're diving deep into some essential concepts for building robust and responsive mobile applications with .NET MAUI.\n\nThis lab, titled \"Task Manager – XAML Data Binding & MVVM Toolkit,\" is a core component of our Mobile Application Development course, specifically focusing on .NET MAUI. Over the next three hours, you'll engage in an individual, hands-on practice session designed to solidify your understanding of XAML data binding and the Model-View-ViewModel pattern using the powerful CommunityToolkit.Mvvm.\n\nBy the end of this lab, you will achieve several key objectives. You'll be able to clearly explain the fundamental purpose of data binding within .NET MAUI applications, understanding how it simplifies UI updates. You'll gain practical experience applying the MVVM pattern effectively using the CommunityToolkit.Mvvm library, which is crucial for creating maintainable and testable codebases. Furthermore, you'll learn to correctly utilize common binding modes in XAML, ensuring your UI behaves exactly as intended. We'll also cover how to seamlessly bind your user interface elements to ViewModel properties and commands, enabling dynamic interactions. Finally, you'll explore advanced UI scenarios by using converters and MultiBinding to transform and combine data for display.\n\nTo get started with this exciting lab, please ensure you have Visual Studio 2022 or a later version installed, along with the .NET MAUI workload. Additionally, you will need to install the CommunityToolkit.Mvvm NuGet package in your project. These tools will provide everything you need to successfully complete the exercises. Let's begin building some amazing applications!",
        "edited_text": "Hello everyone, and welcome to our latest hands-on lab session. Today, we're diving deep into some essential concepts for building robust and responsive mobile applications with .NET MAUI.\n\nThis lab, titled \"Task Manager – XAML Data Binding & MVVM Toolkit,\" is a core component of our Mobile Application Development course, specifically focusing on .NET MAUI. Over the next three hours, you'll engage in an individual, hands-on practice session designed to solidify your understanding of XAML data binding and the Model-View-ViewModel pattern using the powerful CommunityToolkit.Mvvm.\n\nBy the end of this lab, you will achieve several key objectives. You'll be able to clearly explain the fundamental purpose of data binding within .NET MAUI applications, understanding how it simplifies UI updates. You'll gain practical experience applying the MVVM pattern effectively using the CommunityToolkit.Mvvm library, which is crucial for creating maintainable and testable codebases. Furthermore, you'll learn to correctly utilize common binding modes in XAML, ensuring your UI behaves exactly as intended. We'll also cover how to seamlessly bind your user interface elements to ViewModel properties and commands, enabling dynamic interactions. Finally, you'll explore advanced UI scenarios by using converters and MultiBinding to transform and combine data for display.\n\nTo get started with this exciting lab, please ensure you have Visual Studio 2022 or a later version installed, along with the .NET MAUI workload. Additionally, you will need to install the CommunityToolkit.Mvvm NuGet package in your project. These tools will provide everything you need to successfully complete the exercises. Let's begin building some amazing applications!",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "3. Problem Description \nYou are required to build a single-screen Task Manager application using .NET MAUI \n(XAML). \nThe application allows users to: - Enter a task name - Add the task to a list - Mark tasks as \ncompleted - View task statistics (total and completed) \n    Constraints - No navigation between pages - No database or API - No code-\nbehind logic for UI behavior - All interactions must be implemented using data \nbinding and commands \n \n4. User Interface Specification \nMain Screen Components \n1. Application title: MY TASKS \n2. Text input for new task \n3. Add button \n4. Task list (CollectionView) \n5. Checkbox for task completion \n6. Summary section displaying: \no Total tasks \no Completed tasks \n \n5. Required Binding Types \nYour solution must demonstrate the following bindings: \nNo Binding Type Required Usage \n1 OneWay Display task title \n2 TwoWay Entry ↔ ViewModel property \n3 OneWayToSource Selected task \n4 Command Add task action \n5 RelativeSource Access ViewModel from item template \n6 x:Reference UI-to-UI binding \n7 Converter Completed task text style \n8 MultiBinding Summary text \n9 ObservableCollection Auto-update task list \n10 INotifyPropertyChanged ViewModel updates",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "6. Data Model \nCreate a TaskItem model that contains: \n• Title (string) \n• IsCompleted (bool) \nThe model must inherit from ObservableObject. \n \n7. ViewModel Requirements \nCreate TasksViewModel with the following: \nProperties \n• NewTaskTitle (string) \n• Tasks (ObservableCollection) \n• SelectedTask (TaskItem) \n• TotalCount (int) \n• CompletedCount (int) \nCommands \n• AddTaskCommand \nUse [ObservableProperty] and [RelayCommand] attributes where applicable. \n \n8. XAML Requirements \n• Bind Entry.Text using TwoWay binding \n• Bind Button.Command to ViewModel command \n• Use CollectionView for task list \n• Bind CheckBox.IsChecked using TwoWay binding \n• Use a Value Converter to apply strikethrough to completed tasks \n• Use MultiBinding for summary text \n• Use x:Reference at least once \n \n9. Suggested Lab Steps \n1. Create a new .NET MAUI project",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "2. Install CommunityToolkit.Mvvm \n3. Create the model class \n4. Create the ViewModel \n5. Design the UI in XAML \n6. Apply required bindings \n7. Test UI behavior \n \n10. Assessment Rubric (10 Marks) \nCriteria Marks \nCorrect MVVM structure 2 \nProper use of binding modes 3 \nCommand implementation 2 \nConverter & MultiBinding 2 \nUI completeness & clarity 1 \n \n11. Submission Requirements \nStudents must submit: \n• Source code folder or Git repository \n• Screenshot of running application \n \n12. Notes \n• Code-behind should be minimal or empty \n• Focus on binding correctness, not UI aesthetics \n• Naming conventions and clean structure are required \n \nEnd of Lab",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-02-01 06:55:30",
    "avatar_path": null,
    "final_video_path": null
  },
  "823d0a69-56a2-4dd1-b27b-c0d8da0f0522": {
    "id": "823d0a69-56a2-4dd1-b27b-c0d8da0f0522",
    "filename": "Maui_Xaml_Binding_Lab_Handout.pdf",
    "file_path": "static/uploads/presentations\\823d0a69-56a2-4dd1-b27b-c0d8da0f0522\\Maui_Xaml_Binding_Lab_Handout.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "LAB HANDOUT \nMAUI XAML Binding Practice with CommunityToolkit.Mvvm \n \nCourse / Module \nMobile Application Development (.NET MAUI) \nLab Title \nTask Manager – XAML Data Binding & MVVM Toolkit \nDuration \n3 hours (180 minutes) \nLab Type \nIndividual – Hands-on Practice \n \n1. Lab Objectives \nAfter completing this lab, students will be able to: \n• Explain the purpose of data binding in .NET MAUI \n• Apply MVVM pattern using CommunityToolkit.Mvvm \n• Correctly use common binding modes in XAML \n• Bind UI elements to ViewModel properties and commands \n• Use converters and MultiBinding in real UI scenarios \n \n2. Software & Tools \n• Visual Studio 2022 or later \n• .NET MAUI workload installed \n• NuGet package: \no CommunityToolkit.Mvvm",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Hello everyone, and welcome to our latest lab session. Today, we're diving into a crucial topic in mobile application development: MAUI XAML Binding Practice with the Community Toolkit MVVM.\n\nThis lab is an integral part of our Mobile Application Development using .NET MAUI course. Its specific title is \"Task Manager – XAML Data Binding and MVVM Toolkit.\" You should allocate approximately three hours, or one hundred and eighty minutes, to complete this lab. It is designed as an individual, hands-on practice session to ensure you gain practical experience.\n\nLet's look at the key objectives for this lab. By the end of this session, you will be able to clearly explain the fundamental purpose of data binding within .NET MAUI applications. You will also gain practical experience applying the MVVM architectural pattern, specifically leveraging the powerful Community Toolkit MVVM. We'll ensure you can correctly utilize common binding modes within XAML, a key skill for building responsive user interfaces. This includes effectively binding your user interface elements to ViewModel properties and commands, bringing your applications to life. And finally, you'll learn to implement advanced techniques such as converters and MultiBinding to tackle real-world user interface scenarios.\n\nTo get started with this lab, you'll need a few essential software and tools. Please ensure you have Visual Studio 2022 or a later version installed, along with the .NET MAUI workload. Additionally, you will need to install the Community Toolkit MVVM NuGet package within your project.\n\nWe're excited for you to dive in and enhance your .NET MAUI development skills!",
        "edited_text": "Hello everyone, and welcome to our latest lab session. Today, we're diving into a crucial topic in mobile application development: MAUI XAML Binding Practice with the Community Toolkit MVVM.\n\nThis lab is an integral part of our Mobile Application Development using .NET MAUI course. Its specific title is \"Task Manager – XAML Data Binding and MVVM Toolkit.\" You should allocate approximately three hours, or one hundred and eighty minutes, to complete this lab. It is designed as an individual, hands-on practice session to ensure you gain practical experience.\n\nLet's look at the key objectives for this lab. By the end of this session, you will be able to clearly explain the fundamental purpose of data binding within .NET MAUI applications. You will also gain practical experience applying the MVVM architectural pattern, specifically leveraging the powerful Community Toolkit MVVM. We'll ensure you can correctly utilize common binding modes within XAML, a key skill for building responsive user interfaces. This includes effectively binding your user interface elements to ViewModel properties and commands, bringing your applications to life. And finally, you'll learn to implement advanced techniques such as converters and MultiBinding to tackle real-world user interface scenarios.\n\nTo get started with this lab, you'll need a few essential software and tools. Please ensure you have Visual Studio 2022 or a later version installed, along with the .NET MAUI workload. Additionally, you will need to install the Community Toolkit MVVM NuGet package within your project.\n\nWe're excited for you to dive in and enhance your .NET MAUI development skills!",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/823d0a69-56a2-4dd1-b27b-c0d8da0f0522/slide_1.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\823d0a69-56a2-4dd1-b27b-c0d8da0f0522\\slide_1.wav"
      },
      {
        "slide_num": 2,
        "content": "3. Problem Description \nYou are required to build a single-screen Task Manager application using .NET MAUI \n(XAML). \nThe application allows users to: - Enter a task name - Add the task to a list - Mark tasks as \ncompleted - View task statistics (total and completed) \n    Constraints - No navigation between pages - No database or API - No code-\nbehind logic for UI behavior - All interactions must be implemented using data \nbinding and commands \n \n4. User Interface Specification \nMain Screen Components \n1. Application title: MY TASKS \n2. Text input for new task \n3. Add button \n4. Task list (CollectionView) \n5. Checkbox for task completion \n6. Summary section displaying: \no Total tasks \no Completed tasks \n \n5. Required Binding Types \nYour solution must demonstrate the following bindings: \nNo Binding Type Required Usage \n1 OneWay Display task title \n2 TwoWay Entry ↔ ViewModel property \n3 OneWayToSource Selected task \n4 Command Add task action \n5 RelativeSource Access ViewModel from item template \n6 x:Reference UI-to-UI binding \n7 Converter Completed task text style \n8 MultiBinding Summary text \n9 ObservableCollection Auto-update task list \n10 INotifyPropertyChanged ViewModel updates",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Good morning everyone. Today, we're going to dive into the specifications for building a practical, single-screen Task Manager application using .NET MAUI with XAML.\n\nFirst, let's outline the problem description. Your primary task is to develop a user-friendly application that allows users to perform several key actions. They should be able to easily enter a task name, add that task to a dynamic list, mark tasks as completed, and view essential statistics like the total number of tasks and how many have been completed.\n\nNow, it's crucial to understand the constraints for this project. We are specifically looking for a single-screen experience, meaning there should be no navigation between pages. Furthermore, the application must operate without any external dependencies, so no database or API integration is permitted. A significant requirement is to avoid code-behind logic for UI behavior; all interactions must be implemented purely using data binding and commands, emphasizing a clean separation of concerns.\n\nMoving on to the User Interface Specification, let's detail the main components you'll need to include on this single screen. At the very top, we'll have our application title, which should clearly state \"MY TASKS.\" Below that, users will find a text input field for entering new tasks, accompanied by an \"Add\" button to commit their entries. The core of the application will be a task list, implemented using a CollectionView, where each task will feature a checkbox for marking completion. Finally, a summary section is required to display the total number of tasks and the count of completed tasks.\n\nLastly, let's talk about the required binding types, as these are fundamental to meeting the project's architectural constraints. Your solution must demonstrate proficiency with several binding techniques. We'll need OneWay binding to display the task title efficiently. TwoWay binding will be essential for the interaction between entry fields and your ViewModel properties. OneWayToSource binding will handle the selection of a task, while Command binding will drive actions like adding a new task. RelativeSource binding will provide access to the ViewModel from within an item template, and x:Reference will enable direct UI-to-UI binding. For visual styling, a Value Converter will be used to style completed task text. MultiBinding will be leveraged for creating the summary text, and crucially, an ObservableCollection will ensure the task list automatically updates as tasks are added or removed. Finally, INotifyPropertyChanged is required within your ViewModel to ensure the UI reflects any property changes.\n\nBy adhering to these specifications and demonstrating these binding types, you'll create a robust and well-structured Task Manager application.",
        "edited_text": "Alright, let's outline the task at hand. We are focusing on building a single screen Task Manager application using .NET MAUI and XAML. This application is designed to be straightforward yet feature-rich, allowing users to efficiently manage their daily tasks.\n\nThe core functionalities include the ability for users to easily enter a task name, add that task to a dynamic list, and then mark tasks as completed once they are done. Furthermore, the application will provide immediate feedback by displaying key task statistics, specifically the total number of tasks and how many of them have been completed.\n\nNow, it's important to highlight some key constraints and design principles for this project. To keep the focus on core UI and data interaction, there will be no navigation between pages. We are also not incorporating any external database or API, meaning all data management will occur within the application's current session. Crucially, all UI behavior and interactions must be implemented purely through data binding and commands, avoiding any traditional code-behind logic for the user interface elements. This approach emphasizes a clean separation of concerns and leverages the power of XAML.\n\nMoving on to the user interface specification, our main screen will comprise several essential components. At the very top, we'll have a clear application title, simply stating \"MY TASKS.\" Below that, there will be a text input field where users can type in their new task. Adjacent to this input, an Add button will facilitate adding the entered task to our list. The central part of the screen will feature a Task list, implemented using a CollectionView, to display all active tasks. Each task in the list will be accompanied by a checkbox, allowing users to easily mark it as completed. Finally, at the bottom of the screen, a summary section will provide a quick overview, showing both the total number of tasks and the count of completed tasks.\n\nTo achieve these functionalities while adhering to our constraints, your solution must effectively demonstrate a variety of binding types. We require OneWay binding for simply displaying information, such as the task title. TwoWay binding will be crucial for synchronizing data between the entry field and our ViewModel properties. OneWayToSource binding will be used for scenarios like capturing a selected task from the list. Commands are essential for triggering actions, such as the Add task button. RelativeSource binding will allow us to access the ViewModel directly from within an item template, and x:Reference will enable direct UI-to-UI binding where appropriate. For visual styling, a Converter will be needed to modify the text style of completed tasks. MultiBinding will allow us to combine multiple pieces of data into a single summary text display. Finally, to ensure our task list automatically updates as tasks are added or completed, we must utilize an ObservableCollection, and our ViewModel properties will need to implement INotifyPropertyChanged to propagate updates to the UI.",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/823d0a69-56a2-4dd1-b27b-c0d8da0f0522/slide_2.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\823d0a69-56a2-4dd1-b27b-c0d8da0f0522\\slide_2.wav"
      },
      {
        "slide_num": 3,
        "content": "6. Data Model \nCreate a TaskItem model that contains: \n• Title (string) \n• IsCompleted (bool) \nThe model must inherit from ObservableObject. \n \n7. ViewModel Requirements \nCreate TasksViewModel with the following: \nProperties \n• NewTaskTitle (string) \n• Tasks (ObservableCollection) \n• SelectedTask (TaskItem) \n• TotalCount (int) \n• CompletedCount (int) \nCommands \n• AddTaskCommand \nUse [ObservableProperty] and [RelayCommand] attributes where applicable. \n \n8. XAML Requirements \n• Bind Entry.Text using TwoWay binding \n• Bind Button.Command to ViewModel command \n• Use CollectionView for task list \n• Bind CheckBox.IsChecked using TwoWay binding \n• Use a Value Converter to apply strikethrough to completed tasks \n• Use MultiBinding for summary text \n• Use x:Reference at least once \n \n9. Suggested Lab Steps \n1. Create a new .NET MAUI project",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/823d0a69-56a2-4dd1-b27b-c0d8da0f0522/slide_3.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\823d0a69-56a2-4dd1-b27b-c0d8da0f0522\\slide_3.wav"
      },
      {
        "slide_num": 4,
        "content": "2. Install CommunityToolkit.Mvvm \n3. Create the model class \n4. Create the ViewModel \n5. Design the UI in XAML \n6. Apply required bindings \n7. Test UI behavior \n \n10. Assessment Rubric (10 Marks) \nCriteria Marks \nCorrect MVVM structure 2 \nProper use of binding modes 3 \nCommand implementation 2 \nConverter & MultiBinding 2 \nUI completeness & clarity 1 \n \n11. Submission Requirements \nStudents must submit: \n• Source code folder or Git repository \n• Screenshot of running application \n \n12. Notes \n• Code-behind should be minimal or empty \n• Focus on binding correctness, not UI aesthetics \n• Naming conventions and clean structure are required \n \nEnd of Lab",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-02-01 06:56:29",
    "avatar_path": null,
    "final_video_path": null
  },
  "57e5cfa0-10fb-49d2-8f49-e0526d1b6073": {
    "id": "57e5cfa0-10fb-49d2-8f49-e0526d1b6073",
    "filename": "Maui_Xaml_Binding_Lab_Handout.pdf",
    "file_path": "static/uploads/presentations\\57e5cfa0-10fb-49d2-8f49-e0526d1b6073\\Maui_Xaml_Binding_Lab_Handout.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "LAB HANDOUT \nMAUI XAML Binding Practice with CommunityToolkit.Mvvm \n \nCourse / Module \nMobile Application Development (.NET MAUI) \nLab Title \nTask Manager – XAML Data Binding & MVVM Toolkit \nDuration \n3 hours (180 minutes) \nLab Type \nIndividual – Hands-on Practice \n \n1. Lab Objectives \nAfter completing this lab, students will be able to: \n• Explain the purpose of data binding in .NET MAUI \n• Apply MVVM pattern using CommunityToolkit.Mvvm \n• Correctly use common binding modes in XAML \n• Bind UI elements to ViewModel properties and commands \n• Use converters and MultiBinding in real UI scenarios \n \n2. Software & Tools \n• Visual Studio 2022 or later \n• .NET MAUI workload installed \n• NuGet package: \no CommunityToolkit.Mvvm",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Hello everyone, and welcome to our next hands-on lab session. Today, we will be diving into XAML Binding Practice with the CommunityToolkit.Mvvm framework, a crucial skill for any mobile application developer. This lab is part of our Mobile Application Development using .NET MAUI course. The specific title for today's session is Task Manager – XAML Data Binding and MVVM Toolkit. You will have three hours, or one hundred and eighty minutes, for this individual, hands-on practice.\n\nBy the end of this lab, you will achieve several key learning objectives. First, you will be able to clearly explain the fundamental purpose of data binding within .NET MAUI applications. Second, you will gain practical experience applying the Model-View-ViewModel, or MVVM, pattern using the powerful CommunityToolkit.Mvvm library. We will ensure you can correctly utilize common data binding modes in XAML, understanding when and why to choose each one. You will also learn how to effectively bind your user interface elements to ViewModel properties and commands, creating responsive and maintainable applications. Finally, we will explore more advanced scenarios, demonstrating how to use converters and MultiBinding to tackle real-world UI challenges.\n\nTo get started, please ensure you have the necessary software and tools set up. You will need Visual Studio 2022 or a later version installed, along with the .NET MAUI workload. Additionally, we will be relying on a specific NuGet package: the CommunityToolkit.Mvvm. Make sure this is added to your project. Let us begin.",
        "edited_text": "Hello everyone, and welcome to our next hands-on lab session. Today, we will be diving into XAML Binding Practice with the CommunityToolkit.Mvvm framework, a crucial skill for any mobile application developer. This lab is part of our Mobile Application Development using .NET MAUI course. The specific title for today's session is Task Manager – XAML Data Binding and MVVM Toolkit. You will have three hours, or one hundred and eighty minutes, for this individual, hands-on practice.\n\nBy the end of this lab, you will achieve several key learning objectives. First, you will be able to clearly explain the fundamental purpose of data binding within .NET MAUI applications. Second, you will gain practical experience applying the Model-View-ViewModel, or MVVM, pattern using the powerful CommunityToolkit.Mvvm library. We will ensure you can correctly utilize common data binding modes in XAML, understanding when and why to choose each one. You will also learn how to effectively bind your user interface elements to ViewModel properties and commands, creating responsive and maintainable applications. Finally, we will explore more advanced scenarios, demonstrating how to use converters and MultiBinding to tackle real-world UI challenges.\n\nTo get started, please ensure you have the necessary software and tools set up. You will need Visual Studio 2022 or a later version installed, along with the .NET MAUI workload. Additionally, we will be relying on a specific NuGet package: the CommunityToolkit.Mvvm. Make sure this is added to your project. Let us begin.",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/57e5cfa0-10fb-49d2-8f49-e0526d1b6073/slide_1.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\57e5cfa0-10fb-49d2-8f49-e0526d1b6073\\slide_1.wav"
      },
      {
        "slide_num": 2,
        "content": "3. Problem Description \nYou are required to build a single-screen Task Manager application using .NET MAUI \n(XAML). \nThe application allows users to: - Enter a task name - Add the task to a list - Mark tasks as \ncompleted - View task statistics (total and completed) \n    Constraints - No navigation between pages - No database or API - No code-\nbehind logic for UI behavior - All interactions must be implemented using data \nbinding and commands \n \n4. User Interface Specification \nMain Screen Components \n1. Application title: MY TASKS \n2. Text input for new task \n3. Add button \n4. Task list (CollectionView) \n5. Checkbox for task completion \n6. Summary section displaying: \no Total tasks \no Completed tasks \n \n5. Required Binding Types \nYour solution must demonstrate the following bindings: \nNo Binding Type Required Usage \n1 OneWay Display task title \n2 TwoWay Entry ↔ ViewModel property \n3 OneWayToSource Selected task \n4 Command Add task action \n5 RelativeSource Access ViewModel from item template \n6 x:Reference UI-to-UI binding \n7 Converter Completed task text style \n8 MultiBinding Summary text \n9 ObservableCollection Auto-update task list \n10 INotifyPropertyChanged ViewModel updates",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Alright, let's dive into the core problem we're addressing today. Your task is to develop a single-screen Task Manager application using .NET MAUI and XAML. This application should be intuitive, allowing users to easily enter a new task, add it to a list, mark tasks as completed, and instantly view task statistics, specifically the total number of tasks and how many have been completed.\n\nNow, this isn't just about building a functional app; it comes with some specific and important constraints. We're keeping it to a single screen, so no navigation between pages. Furthermore, there's no backend database or external API involved. Crucially, we're focusing on a clean architecture: there should be no code-behind logic for UI behavior. All interactions, from button clicks to data updates, must be implemented purely through data binding and commands.\n\nMoving on to the user interface specification, let's visualize the main screen components. At the very top, we'll have a clear application title: 'MY TASKS'. Below that, users will find a text input field for entering new tasks, accompanied by an 'Add' button to submit them. The heart of our task display will be a CollectionView, efficiently listing all entered tasks. Each task within this list will feature a checkbox, enabling users to easily mark it as completed. Finally, a dedicated summary section will provide at-a-glance statistics, showing both the total number of tasks and the count of completed tasks.\n\nNow, a key aspect of this exercise is demonstrating proficiency with various binding types. Your solution is required to showcase the following: First, a OneWay binding will be used to simply display the task title. Then, a TwoWay binding is essential for the text input, ensuring seamless synchronization between the entry field and your ViewModel property. We'll also need a OneWayToSource binding, particularly for capturing a selected task. The 'Add task' action will naturally utilize a Command binding. To access your ViewModel from within an item template, you'll employ a RelativeSource binding. For direct UI-to-UI interactions, an x:Reference binding will be necessary. A Value Converter will be implemented to apply specific styling, perhaps for completed task text. To construct the dynamic summary text, a MultiBinding will be required, combining multiple data sources. For automatically updating the task list whenever tasks are added or removed, an ObservableCollection is indispensable. And finally, to ensure your ViewModel properties correctly notify the UI of any changes, the INotifyPropertyChanged interface must be implemented throughout your ViewModel.",
        "edited_text": "Alright, let's dive into the core problem we're addressing today. Your task is to develop a single-screen Task Manager application using .NET MAUI and XAML. This application should be intuitive, allowing users to easily enter a new task, add it to a list, mark tasks as completed, and instantly view task statistics, specifically the total number of tasks and how many have been completed.\n\nNow, this isn't just about building a functional app; it comes with some specific and important constraints. We're keeping it to a single screen, so no navigation between pages. Furthermore, there's no backend database or external API involved. Crucially, we're focusing on a clean architecture: there should be no code-behind logic for UI behavior. All interactions, from button clicks to data updates, must be implemented purely through data binding and commands.\n\nMoving on to the user interface specification, let's visualize the main screen components. At the very top, we'll have a clear application title: 'MY TASKS'. Below that, users will find a text input field for entering new tasks, accompanied by an 'Add' button to submit them. The heart of our task display will be a CollectionView, efficiently listing all entered tasks. Each task within this list will feature a checkbox, enabling users to easily mark it as completed. Finally, a dedicated summary section will provide at-a-glance statistics, showing both the total number of tasks and the count of completed tasks.\n\nNow, a key aspect of this exercise is demonstrating proficiency with various binding types. Your solution is required to showcase the following: First, a OneWay binding will be used to simply display the task title. Then, a TwoWay binding is essential for the text input, ensuring seamless synchronization between the entry field and your ViewModel property. We'll also need a OneWayToSource binding, particularly for capturing a selected task. The 'Add task' action will naturally utilize a Command binding. To access your ViewModel from within an item template, you'll employ a RelativeSource binding. For direct UI-to-UI interactions, an x:Reference binding will be necessary. A Value Converter will be implemented to apply specific styling, perhaps for completed task text. To construct the dynamic summary text, a MultiBinding will be required, combining multiple data sources. For automatically updating the task list whenever tasks are added or removed, an ObservableCollection is indispensable. And finally, to ensure your ViewModel properties correctly notify the UI of any changes, the INotifyPropertyChanged interface must be implemented throughout your ViewModel.",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/57e5cfa0-10fb-49d2-8f49-e0526d1b6073/slide_2.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\57e5cfa0-10fb-49d2-8f49-e0526d1b6073\\slide_2.wav"
      },
      {
        "slide_num": 3,
        "content": "6. Data Model \nCreate a TaskItem model that contains: \n• Title (string) \n• IsCompleted (bool) \nThe model must inherit from ObservableObject. \n \n7. ViewModel Requirements \nCreate TasksViewModel with the following: \nProperties \n• NewTaskTitle (string) \n• Tasks (ObservableCollection) \n• SelectedTask (TaskItem) \n• TotalCount (int) \n• CompletedCount (int) \nCommands \n• AddTaskCommand \nUse [ObservableProperty] and [RelayCommand] attributes where applicable. \n \n8. XAML Requirements \n• Bind Entry.Text using TwoWay binding \n• Bind Button.Command to ViewModel command \n• Use CollectionView for task list \n• Bind CheckBox.IsChecked using TwoWay binding \n• Use a Value Converter to apply strikethrough to completed tasks \n• Use MultiBinding for summary text \n• Use x:Reference at least once \n \n9. Suggested Lab Steps \n1. Create a new .NET MAUI project",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Alright, let's dive into the technical requirements for building our application.\n\nFirst, we'll establish our Data Model. You'll need to create a TaskItem model. This model will be quite straightforward, containing two key properties: a string for the task's Title, and a boolean property named IsCompleted to track its status. Crucially, this TaskItem model must inherit from ObservableObject. This inheritance is vital because it enables our UI to automatically react and update whenever a task's properties change, ensuring a smooth user experience.\n\nNext, we move on to the ViewModel Requirements. This is where our application's logic resides. We'll create a TasksViewModel that will manage our task list. It will have several important properties: NewTaskTitle, which is a string to capture new task input; an ObservableCollection named Tasks, which will hold all our TaskItem objects; SelectedTask, to manage the currently chosen task; and finally, TotalCount and CompletedCount, both integers, to provide a quick summary of our task list's state. For commands, we'll implement an AddTaskCommand. Remember to leverage the power of the ObservableProperty and RelayCommand attributes from the Community Toolkit where appropriate. These attributes significantly simplify property change notifications and command implementation, making our code cleaner and more efficient.\n\nNow, let's look at the XAML Requirements, focusing on how we'll build our user interface. We'll need to bind the Entry.Text property using TwoWay binding, allowing users to input and modify task titles seamlessly. Our buttons will bind their Command property directly to our ViewModel commands. For displaying our list of tasks, we'll utilize a CollectionView, which is excellent for handling data collections efficiently. The CheckBox.IsChecked property will also use TwoWay binding, so changes in the UI directly update our TaskItem's IsCompleted status and vice versa. To visually distinguish completed tasks, we'll implement a Value Converter. This converter will apply a strikethrough text decoration to any task where IsCompleted is true. For our summary text, perhaps showing 'X of Y tasks completed,' we'll use MultiBinding to combine different data points into a single display. And finally, to demonstrate a specific XAML feature, ensure you use x:Reference at least once within your layout.\n\nTo get started with this lab, your very first step will be to create a brand new .NET MAUI project. This will provide the foundation for everything we've just discussed.",
        "edited_text": "Alright, let's dive into the technical requirements for building our application.\n\nFirst, we'll establish our Data Model. You'll need to create a TaskItem model. This model will be quite straightforward, containing two key properties: a string for the task's Title, and a boolean property named IsCompleted to track its status. Crucially, this TaskItem model must inherit from ObservableObject. This inheritance is vital because it enables our UI to automatically react and update whenever a task's properties change, ensuring a smooth user experience.\n\nNext, we move on to the ViewModel Requirements. This is where our application's logic resides. We'll create a TasksViewModel that will manage our task list. It will have several important properties: NewTaskTitle, which is a string to capture new task input; an ObservableCollection named Tasks, which will hold all our TaskItem objects; SelectedTask, to manage the currently chosen task; and finally, TotalCount and CompletedCount, both integers, to provide a quick summary of our task list's state. For commands, we'll implement an AddTaskCommand. Remember to leverage the power of the ObservableProperty and RelayCommand attributes from the Community Toolkit where appropriate. These attributes significantly simplify property change notifications and command implementation, making our code cleaner and more efficient.\n\nNow, let's look at the XAML Requirements, focusing on how we'll build our user interface. We'll need to bind the Entry.Text property using TwoWay binding, allowing users to input and modify task titles seamlessly. Our buttons will bind their Command property directly to our ViewModel commands. For displaying our list of tasks, we'll utilize a CollectionView, which is excellent for handling data collections efficiently. The CheckBox.IsChecked property will also use TwoWay binding, so changes in the UI directly update our TaskItem's IsCompleted status and vice versa. To visually distinguish completed tasks, we'll implement a Value Converter. This converter will apply a strikethrough text decoration to any task where IsCompleted is true. For our summary text, perhaps showing 'X of Y tasks completed,' we'll use MultiBinding to combine different data points into a single display. And finally, to demonstrate a specific XAML feature, ensure you use x:Reference at least once within your layout.\n\nTo get started with this lab, your very first step will be to create a brand new .NET MAUI project. This will provide the foundation for everything we've just discussed.",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/57e5cfa0-10fb-49d2-8f49-e0526d1b6073/slide_3.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\57e5cfa0-10fb-49d2-8f49-e0526d1b6073\\slide_3.wav"
      },
      {
        "slide_num": 4,
        "content": "2. Install CommunityToolkit.Mvvm \n3. Create the model class \n4. Create the ViewModel \n5. Design the UI in XAML \n6. Apply required bindings \n7. Test UI behavior \n \n10. Assessment Rubric (10 Marks) \nCriteria Marks \nCorrect MVVM structure 2 \nProper use of binding modes 3 \nCommand implementation 2 \nConverter & MultiBinding 2 \nUI completeness & clarity 1 \n \n11. Submission Requirements \nStudents must submit: \n• Source code folder or Git repository \n• Screenshot of running application \n \n12. Notes \n• Code-behind should be minimal or empty \n• Focus on binding correctness, not UI aesthetics \n• Naming conventions and clean structure are required \n \nEnd of Lab",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Alright, let's walk through the practical steps for this lab. First, you'll need to install the Community Toolkit MVVM package. This is a crucial foundation for building our application following the Model-View-ViewModel pattern. Once that's in place, your next step is to create the model class, which will define the data structure for your application. Following that, you'll create the ViewModel, serving as the bridge between your data and the user interface. Then, you'll design the user interface itself using XAML, focusing on a clean and functional layout. A critical part of this lab is applying the required bindings correctly, ensuring seamless data flow between your ViewModel and the UI elements. Finally, remember to thoroughly test the UI behavior to confirm everything is working as expected.\n\nNow, regarding how your work will be assessed, we have a ten-mark rubric. Two marks are allocated for a correct MVVM structure, ensuring you've properly separated your concerns. Three marks will be given for the proper use of binding modes, demonstrating your understanding of how data flows and updates. Command implementation, which handles user interactions, is worth another two marks. We'll also be looking for your use of converters and multibinding techniques, which account for two marks. The final mark will be for the UI completeness and clarity, ensuring your interface is functional and easy to understand.\n\nFor submission, please ensure you provide either your complete source code folder or a link to your Git repository. Additionally, a screenshot of your running application is required to demonstrate its functionality.\n\nFinally, just a few important notes to keep in mind throughout this project. Your code-behind should be minimal or, ideally, empty, adhering strictly to MVVM principles. The primary focus for evaluation is on the correctness of your bindings, not on the aesthetic design of your UI. While a clean UI is good, binding functionality is key here. And always remember that naming conventions and a clean, well-structured codebase are absolutely required for professional development. That concludes our overview for this lab.",
        "edited_text": "Alright, let's walk through the practical steps for this lab. First, you'll need to install the Community Toolkit MVVM package. This is a crucial foundation for building our application following the Model-View-ViewModel pattern. Once that's in place, your next step is to create the model class, which will define the data structure for your application. Following that, you'll create the ViewModel, serving as the bridge between your data and the user interface. Then, you'll design the user interface itself using XAML, focusing on a clean and functional layout. A critical part of this lab is applying the required bindings correctly, ensuring seamless data flow between your ViewModel and the UI elements. Finally, remember to thoroughly test the UI behavior to confirm everything is working as expected.\n\nNow, regarding how your work will be assessed, we have a ten-mark rubric. Two marks are allocated for a correct MVVM structure, ensuring you've properly separated your concerns. Three marks will be given for the proper use of binding modes, demonstrating your understanding of how data flows and updates. Command implementation, which handles user interactions, is worth another two marks. We'll also be looking for your use of converters and multibinding techniques, which account for two marks. The final mark will be for the UI completeness and clarity, ensuring your interface is functional and easy to understand.\n\nFor submission, please ensure you provide either your complete source code folder or a link to your Git repository. Additionally, a screenshot of your running application is required to demonstrate its functionality.\n\nFinally, just a few important notes to keep in mind throughout this project. Your code-behind should be minimal or, ideally, empty, adhering strictly to MVVM principles. The primary focus for evaluation is on the correctness of your bindings, not on the aesthetic design of your UI. While a clean UI is good, binding functionality is key here. And always remember that naming conventions and a clean, well-structured codebase are absolutely required for professional development. That concludes our overview for this lab.",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/57e5cfa0-10fb-49d2-8f49-e0526d1b6073/slide_4.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\57e5cfa0-10fb-49d2-8f49-e0526d1b6073\\slide_4.wav"
      }
    ],
    "created_at": "2026-02-01 06:58:27",
    "avatar_path": null,
    "final_video_path": null
  },
  "14ed5848-0b81-4f82-9c34-e67bbc0b93b0": {
    "id": "14ed5848-0b81-4f82-9c34-e67bbc0b93b0",
    "filename": "Open_Agri_1.pdf",
    "file_path": "static/uploads/presentations\\14ed5848-0b81-4f82-9c34-e67bbc0b93b0\\Open_Agri_1.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "Open Agri",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Về dự án của\nchúng tôi\nOpenAgri – Nền tảng hỗ trợ ra quyết định cho người nông dân.\nHiện nay, rất nhiều bà con nông dân vẫn phải dựa vào kinh nghiệm và… may mắn để quyết định: trồng cây gì, khi\nnào gieo, khi nào phun thuốc, khi nào thu hoạch.\nTrong khi đó, thời tiết thay đổi thất thường, sâu bệnh xuất hiện khó lường, giá nông sản lên xuống mỗi ngày. Nếu\nquyết định sai, bà con có thể mất mùa, lỗ vốn, thậm chí nợ nần.\nOpenAgri ra đời với mong muốn trở thành một người trợ lý thông minh cho người nông dân và nhà quản lý, giúp\ngiảm rủi ro, tăng năng suất và tăng thu nhập.\nThay vì phải tự đoán, bà con chỉ cần mở ứng dụng trên điện thoại là có thể:\nXem được tình trạng sức khỏe ruộng của mình qua màu sắc hiển thị trên bản đồ: vùng nào cây đang khỏe,\nvùng nào có dấu hiệu bất thường cần kiểm tra.\nNhận cảnh báo sớm về nguy cơ sâu bệnh tại khu vực của mình, dựa trên dữ liệu lịch sử và điều kiện thời tiết.\nXem thời tiết nông vụ trong 7 ngày tới để quyết định thời điểm gieo trồng, tưới nước, phun thuốc, thu hoạch\ncho phù hợp.\nTheo dõi giá cả một số loại nông sản hằng ngày, giúp lựa chọn thời điểm bán ra hợp lý hơn.\nQuản lý các thửa ruộng, diện tích, loại cây trồng, lịch sử canh tác ngay trên bản đồ, dễ dàng tra cứu và tổng\nhợp.\nVề phía cơ quan quản lý và hợp tác xã, OpenAgri hỗ trợ:\nNắm được bức tranh tổng thể vùng trồng, diện tích, cơ cấu cây trồng.\nTheo dõi tình hình sâu bệnh, năng suất dự kiến, từ đó đưa ra khuyến cáo phù hợp và kịp thời cho bà con.\nCó thêm dữ liệu để lập kế hoạch sản xuất, tiêu thụ, kết nối với doanh nghiệp thu mua.",
        "notes": "",
        "total_slides": 7,
        "generated_text": "Kính thưa quý vị, trong bối cảnh nông nghiệp hiện đại, việc đưa ra những quyết định đúng đắn là chìa khóa để thành công. Tuy nhiên, thực tế đang đặt ra không ít thách thức cho bà con nông dân của chúng ta. Và đó chính là lý do dự án OpenAgri của chúng tôi ra đời, với nền tảng hỗ trợ ra quyết định thông minh dành riêng cho người nông dân.\n\nTrong nhiều năm qua, việc canh tác vẫn thường dựa vào kinh nghiệm truyền đời và đôi khi là cả sự may mắn. Quyết định trồng cây gì, gieo hạt khi nào, phun thuốc hay thu hoạch ra sao, tất cả đều tiềm ẩn rủi ro lớn. Thời tiết ngày càng biến đổi khó lường, sâu bệnh xuất hiện bất ngờ, cùng với sự biến động không ngừng của giá nông sản thị trường, một quyết định sai lầm có thể dẫn đến mất mùa, thua lỗ, thậm chí là gánh nặng nợ nần cho bà con.\n\nThấu hiểu những trăn trở đó, OpenAgri được phát triển như một nền tảng hỗ trợ ra quyết định thông minh, một người trợ lý đắc lực không chỉ cho người nông dân mà còn cho cả các nhà quản lý nông nghiệp. Mục tiêu của chúng tôi là giảm thiểu rủi ro, tối ưu hóa năng suất và nâng cao thu nhập một cách bền vững.\n\nVậy OpenAgri mang lại những gì cho bà con nông dân? Thay vì phải phỏng đoán, bà con chỉ cần một chiếc điện thoại thông minh để truy cập ứng dụng và có được những thông tin giá trị nhất:\nĐầu tiên, bà con có thể dễ dàng xem được tình trạng sức khỏe của từng thửa ruộng thông qua bản đồ hiển thị màu sắc trực quan, giúp phát hiện sớm những vùng cây đang phát triển kém hoặc có dấu hiệu bất thường cần kiểm tra.\nTiếp theo, hệ thống sẽ cung cấp cảnh báo sớm về nguy cơ sâu bệnh tại khu vực của mình, dựa trên dữ liệu lịch sử và điều kiện thời tiết, giúp bà con chủ động phòng ngừa và ứng phó kịp thời.\nOpenAgri còn cung cấp dự báo thời tiết nông vụ chi tiết trong bảy ngày tới, hỗ trợ bà con đưa ra quyết định chính xác về thời điểm gieo trồng, tưới nước, phun thuốc hay thu hoạch để đạt hiệu quả cao nhất.\nKhông chỉ vậy, việc theo dõi giá cả một số loại nông sản hàng ngày cũng trở nên đơn giản hơn, giúp bà con lựa chọn thời điểm bán ra hợp lý, tối đa hóa lợi nhuận.\nCuối cùng, bà con có thể quản lý toàn bộ thông tin về các thửa ruộng, diện tích, loại cây trồng và lịch sử canh tác ngay trên bản đồ số, dễ dàng tra cứu và tổng hợp mọi lúc mọi nơi.\n\nKhông chỉ dừng lại ở người nông dân, OpenAgri còn là công cụ hữu ích cho các cơ quan quản lý và hợp tác xã:\nNền tảng giúp họ có được bức tranh tổng thể về vùng trồng, diện tích và cơ cấu cây trồng, từ đó đưa ra các chiến lược phát triển phù hợp.\nViệc theo dõi tình hình sâu bệnh và dự kiến năng suất cây trồng cũng trở nên minh bạch hơn, giúp các nhà quản lý đưa ra khuyến cáo kịp thời và chính xác cho bà con nông dân.\nQuan trọng hơn, OpenAgri cung cấp nguồn dữ liệu đáng tin cậy để lập kế hoạch sản xuất, tiêu thụ và đặc biệt là kết nối hiệu quả với các doanh nghiệp thu mua, tạo chuỗi giá trị bền vững cho nông sản Việt.\n\nVới OpenAgri, chúng tôi tin rằng nông nghiệp Việt Nam sẽ ngày càng phát triển thông minh hơn, hiệu quả hơn và bền vững hơn, mang lại cuộc sống tốt đẹp hơn cho bà con nông dân. Xin cảm ơn quý vị đã lắng nghe.",
        "edited_text": "Kính thưa quý vị, trong bối cảnh nông nghiệp hiện đại, việc đưa ra những quyết định đúng đắn là chìa khóa để thành công. Tuy nhiên, thực tế đang đặt ra không ít thách thức cho bà con nông dân của chúng ta. Và đó chính là lý do dự án OpenAgri của chúng tôi ra đời, với nền tảng hỗ trợ ra quyết định thông minh dành riêng cho người nông dân.\n\nTrong nhiều năm qua, việc canh tác vẫn thường dựa vào kinh nghiệm truyền đời và đôi khi là cả sự may mắn. Quyết định trồng cây gì, gieo hạt khi nào, phun thuốc hay thu hoạch ra sao, tất cả đều tiềm ẩn rủi ro lớn. Thời tiết ngày càng biến đổi khó lường, sâu bệnh xuất hiện bất ngờ, cùng với sự biến động không ngừng của giá nông sản thị trường, một quyết định sai lầm có thể dẫn đến mất mùa, thua lỗ, thậm chí là gánh nặng nợ nần cho bà con.\n\nThấu hiểu những trăn trở đó, OpenAgri được phát triển như một nền tảng hỗ trợ ra quyết định thông minh, một người trợ lý đắc lực không chỉ cho người nông dân mà còn cho cả các nhà quản lý nông nghiệp. Mục tiêu của chúng tôi là giảm thiểu rủi ro, tối ưu hóa năng suất và nâng cao thu nhập một cách bền vững.\n\nVậy OpenAgri mang lại những gì cho bà con nông dân? Thay vì phải phỏng đoán, bà con chỉ cần một chiếc điện thoại thông minh để truy cập ứng dụng và có được những thông tin giá trị nhất:\nĐầu tiên, bà con có thể dễ dàng xem được tình trạng sức khỏe của từng thửa ruộng thông qua bản đồ hiển thị màu sắc trực quan, giúp phát hiện sớm những vùng cây đang phát triển kém hoặc có dấu hiệu bất thường cần kiểm tra.\nTiếp theo, hệ thống sẽ cung cấp cảnh báo sớm về nguy cơ sâu bệnh tại khu vực của mình, dựa trên dữ liệu lịch sử và điều kiện thời tiết, giúp bà con chủ động phòng ngừa và ứng phó kịp thời.\nOpenAgri còn cung cấp dự báo thời tiết nông vụ chi tiết trong bảy ngày tới, hỗ trợ bà con đưa ra quyết định chính xác về thời điểm gieo trồng, tưới nước, phun thuốc hay thu hoạch để đạt hiệu quả cao nhất.\nKhông chỉ vậy, việc theo dõi giá cả một số loại nông sản hàng ngày cũng trở nên đơn giản hơn, giúp bà con lựa chọn thời điểm bán ra hợp lý, tối đa hóa lợi nhuận.\nCuối cùng, bà con có thể quản lý toàn bộ thông tin về các thửa ruộng, diện tích, loại cây trồng và lịch sử canh tác ngay trên bản đồ số, dễ dàng tra cứu và tổng hợp mọi lúc mọi nơi.\n\nKhông chỉ dừng lại ở người nông dân, OpenAgri còn là công cụ hữu ích cho các cơ quan quản lý và hợp tác xã:\nNền tảng giúp họ có được bức tranh tổng thể về vùng trồng, diện tích và cơ cấu cây trồng, từ đó đưa ra các chiến lược phát triển phù hợp.\nViệc theo dõi tình hình sâu bệnh và dự kiến năng suất cây trồng cũng trở nên minh bạch hơn, giúp các nhà quản lý đưa ra khuyến cáo kịp thời và chính xác cho bà con nông dân.\nQuan trọng hơn, OpenAgri cung cấp nguồn dữ liệu đáng tin cậy để lập kế hoạch sản xuất, tiêu thụ và đặc biệt là kết nối hiệu quả với các doanh nghiệp thu mua, tạo chuỗi giá trị bền vững cho nông sản Việt.\n\nVới OpenAgri, chúng tôi tin rằng nông nghiệp Việt Nam sẽ ngày càng phát triển thông minh hơn, hiệu quả hơn và bền vững hơn, mang lại cuộc sống tốt đẹp hơn cho bà con nông dân. Xin cảm ơn quý vị đã lắng nghe.",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/14ed5848-0b81-4f82-9c34-e67bbc0b93b0/slide_2.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\14ed5848-0b81-4f82-9c34-e67bbc0b93b0\\slide_2.wav"
      },
      {
        "slide_num": 3,
        "content": "Dự báo thời tiết và\nđưa ra lời khuyên\ncho nông dân\nTrong sản xuất nông nghiệp, chỉ  cần lệch một trận mưa hay một đợt nắng nóng là bà con có thể\nmất trắng cả vụ. Nhưng thực tế, nhiều khi bà con không kịp xem dự báo thời tiết, hoặc bản tin\nchỉ nói chung chung cho cả tỉnh, không sát với ruộng của mình.\nVì vậy, trong ứng dụng OpenAg ri, chúng em xây dựng một mục thời tiết nông vụ riêng cho từng\nkhu ruộng.\nChỉ cần mở điện thoại, bà con sẽ thấy ngay:\nThời tiết hôm nay và 7 ngày tới tại đúng vị trí ruộng của mình: có mưa hay không, nhiệt độ,\nđộ ẩm, khả năng nắng nóng kéo dài…\nNhững cảnh báo ngắn gọn, dễ hiểu, ví dụ như:\n“2–3 ngày tới khả năng mưa lớn, nên hạn chế phun thuốc trừ sâu để tránh bị rửa trôi.”\n“Nắng nóng kéo dài, nên chú ý tưới bổ sung cho lúa/gia tăng che phủ cho rau màu.”\n“Trời âm u, ẩm độ cao, nguy c ơ một số bệnh lá phát triển mạ nh, nên kiểm tra đồng\nruộng thường xuyên hơn.”\nKhông chỉ dừng ở việc “báo thời tiết”, OpenAgri cố gắng dịch thông tin thời tiết thành lời\nkhuyên nông vụ cụ thể cho bà con: nên gieo khi nào, nên tránh phun thuốc vào lúc nào, đâu là\nthời điểm thuận lợi để thu hoạch để giảm rủi ro và tiết kiệm chi phí.\nNhờ đó, thay vì phải đoán “không biết mấy hôm nữa có mưa kh ông”, bà con có thêm một công\ncụ hỗ trợ ra quyết định, giúp chủ động hơn trong canh tác, bảo vệ sức khỏe cây trồng và nâng\ncao năng suất.",
        "notes": "",
        "total_slides": 7,
        "generated_text": "Kính thưa quý vị, trong lĩnh vực nông nghiệp, thời tiết luôn là yếu tố then chốt, đôi khi quyết định cả một mùa vụ. Chỉ một trận mưa lệch pha hay một đợt nắng nóng kéo dài không đúng lúc cũng có thể khiến bà con nông dân mất trắng công sức, đối mặt với những thiệt hại nặng nề. Thế nhưng, thực tế cho thấy, nhiều khi bà con không kịp cập nhật dự báo, hoặc bản tin thời tiết lại quá chung chung, không sát với điều kiện cụ thể của từng thửa ruộng.\n\nThấu hiểu những khó khăn đó, trong ứng dụng OpenAgri, chúng tôi đã phát triển một giải pháp đột phá: một mục thời tiết nông vụ được tùy chỉnh riêng cho từng khu ruộng của bà con. Giờ đây, chỉ với chiếc điện thoại thông minh, bà con có thể dễ dàng nắm bắt mọi thông tin quan trọng. Ngay lập tức, quý vị sẽ thấy dự báo thời tiết chi tiết cho hôm nay và cả bảy ngày tới, ngay tại chính vị trí thửa ruộng của mình. Chúng tôi cung cấp đầy đủ thông tin về khả năng mưa, nhiệt độ, độ ẩm, và cả nguy cơ nắng nóng kéo dài.\n\nĐặc biệt hơn, chúng tôi không chỉ dừng lại ở việc báo thời tiết. OpenAgri còn đưa ra những cảnh báo và lời khuyên nông vụ ngắn gọn, dễ hiểu và cực kỳ thiết thực. Ví dụ, bà con sẽ nhận được thông báo như: \"Hai đến ba ngày tới khả năng mưa lớn, nên hạn chế phun thuốc trừ sâu để tránh bị rửa trôi, gây lãng phí và ô nhiễm.\" Hay khi có \"nắng nóng kéo dài, nên chú ý tưới bổ sung cho lúa hoặc gia tăng che phủ cho rau màu để bảo vệ cây trồng.\" Và cả những lời nhắc nhở quan trọng như: \"Trời âm u, ẩm độ cao, nguy cơ một số bệnh lá phát triển mạnh, nên kiểm tra đồng ruộng thường xuyên hơn để phát hiện sớm và có biện pháp xử lý kịp thời.\"\n\nMục tiêu của chúng tôi là dịch thông tin thời tiết khô khan thành những lời khuyên nông vụ cụ thể, giúp bà con đưa ra quyết định chính xác: nên gieo trồng khi nào, thời điểm nào cần tránh phun thuốc, và đâu là lúc thuận lợi nhất để thu hoạch, từ đó giảm thiểu rủi ro và tiết kiệm chi phí đáng kể. Nhờ OpenAgri, thay vì phải băn khoăn hay đoán định \"không biết mấy hôm nữa có mưa hay không\", bà con nông dân giờ đây có thêm một công cụ hỗ trợ đắc lực. Điều này giúp quý vị chủ động hơn rất nhiều trong canh tác, bảo vệ sức khỏe cây trồng, và quan trọng nhất là góp phần nâng cao năng suất, mang lại hiệu quả kinh tế bền vững cho gia đình và cộng đồng.",
        "edited_text": "Kính thưa quý vị, trong lĩnh vực nông nghiệp, thời tiết luôn là yếu tố then chốt, đôi khi quyết định cả một mùa vụ. Chỉ một trận mưa lệch pha hay một đợt nắng nóng kéo dài không đúng lúc cũng có thể khiến bà con nông dân mất trắng công sức, đối mặt với những thiệt hại nặng nề. Thế nhưng, thực tế cho thấy, nhiều khi bà con không kịp cập nhật dự báo, hoặc bản tin thời tiết lại quá chung chung, không sát với điều kiện cụ thể của từng thửa ruộng.\n\nThấu hiểu những khó khăn đó, trong ứng dụng OpenAgri, chúng tôi đã phát triển một giải pháp đột phá: một mục thời tiết nông vụ được tùy chỉnh riêng cho từng khu ruộng của bà con. Giờ đây, chỉ với chiếc điện thoại thông minh, bà con có thể dễ dàng nắm bắt mọi thông tin quan trọng. Ngay lập tức, quý vị sẽ thấy dự báo thời tiết chi tiết cho hôm nay và cả bảy ngày tới, ngay tại chính vị trí thửa ruộng của mình. Chúng tôi cung cấp đầy đủ thông tin về khả năng mưa, nhiệt độ, độ ẩm, và cả nguy cơ nắng nóng kéo dài.\n\nĐặc biệt hơn, chúng tôi không chỉ dừng lại ở việc báo thời tiết. OpenAgri còn đưa ra những cảnh báo và lời khuyên nông vụ ngắn gọn, dễ hiểu và cực kỳ thiết thực. Ví dụ, bà con sẽ nhận được thông báo như: \"Hai đến ba ngày tới khả năng mưa lớn, nên hạn chế phun thuốc trừ sâu để tránh bị rửa trôi, gây lãng phí và ô nhiễm.\" Hay khi có \"nắng nóng kéo dài, nên chú ý tưới bổ sung cho lúa hoặc gia tăng che phủ cho rau màu để bảo vệ cây trồng.\" Và cả những lời nhắc nhở quan trọng như: \"Trời âm u, ẩm độ cao, nguy cơ một số bệnh lá phát triển mạnh, nên kiểm tra đồng ruộng thường xuyên hơn để phát hiện sớm và có biện pháp xử lý kịp thời.\"\n\nMục tiêu của chúng tôi là dịch thông tin thời tiết khô khan thành những lời khuyên nông vụ cụ thể, giúp bà con đưa ra quyết định chính xác: nên gieo trồng khi nào, thời điểm nào cần tránh phun thuốc, và đâu là lúc thuận lợi nhất để thu hoạch, từ đó giảm thiểu rủi ro và tiết kiệm chi phí đáng kể. Nhờ OpenAgri, thay vì phải băn khoăn hay đoán định \"không biết mấy hôm nữa có mưa hay không\", bà con nông dân giờ đây có thêm một công cụ hỗ trợ đắc lực. Điều này giúp quý vị chủ động hơn rất nhiều trong canh tác, bảo vệ sức khỏe cây trồng, và quan trọng nhất là góp phần nâng cao năng suất, mang lại hiệu quả kinh tế bền vững cho gia đình và cộng đồng.",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/14ed5848-0b81-4f82-9c34-e67bbc0b93b0/slide_3.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\14ed5848-0b81-4f82-9c34-e67bbc0b93b0\\slide_3.wav"
      },
      {
        "slide_num": 4,
        "content": "b ả n  đ ồ  \nv ù n g  t r ồ n g\nN ế u  n h ư  p h ầ n  t h ờ i  t i ế t  v à  l ờ i  k h u y ê n  n ô n g  v ụ  g i ú p  b à  c o n  q u y ế t  đ ị n h  “ k h i  n à o\nl à m ” ,  t h ì  p h ầ n  b ả n  đ ồ  s ẽ  g i ú p  t r ả  l ờ i  c â u  h ỏ i  “ l à m  ở  đ â u ,  t r ê n  d i ệ n  t í c h  n à o ,  t ì n h\nt r ạ n g  r a  s a o ” .\nT r o n g  ứ n g  d ụ n g ,  m ỗ i  t h ử a  r u ộ n g ,  m ỗ i  v ù n g  t r ồ n g  s ẽ  đ ư ợ c  v ẽ  v à  l ư u  l ạ i  t r ê n  b ả n  đ ồ .\nB à  c o n  c ó  t h ể :\nP h ó n g  t o  n g a y  k h u  v ự c  c ủ a  m ì n h ,  k h o a n h  v ù n g  t h ử a  r u ộ n g ,  đ ặ t  t ê n ,  g h i  d i ệ n\nt í c h ,  l o ạ i  c â y  t r ồ n g .\nN h ì n  t r ê n  b ả n  đ ồ  s ẽ  t h ấ y  t o à n  b ộ  h ệ  t h ố n g  r u ộ n g  c ủ a  g i a  đ ì n h :  r u ộ n g  n à o  đ a n g\ng i e o ,  r u ộ n g  n à o  c h u ẩ n  b ị  t h u  h o ạ c h ,  r u ộ n g  n à o  c ó  c ả n h  b á o  s â u  b ệ n h  h o ặ c  t h ờ i\nt i ế t  b ấ t  l ợ i .\nK h i  r a  đ ồ n g ,  c h ỉ  c ầ n  m ở  đ i ệ n  t h o ạ i  l à  x á c  đ ị n h  đ ú n g  v ị  t r í  l ô  t h ử a ,  t r á n h  n h ầ m\nl ẫ n ,  r ấ t  t i ệ n  k h i  l à m  v i ệ c  v ớ i  h ợ p  t á c  x ã  h o ặ c  c á n  b ộ  k ỹ  t h u ậ t .\nV ớ i  h ợ p  t á c  x ã  v à  đ ị a  p h ư ơ n g ,  b ả n  đ ồ  g i ú p :\nN h ì n  t h ấ y  b ứ c  t r a n h  c h u n g  c ủ a  c ả  v ù n g :  d i ệ n  t í c h ,  c ơ  c ấ u  c â y  t r ồ n g ,  k h u  v ự c\nđ a n g  g ặ p  r ủ i  r o .\nD ễ  d à n g  l ậ p  k ế  h o ạ c h  h ỗ  t r ợ ,  p h â n  b ổ  v ậ t  t ư ,  l ê n  l ị c h  p h u n  p h ò n g ,  t h u  h o ạ c h  t ậ p\nt r u n g .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "Tiếp theo, chúng ta hãy cùng tìm hiểu về một tính năng vô cùng quan trọng và thiết yếu: Bản đồ vùng trồng.\n\nNếu như phần dự báo thời tiết và các lời khuyên nông vụ giúp bà con nông dân trả lời câu hỏi \"khi nào\" nên thực hiện công việc, thì tính năng bản đồ này chính là chìa khóa để giải đáp \"làm ở đâu, trên diện tích cụ thể nào và tình trạng hiện tại của từng thửa ruộng ra sao\".\n\nVới ứng dụng của chúng ta, mỗi thửa ruộng, mỗi vùng canh tác của bà con sẽ được số hóa, vẽ và lưu trữ chi tiết ngay trên bản đồ. Điều này mang lại nhiều lợi ích thiết thực.\n\nĐối với bà con nông dân, quý vị có thể dễ dàng phóng to khu vực canh tác của mình, tự tay khoanh vùng từng thửa ruộng, đặt tên, ghi chú chính xác diện tích cũng như loại cây trồng cụ thể trên từng mảnh đất. Khi nhìn vào bản đồ, bà con sẽ có một cái nhìn tổng thể về toàn bộ hệ thống canh tác của gia đình mình: biết rõ thửa ruộng nào đang trong giai đoạn gieo trồng, thửa nào chuẩn bị thu hoạch, hay thậm chí là những thửa ruộng đang có cảnh báo về sâu bệnh hoặc sắp gặp phải điều kiện thời tiết bất lợi. Đặc biệt, khi ra đồng, chỉ cần mở điện thoại thông minh, bà con có thể xác định chính xác vị trí của từng lô thửa, tránh mọi sự nhầm lẫn không đáng có. Tính năng này vô cùng tiện lợi khi bà con làm việc với hợp tác xã hoặc các cán bộ kỹ thuật.\n\nKhông chỉ dừng lại ở cấp độ hộ gia đình, tính năng bản đồ vùng trồng còn mang lại giá trị to lớn cho các hợp tác xã và chính quyền địa phương. Bản đồ giúp họ có được một bức tranh tổng thể, toàn diện về tình hình canh tác của cả vùng, bao gồm tổng diện tích, cơ cấu cây trồng hiện tại, và đặc biệt là nhận diện được các khu vực đang có nguy cơ gặp rủi ro. Từ đó, việc lập kế hoạch hỗ trợ, phân bổ vật tư nông nghiệp, lên lịch phun phòng trừ sâu bệnh hay tổ chức thu hoạch tập trung sẽ trở nên dễ dàng và hiệu quả hơn rất nhiều.",
        "edited_text": "Tiếp theo, chúng ta hãy cùng tìm hiểu về một tính năng vô cùng quan trọng và thiết yếu: Bản đồ vùng trồng.\n\nNếu như phần dự báo thời tiết và các lời khuyên nông vụ giúp bà con nông dân trả lời câu hỏi \"khi nào\" nên thực hiện công việc, thì tính năng bản đồ này chính là chìa khóa để giải đáp \"làm ở đâu, trên diện tích cụ thể nào và tình trạng hiện tại của từng thửa ruộng ra sao\".\n\nVới ứng dụng của chúng ta, mỗi thửa ruộng, mỗi vùng canh tác của bà con sẽ được số hóa, vẽ và lưu trữ chi tiết ngay trên bản đồ. Điều này mang lại nhiều lợi ích thiết thực.\n\nĐối với bà con nông dân, quý vị có thể dễ dàng phóng to khu vực canh tác của mình, tự tay khoanh vùng từng thửa ruộng, đặt tên, ghi chú chính xác diện tích cũng như loại cây trồng cụ thể trên từng mảnh đất. Khi nhìn vào bản đồ, bà con sẽ có một cái nhìn tổng thể về toàn bộ hệ thống canh tác của gia đình mình: biết rõ thửa ruộng nào đang trong giai đoạn gieo trồng, thửa nào chuẩn bị thu hoạch, hay thậm chí là những thửa ruộng đang có cảnh báo về sâu bệnh hoặc sắp gặp phải điều kiện thời tiết bất lợi. Đặc biệt, khi ra đồng, chỉ cần mở điện thoại thông minh, bà con có thể xác định chính xác vị trí của từng lô thửa, tránh mọi sự nhầm lẫn không đáng có. Tính năng này vô cùng tiện lợi khi bà con làm việc với hợp tác xã hoặc các cán bộ kỹ thuật.\n\nKhông chỉ dừng lại ở cấp độ hộ gia đình, tính năng bản đồ vùng trồng còn mang lại giá trị to lớn cho các hợp tác xã và chính quyền địa phương. Bản đồ giúp họ có được một bức tranh tổng thể, toàn diện về tình hình canh tác của cả vùng, bao gồm tổng diện tích, cơ cấu cây trồng hiện tại, và đặc biệt là nhận diện được các khu vực đang có nguy cơ gặp rủi ro. Từ đó, việc lập kế hoạch hỗ trợ, phân bổ vật tư nông nghiệp, lên lịch phun phòng trừ sâu bệnh hay tổ chức thu hoạch tập trung sẽ trở nên dễ dàng và hiệu quả hơn rất nhiều.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "C h ẩ n  đ o á n  b ệ n h\nt r ê n  c â y  t r ồ n g\nT r o n g  t h ự c  t ế ,  k h ô n g  p h ả i  b à  c o n  n à o  c ũ n g  c ó  đ i ề u  k i ệ n  g ặ p  c á n  b ộ  k ỹ\nt h u ậ t  t h ư ờ n g  x u y ê n ,  n h i ề u  l o ạ i  b ệ n h  l á  n h ì n  k h á  g i ố n g  n h a u ,  n ế u  đ o á n\ns a i  v à  p h u n  n h ầ m  t h u ố c  t h ì  t ố n  t i ề n  m à  b ệ n h  v ẫ n  k h ô n g  k h ỏ i ,  t h ậ m  c h í\nc â y  c ò n  y ế u  h ơ n .\nV ớ i  O p e n A g r i ,  b à  c o n  c h ỉ  c ầ n  d ù n g  đ i ệ n  t h o ạ i  c h ụ p  l ạ i  h ì n h  c h i ế c  l á\nđ a n g  b ị  b ệ n h ,  s a u  đ ó  g ử i  l ê n  ứ n g  d ụ n g .  H ệ  t h ố n g  s ẽ  s o  s á n h  v ớ i  k h o\nh ì n h  ả n h  đ ã  đ ư ợ c  “ h ọ c ”  t r ư ớ c  đ ó ,  r ồ i  đ ư a  r a  g ợ i  ý :  l á  đ a n g  c ó  d ấ u  h i ệ u\ng i ố n g  v ớ i  m ộ t  s ố  l o ạ i  b ệ n h  n à o ,  t h ư ờ n g  g ặ p  t r ê n  l o ạ i  c â y  g ì ,  ở  g i a i  đ o ạ n\nn à o .\nT r ê n  m à n  h ì n h ,  b à  c o n  s ẽ  n h ậ n  đ ư ợ c  m ộ t  s ố  p h ư ơ n g  á n  b ệ n h  c ó  k h ả\nn ă n g  c a o ,  k è m  t h e o  m ô  t ả  t r i ệ u  c h ứ n g  d ễ  h i ể u  v à  g ợ i  ý  h ư ớ n g  x ử  l ý  c ơ\nb ả n  ( v í  d ụ :  n ê n  k i ể m  t r a  t h ê m  g ì ,  n ê n  h ỏ i  c á n  b ộ  k ỹ  t h u ậ t  v ề  l o ạ i  t h u ố c\nn à o ,  c ầ n  c h ú  ý  đ i ề u  k i ệ n  ẩ m  đ ộ ,  t h o á t  n ư ớ c … ) .\nM ụ c  t i ê u  c ủ a  t í n h  n ă n g  n à y  k h ô n g  p h ả i  l à  t h a y  t h ế  c h u y ê n  g i a ,  m à  l à\ng i ú p  b à  c o n  “ n g h i  n g ờ  đ ú n g  h ư ớ n g ”  s ớ m  h ơ n ,  t r á n h  đ ể  b ệ n h  l â y  l a n\nr ộ n g  m ớ i  p h á t  h i ệ n .  N h ờ  đ ó ,  b à  c o n  c ó  t h ể  t i ế t  k i ệ m  c h i  p h í  t h u ố c ,  g i ả m\ns ố  l ầ n  p h u n ,  b ả o  v ệ  s ứ c  k h ỏ e  c h o  m ì n h  v à  m ô i  t r ư ờ n g ,  đ ồ n g  t h ờ i  g i ữ\nđ ư ợ c  n ă n g  s u ấ t  v à  c h ấ t  l ư ợ n g  n ô n g  s ả n  t ố t  h ơ n .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "Kính thưa quý vị, hôm nay chúng ta sẽ cùng tìm hiểu về một tính năng vô cùng hữu ích: Chẩn đoán bệnh trên cây trồng.\n\nThực tế cho thấy, việc chẩn đoán bệnh cây trồng luôn là một thách thức lớn đối với bà con nông dân. Không phải ai cũng có điều kiện tiếp cận cán bộ kỹ thuật thường xuyên. Hơn nữa, nhiều loại bệnh lá có triệu chứng rất giống nhau, dễ gây nhầm lẫn. Nếu chẩn đoán sai và phun nhầm thuốc, không những tốn kém chi phí mà bệnh vẫn không khỏi, thậm chí còn khiến cây suy yếu hơn.\n\nVậy giải pháp của chúng ta là gì? Với ứng dụng OpenAgri, quy trình trở nên vô cùng đơn giản và hiệu quả. Bà con chỉ cần dùng điện thoại của mình chụp lại hình ảnh chiếc lá đang bị bệnh, sau đó gửi lên ứng dụng. Hệ thống thông minh của chúng tôi sẽ ngay lập tức so sánh hình ảnh đó với kho dữ liệu đã được huấn luyện từ trước. Từ đó, ứng dụng sẽ đưa ra gợi ý về các loại bệnh mà chiếc lá có dấu hiệu tương tự, thường gặp trên loại cây gì và ở giai đoạn phát triển nào.\n\nNgay lập tức, trên màn hình điện thoại, bà con sẽ nhận được một số phương án bệnh có khả năng cao nhất, kèm theo mô tả triệu chứng dễ hiểu và những gợi ý xử lý cơ bản. Ví dụ, ứng dụng có thể khuyên bà con nên kiểm tra thêm điều kiện ẩm độ, khả năng thoát nước của đất, hoặc gợi ý loại thuốc nên hỏi cán bộ kỹ thuật để có hướng điều trị chính xác hơn.\n\nĐiều quan trọng cần nhấn mạnh, mục tiêu của tính năng này không phải là thay thế hoàn toàn các chuyên gia. Thay vào đó, OpenAgri giúp bà con \"nghi ngờ đúng hướng\" sớm hơn, phát hiện bệnh từ giai đoạn đầu, tránh để bệnh lây lan rộng mới tìm cách xử lý. Nhờ khả năng chẩn đoán sớm và chính xác, bà con có thể tiết kiệm đáng kể chi phí thuốc bảo vệ thực vật, giảm số lần phun xịt, từ đó bảo vệ sức khỏe cho bản thân, gia đình và môi trường. Đồng thời, điều này cũng góp phần giữ vững năng suất và nâng cao chất lượng nông sản, mang lại hiệu quả kinh tế cao hơn.",
        "edited_text": "Kính thưa quý vị, hôm nay chúng ta sẽ cùng tìm hiểu về một tính năng vô cùng hữu ích: Chẩn đoán bệnh trên cây trồng.\n\nThực tế cho thấy, việc chẩn đoán bệnh cây trồng luôn là một thách thức lớn đối với bà con nông dân. Không phải ai cũng có điều kiện tiếp cận cán bộ kỹ thuật thường xuyên. Hơn nữa, nhiều loại bệnh lá có triệu chứng rất giống nhau, dễ gây nhầm lẫn. Nếu chẩn đoán sai và phun nhầm thuốc, không những tốn kém chi phí mà bệnh vẫn không khỏi, thậm chí còn khiến cây suy yếu hơn.\n\nVậy giải pháp của chúng ta là gì? Với ứng dụng OpenAgri, quy trình trở nên vô cùng đơn giản và hiệu quả. Bà con chỉ cần dùng điện thoại của mình chụp lại hình ảnh chiếc lá đang bị bệnh, sau đó gửi lên ứng dụng. Hệ thống thông minh của chúng tôi sẽ ngay lập tức so sánh hình ảnh đó với kho dữ liệu đã được huấn luyện từ trước. Từ đó, ứng dụng sẽ đưa ra gợi ý về các loại bệnh mà chiếc lá có dấu hiệu tương tự, thường gặp trên loại cây gì và ở giai đoạn phát triển nào.\n\nNgay lập tức, trên màn hình điện thoại, bà con sẽ nhận được một số phương án bệnh có khả năng cao nhất, kèm theo mô tả triệu chứng dễ hiểu và những gợi ý xử lý cơ bản. Ví dụ, ứng dụng có thể khuyên bà con nên kiểm tra thêm điều kiện ẩm độ, khả năng thoát nước của đất, hoặc gợi ý loại thuốc nên hỏi cán bộ kỹ thuật để có hướng điều trị chính xác hơn.\n\nĐiều quan trọng cần nhấn mạnh, mục tiêu của tính năng này không phải là thay thế hoàn toàn các chuyên gia. Thay vào đó, OpenAgri giúp bà con \"nghi ngờ đúng hướng\" sớm hơn, phát hiện bệnh từ giai đoạn đầu, tránh để bệnh lây lan rộng mới tìm cách xử lý. Nhờ khả năng chẩn đoán sớm và chính xác, bà con có thể tiết kiệm đáng kể chi phí thuốc bảo vệ thực vật, giảm số lần phun xịt, từ đó bảo vệ sức khỏe cho bản thân, gia đình và môi trường. Đồng thời, điều này cũng góp phần giữ vững năng suất và nâng cao chất lượng nông sản, mang lại hiệu quả kinh tế cao hơn.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "D ự  b á o  r ủ i  r o\nT r o n g  s ả n  x u ấ t ,  đ i ề u  b à  c o n  l o  n h ấ t  k h ô n g  c h ỉ  l à  “ h i ệ n  t ạ i  đ a n g  b ị  g ì ”  m à  l à  “ s ắ p  t ớ i  c ó\nn g u y  c ơ  g ì  k h ô n g ” :  c ó  đ ợ t  s â u  b ệ n h  n à o  d ễ  b ù n g  l ê n ,  c ó  g i a i  đ o ạ n  t h ờ i  t i ế t  n à o  b ấ t  l ợ i\nc h o  c â y  t r ồ n g ,  c ó  n g u y  c ơ  m ấ t  m ù a  ở  k h u  v ự c  n à o …  N ế u  b i ế t  t r ư ớ c ,  b à  c o n  c ó  t h ể  c h ủ\nđ ộ n g  p h ò n g  h ơ n  l à  c h ữ a .\nT ừ  c á c  n g u ồ n  d ữ  l i ệ u  l ị c h  s ử  v ề  s â u  b ệ n h ,  t h ờ i  t i ế t  v à  v ù n g  t r ồ n g ,  h ệ  t h ố n g  s ẽ  t ổ n g\nh ợ p  l ạ i  t h à n h  n h ữ n g  c ả n h  b á o  r ủ i  r o  r ấ t  d ễ  h i ể u ,  v í  d ụ :\n“ T r o n g  7 – 1 0  n g à y  t ớ i ,  k h u  v ự c  n à y  c ó  n g u y  c ơ  c a o  x u ấ t  h i ệ n  s â u / b ệ n h  X  t r ê n  c â y\nt r ồ n g  Y . ”\n“ Đ ộ  ẩ m  c a o ,  m ư a  k é o  d à i ,  n g u y  c ơ  b ệ n h  l á  t ă n g ,  n ê n  k i ể m  t r a  đ ồ n g  r u ộ n g  t h ư ờ n g\nx u y ê n  h ơ n . ”\n“ T h ờ i  g i a n  n à y ,  n ế u  g i e o  t r ồ n g  m u ộ n ,  n g u y  c ơ  g ặ p  h ạ n  c u ố i  v ụ  s ẽ  c a o  h ơ n . ”\nT h a y  v ì  b ắ t  b à  c o n  đ ọ c  n h ữ n g  b á o  c á o  d à i  v à  p h ứ c  t ạ p ,  I C T U - O p e n A g r i  h i ể n  t h ị  m ứ c\nđ ộ  r ủ i  r o  t h e o  m à u  s ắ c ,  t h e o  k h u  v ự c ,  k è m  t h e o  l ờ i  k h u y ê n  c ụ  t h ể :  n ê n  t ă n g  c ư ờ n g\nt h ă m  đ ồ n g ,  n ê n  c h u ẩ n  b ị  p h ư ơ n g  á n  p h ò n g  t r ừ ,  h a y  n ê n  đ i ề u  c h ỉ n h  l ị c h  g i e o  t r ồ n g .\nN h ờ  v ậ y ,  n g ư ờ i  n ô n g  d â n  v à  h ợ p  t á c  x ã  k h ô n g  c ò n  b ị  đ ộ n g  c h ạ y  t h e o  t h ờ i  t i ế t  v à  s â u\nb ệ n h ,  m à  c ó  t h ê m  m ộ t  c ô n g  c ụ  d ự  b á o  s ớ m ,  g i ú p  g i ả m  t h i ệ t  h ạ i ,  t ố i  ư u  c h i  p h í  v à  ổ n\nđ ị n h  n ă n g  s u ấ t  c h o  c ả  v ụ .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "Kính thưa quý vị, trong lĩnh vực sản xuất nông nghiệp, điều mà bà con nông dân trăn trở nhất không chỉ là những vấn đề hiện hữu mà họ đang đối mặt, mà còn là những rủi ro tiềm ẩn trong tương lai. Họ luôn tự hỏi: Liệu có đợt sâu bệnh nào sắp bùng phát? Thời tiết bất lợi có ảnh hưởng đến cây trồng không? Hay nguy cơ mất mùa ở khu vực nào đang cận kề? Bởi lẽ, nếu có thể biết trước, chúng ta hoàn toàn có thể chủ động phòng ngừa, thay vì phải vất vả chạy theo để khắc phục hậu quả.\n\nChính vì vậy, tính năng Dự báo rủi ro của chúng tôi ra đời nhằm giải quyết trực tiếp nỗi lo này. Bằng cách phân tích sâu rộng các nguồn dữ liệu lịch sử về sâu bệnh, diễn biến thời tiết và đặc điểm từng vùng trồng, hệ thống của chúng tôi sẽ tổng hợp lại thành những cảnh báo rủi ro vô cùng dễ hiểu và trực quan.\n\nVí dụ, bà con có thể nhận được thông báo như: \"Trong 7 đến 10 ngày tới, khu vực này có nguy cơ cao xuất hiện sâu hoặc bệnh X trên cây trồng Y.\" Hoặc một cảnh báo khác: \"Độ ẩm cao, mưa kéo dài, nguy cơ bệnh lá tăng, nên kiểm tra đồng ruộng thường xuyên hơn.\" Hay thậm chí là lời khuyên chiến lược: \"Thời gian này, nếu gieo trồng muộn, nguy cơ gặp hạn cuối vụ sẽ cao hơn đáng kể.\"\n\nThay vì phải đọc những báo cáo dài dòng và phức tạp, nền tảng ICTU - OpenAgri của chúng tôi sẽ hiển thị mức độ rủi ro một cách trực quan bằng màu sắc trên bản đồ theo từng khu vực cụ thể. Kèm theo đó là những lời khuyên hành động cụ thể và thiết thực: nên tăng cường thăm đồng, chuẩn bị phương án phòng trừ sớm, hay thậm chí là điều chỉnh lịch gieo trồng để tối ưu hóa hiệu quả.\n\nNhờ vậy, người nông dân và các hợp tác xã không còn bị động chạy theo thời tiết và sâu bệnh nữa. Họ có thêm một công cụ dự báo sớm mạnh mẽ, giúp giảm thiểu thiệt hại đáng kể, tối ưu hóa chi phí sản xuất và quan trọng hơn cả là ổn định năng suất cho cả vụ mùa. Đây chính là bước tiến quan trọng hướng tới một nền nông nghiệp thông minh và bền vững hơn.",
        "edited_text": "Kính thưa quý vị, trong lĩnh vực sản xuất nông nghiệp, điều mà bà con nông dân trăn trở nhất không chỉ là những vấn đề hiện hữu mà họ đang đối mặt, mà còn là những rủi ro tiềm ẩn trong tương lai. Họ luôn tự hỏi: Liệu có đợt sâu bệnh nào sắp bùng phát? Thời tiết bất lợi có ảnh hưởng đến cây trồng không? Hay nguy cơ mất mùa ở khu vực nào đang cận kề? Bởi lẽ, nếu có thể biết trước, chúng ta hoàn toàn có thể chủ động phòng ngừa, thay vì phải vất vả chạy theo để khắc phục hậu quả.\n\nChính vì vậy, tính năng Dự báo rủi ro của chúng tôi ra đời nhằm giải quyết trực tiếp nỗi lo này. Bằng cách phân tích sâu rộng các nguồn dữ liệu lịch sử về sâu bệnh, diễn biến thời tiết và đặc điểm từng vùng trồng, hệ thống của chúng tôi sẽ tổng hợp lại thành những cảnh báo rủi ro vô cùng dễ hiểu và trực quan.\n\nVí dụ, bà con có thể nhận được thông báo như: \"Trong 7 đến 10 ngày tới, khu vực này có nguy cơ cao xuất hiện sâu hoặc bệnh X trên cây trồng Y.\" Hoặc một cảnh báo khác: \"Độ ẩm cao, mưa kéo dài, nguy cơ bệnh lá tăng, nên kiểm tra đồng ruộng thường xuyên hơn.\" Hay thậm chí là lời khuyên chiến lược: \"Thời gian này, nếu gieo trồng muộn, nguy cơ gặp hạn cuối vụ sẽ cao hơn đáng kể.\"\n\nThay vì phải đọc những báo cáo dài dòng và phức tạp, nền tảng ICTU - OpenAgri của chúng tôi sẽ hiển thị mức độ rủi ro một cách trực quan bằng màu sắc trên bản đồ theo từng khu vực cụ thể. Kèm theo đó là những lời khuyên hành động cụ thể và thiết thực: nên tăng cường thăm đồng, chuẩn bị phương án phòng trừ sớm, hay thậm chí là điều chỉnh lịch gieo trồng để tối ưu hóa hiệu quả.\n\nNhờ vậy, người nông dân và các hợp tác xã không còn bị động chạy theo thời tiết và sâu bệnh nữa. Họ có thêm một công cụ dự báo sớm mạnh mẽ, giúp giảm thiểu thiệt hại đáng kể, tối ưu hóa chi phí sản xuất và quan trọng hơn cả là ổn định năng suất cho cả vụ mùa. Đây chính là bước tiến quan trọng hướng tới một nền nông nghiệp thông minh và bền vững hơn.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Cảm ơnvì lắngnghe",
        "notes": "",
        "total_slides": 7,
        "generated_text": "Kính thưa quý vị, tôi xin chân thành cảm ơn quý vị đã dành thời gian quý báu để lắng nghe và theo dõi phần trình bày của tôi ngày hôm nay. Sự quan tâm và chú ý của quý vị là nguồn động viên rất lớn đối với chúng tôi. Hy vọng những thông tin tôi chia sẻ đã mang lại giá trị thiết thực và hữu ích. Nếu quý vị có bất kỳ câu hỏi nào hoặc muốn thảo luận thêm về chủ đề này, xin đừng ngần ngại chia sẻ. Một lần nữa, xin cảm ơn quý vị rất nhiều.",
        "edited_text": "Kính thưa quý vị, tôi xin chân thành cảm ơn quý vị đã dành thời gian quý báu để lắng nghe và theo dõi phần trình bày của tôi ngày hôm nay. Sự quan tâm và chú ý của quý vị là nguồn động viên rất lớn đối với chúng tôi. Hy vọng những thông tin tôi chia sẻ đã mang lại giá trị thiết thực và hữu ích. Nếu quý vị có bất kỳ câu hỏi nào hoặc muốn thảo luận thêm về chủ đề này, xin đừng ngần ngại chia sẻ. Một lần nữa, xin cảm ơn quý vị rất nhiều.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-02-01 07:10:57",
    "avatar_path": null,
    "final_video_path": null
  },
  "c74f374d-afd2-49e9-868c-59b8da914208": {
    "id": "c74f374d-afd2-49e9-868c-59b8da914208",
    "filename": "Open_Agri.pdf",
    "file_path": "static/uploads/presentations\\c74f374d-afd2-49e9-868c-59b8da914208\\Open_Agri.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "Open Agri",
        "notes": "",
        "total_slides": 7,
        "generated_text": "Good morning, everyone. Today, we're going to delve into a concept that holds immense potential for the future of our food systems: Open Agri.\n\nWhat exactly do we mean by 'Open Agri'? At its core, it represents a paradigm shift in how we approach agriculture. It's about fostering transparency, collaboration, and accessibility across the entire agricultural value chain.\n\nThink of it this way: 'Open' refers to the sharing of knowledge, data, technologies, and best practices. It's about breaking down silos, enabling farmers, researchers, policymakers, and consumers to connect and innovate together. And 'Agri,' of course, encompasses everything from crop cultivation and livestock management to supply chain logistics and sustainable practices.\n\nWhen we combine these two powerful ideas, 'Open Agri' emerges as a movement towards a more efficient, resilient, and sustainable agricultural sector. It means leveraging open-source tools, open data platforms, and collaborative networks to drive innovation, improve productivity, and address global food security challenges. It's about democratizing access to the information and tools needed to thrive in modern farming.\n\nWe believe that by embracing the principles of Open Agri, we can unlock new opportunities for growth, enhance environmental stewardship, and build stronger, more connected agricultural communities. Let's explore how we can make this vision a reality.",
        "edited_text": "Good morning, everyone. Today, we're going to delve into a concept that holds immense potential for the future of our food systems: Open Agri.\n\nWhat exactly do we mean by 'Open Agri'? At its core, it represents a paradigm shift in how we approach agriculture. It's about fostering transparency, collaboration, and accessibility across the entire agricultural value chain.\n\nThink of it this way: 'Open' refers to the sharing of knowledge, data, technologies, and best practices. It's about breaking down silos, enabling farmers, researchers, policymakers, and consumers to connect and innovate together. And 'Agri,' of course, encompasses everything from crop cultivation and livestock management to supply chain logistics and sustainable practices.\n\nWhen we combine these two powerful ideas, 'Open Agri' emerges as a movement towards a more efficient, resilient, and sustainable agricultural sector. It means leveraging open-source tools, open data platforms, and collaborative networks to drive innovation, improve productivity, and address global food security challenges. It's about democratizing access to the information and tools needed to thrive in modern farming.\n\nWe believe that by embracing the principles of Open Agri, we can unlock new opportunities for growth, enhance environmental stewardship, and build stronger, more connected agricultural communities. Let's explore how we can make this vision a reality.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Về dự án của\nchúng tôi\nOpenAgri – Nền tảng hỗ trợ ra quyết định cho người nông dân.\nHiện nay, rất nhiều bà con nông dân vẫn phải dựa vào kinh nghiệm và… may mắn để quyết định: trồng cây gì, khi\nnào gieo, khi nào phun thuốc, khi nào thu hoạch.\nTrong khi đó, thời tiết thay đổi thất thường, sâu bệnh xuất hiện khó lường, giá nông sản lên xuống mỗi ngày. Nếu\nquyết định sai, bà con có thể mất mùa, lỗ vốn, thậm chí nợ nần.\nOpenAgri ra đời với mong muốn trở thành một người trợ lý thông minh cho người nông dân và nhà quản lý, giúp\ngiảm rủi ro, tăng năng suất và tăng thu nhập.\nThay vì phải tự đoán, bà con chỉ cần mở ứng dụng trên điện thoại là có thể:\nXem được tình trạng sức khỏe ruộng của mình qua màu sắc hiển thị trên bản đồ: vùng nào cây đang khỏe,\nvùng nào có dấu hiệu bất thường cần kiểm tra.\nNhận cảnh báo sớm về nguy cơ sâu bệnh tại khu vực của mình, dựa trên dữ liệu lịch sử và điều kiện thời tiết.\nXem thời tiết nông vụ trong 7 ngày tới để quyết định thời điểm gieo trồng, tưới nước, phun thuốc, thu hoạch\ncho phù hợp.\nTheo dõi giá cả một số loại nông sản hằng ngày, giúp lựa chọn thời điểm bán ra hợp lý hơn.\nQuản lý các thửa ruộng, diện tích, loại cây trồng, lịch sử canh tác ngay trên bản đồ, dễ dàng tra cứu và tổng\nhợp.\nVề phía cơ quan quản lý và hợp tác xã, OpenAgri hỗ trợ:\nNắm được bức tranh tổng thể vùng trồng, diện tích, cơ cấu cây trồng.\nTheo dõi tình hình sâu bệnh, năng suất dự kiến, từ đó đưa ra khuyến cáo phù hợp và kịp thời cho bà con.\nCó thêm dữ liệu để lập kế hoạch sản xuất, tiêu thụ, kết nối với doanh nghiệp thu mua.",
        "notes": "",
        "total_slides": 7,
        "generated_text": "Kính chào quý vị và các bạn,\n\nHôm nay, tôi rất vinh dự được giới thiệu về dự án của chúng tôi: OpenAgri – Nền tảng hỗ trợ ra quyết định thông minh dành cho người nông dân Việt Nam.\n\nQuý vị cũng biết, hiện nay, rất nhiều bà con nông dân của chúng ta vẫn thường phải dựa vào kinh nghiệm và đôi khi là cả may mắn để đưa ra những quyết định quan trọng như: nên trồng cây gì, khi nào gieo hạt, lúc nào cần phun thuốc hay thời điểm nào là tốt nhất để thu hoạch. Trong bối cảnh thời tiết ngày càng biến đổi thất thường, sâu bệnh xuất hiện khó lường và giá nông sản liên tục lên xuống mỗi ngày, một quyết định sai lầm có thể dẫn đến mất mùa, thua lỗ, thậm chí là nợ nần, gây ra gánh nặng lớn cho bà con.\n\nChính từ trăn trở đó, OpenAgri đã ra đời với mong muốn trở thành một người trợ lý thông minh, đáng tin cậy, giúp giảm thiểu rủi ro, tối ưu hóa năng suất và nâng cao thu nhập một cách bền vững cho người nông dân và cả các nhà quản lý nông nghiệp.\n\nVới OpenAgri, bà con nông dân giờ đây có thể dễ dàng truy cập thông tin và đưa ra quyết định sáng suốt chỉ với chiếc điện thoại thông minh của mình.\n\nĐầu tiên, không còn phải đi từng luống để kiểm tra, ứng dụng sẽ hiển thị trực quan tình trạng sức khỏe của ruộng qua màu sắc trên bản đồ. Bà con sẽ biết ngay vùng nào cây đang phát triển khỏe mạnh, vùng nào có dấu hiệu bất thường cần được kiểm tra kỹ lưỡng.\n\nThứ hai, hệ thống còn cung cấp cảnh báo sớm về nguy cơ sâu bệnh tại khu vực của mình, dựa trên dữ liệu lịch sử và điều kiện thời tiết thực tế, giúp bà con chủ động phòng ngừa, tránh thiệt hại lớn.\n\nThứ ba, dự báo thời tiết nông vụ chi tiết trong 7 ngày tới là một công cụ đắc lực để bà con quyết định chính xác thời điểm gieo trồng, tưới tiêu, phun thuốc hay thu hoạch cho phù hợp, tối ưu hóa mọi công đoạn sản xuất.\n\nThứ tư, việc theo dõi giá cả một số loại nông sản hằng ngày cũng trở nên dễ dàng hơn bao giờ hết, giúp bà con lựa chọn thời điểm bán ra hợp lý nhất, đảm bảo lợi nhuận cao.\n\nVà cuối cùng, bà con có thể quản lý tất cả các thửa ruộng của mình, từ diện tích, loại cây trồng cho đến lịch sử canh tác, ngay trên bản đồ số, dễ dàng tra cứu và tổng hợp thông tin bất cứ lúc nào.\n\nKhông chỉ dừng lại ở người nông dân, OpenAgri còn là một công cụ cực kỳ hữu ích cho các cơ quan quản lý và hợp tác xã. Họ có thể nắm bắt bức tranh tổng thể về vùng trồng, diện tích và cơ cấu cây trồng một cách nhanh chóng, chính xác. Đồng thời, theo dõi tình hình sâu bệnh, ước tính năng suất dự kiến, từ đó đưa ra những khuyến cáo phù hợp và kịp thời đến bà con, nâng cao hiệu quả sản xuất chung. Hơn nữa, dữ liệu từ OpenAgri cung cấp nền tảng vững chắc để lập kế hoạch sản xuất, tiêu thụ, và đặc biệt là kết nối hiệu quả với các doanh nghiệp thu mua, mở rộng thị trường đầu ra cho nông sản.\n\nTóm lại, OpenAgri không chỉ là một ứng dụng, mà là một người bạn đồng hành, một giải pháp toàn diện giúp ngành nông nghiệp Việt Nam phát triển bền vững, hiện đại và thịnh vượng hơn. Chúng tôi tin rằng, với OpenAgri, việc canh tác sẽ không còn là sự may rủi, mà là những quyết định thông minh, dựa trên dữ liệu và khoa học.\n\nXin chân thành cảm ơn quý vị đã lắng nghe.",
        "edited_text": "Kính chào quý vị và các bạn,\n\nHôm nay, tôi rất vinh dự được giới thiệu về dự án của chúng tôi: OpenAgri – Nền tảng hỗ trợ ra quyết định thông minh dành cho người nông dân Việt Nam.\n\nQuý vị cũng biết, hiện nay, rất nhiều bà con nông dân của chúng ta vẫn thường phải dựa vào kinh nghiệm và đôi khi là cả may mắn để đưa ra những quyết định quan trọng như: nên trồng cây gì, khi nào gieo hạt, lúc nào cần phun thuốc hay thời điểm nào là tốt nhất để thu hoạch. Trong bối cảnh thời tiết ngày càng biến đổi thất thường, sâu bệnh xuất hiện khó lường và giá nông sản liên tục lên xuống mỗi ngày, một quyết định sai lầm có thể dẫn đến mất mùa, thua lỗ, thậm chí là nợ nần, gây ra gánh nặng lớn cho bà con.\n\nChính từ trăn trở đó, OpenAgri đã ra đời với mong muốn trở thành một người trợ lý thông minh, đáng tin cậy, giúp giảm thiểu rủi ro, tối ưu hóa năng suất và nâng cao thu nhập một cách bền vững cho người nông dân và cả các nhà quản lý nông nghiệp.\n\nVới OpenAgri, bà con nông dân giờ đây có thể dễ dàng truy cập thông tin và đưa ra quyết định sáng suốt chỉ với chiếc điện thoại thông minh của mình.\n\nĐầu tiên, không còn phải đi từng luống để kiểm tra, ứng dụng sẽ hiển thị trực quan tình trạng sức khỏe của ruộng qua màu sắc trên bản đồ. Bà con sẽ biết ngay vùng nào cây đang phát triển khỏe mạnh, vùng nào có dấu hiệu bất thường cần được kiểm tra kỹ lưỡng.\n\nThứ hai, hệ thống còn cung cấp cảnh báo sớm về nguy cơ sâu bệnh tại khu vực của mình, dựa trên dữ liệu lịch sử và điều kiện thời tiết thực tế, giúp bà con chủ động phòng ngừa, tránh thiệt hại lớn.\n\nThứ ba, dự báo thời tiết nông vụ chi tiết trong 7 ngày tới là một công cụ đắc lực để bà con quyết định chính xác thời điểm gieo trồng, tưới tiêu, phun thuốc hay thu hoạch cho phù hợp, tối ưu hóa mọi công đoạn sản xuất.\n\nThứ tư, việc theo dõi giá cả một số loại nông sản hằng ngày cũng trở nên dễ dàng hơn bao giờ hết, giúp bà con lựa chọn thời điểm bán ra hợp lý nhất, đảm bảo lợi nhuận cao.\n\nVà cuối cùng, bà con có thể quản lý tất cả các thửa ruộng của mình, từ diện tích, loại cây trồng cho đến lịch sử canh tác, ngay trên bản đồ số, dễ dàng tra cứu và tổng hợp thông tin bất cứ lúc nào.\n\nKhông chỉ dừng lại ở người nông dân, OpenAgri còn là một công cụ cực kỳ hữu ích cho các cơ quan quản lý và hợp tác xã. Họ có thể nắm bắt bức tranh tổng thể về vùng trồng, diện tích và cơ cấu cây trồng một cách nhanh chóng, chính xác. Đồng thời, theo dõi tình hình sâu bệnh, ước tính năng suất dự kiến, từ đó đưa ra những khuyến cáo phù hợp và kịp thời đến bà con, nâng cao hiệu quả sản xuất chung. Hơn nữa, dữ liệu từ OpenAgri cung cấp nền tảng vững chắc để lập kế hoạch sản xuất, tiêu thụ, và đặc biệt là kết nối hiệu quả với các doanh nghiệp thu mua, mở rộng thị trường đầu ra cho nông sản.\n\nTóm lại, OpenAgri không chỉ là một ứng dụng, mà là một người bạn đồng hành, một giải pháp toàn diện giúp ngành nông nghiệp Việt Nam phát triển bền vững, hiện đại và thịnh vượng hơn. Chúng tôi tin rằng, với OpenAgri, việc canh tác sẽ không còn là sự may rủi, mà là những quyết định thông minh, dựa trên dữ liệu và khoa học.\n\nXin chân thành cảm ơn quý vị đã lắng nghe.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Dự báo thời tiết và\nđưa ra lời khuyên\ncho nông dân\nTrong sản xuất nông nghiệp, chỉ  cần lệch một trận mưa hay một đợt nắng nóng là bà con có thể\nmất trắng cả vụ. Nhưng thực tế, nhiều khi bà con không kịp xem dự báo thời tiết, hoặc bản tin\nchỉ nói chung chung cho cả tỉnh, không sát với ruộng của mình.\nVì vậy, trong ứng dụng OpenAg ri, chúng em xây dựng một mục thời tiết nông vụ riêng cho từng\nkhu ruộng.\nChỉ cần mở điện thoại, bà con sẽ thấy ngay:\nThời tiết hôm nay và 7 ngày tới tại đúng vị trí ruộng của mình: có mưa hay không, nhiệt độ,\nđộ ẩm, khả năng nắng nóng kéo dài…\nNhững cảnh báo ngắn gọn, dễ hiểu, ví dụ như:\n“2–3 ngày tới khả năng mưa lớn, nên hạn chế phun thuốc trừ sâu để tránh bị rửa trôi.”\n“Nắng nóng kéo dài, nên chú ý tưới bổ sung cho lúa/gia tăng che phủ cho rau màu.”\n“Trời âm u, ẩm độ cao, nguy c ơ một số bệnh lá phát triển mạ nh, nên kiểm tra đồng\nruộng thường xuyên hơn.”\nKhông chỉ dừng ở việc “báo thời tiết”, OpenAgri cố gắng dịch thông tin thời tiết thành lời\nkhuyên nông vụ cụ thể cho bà con: nên gieo khi nào, nên tránh phun thuốc vào lúc nào, đâu là\nthời điểm thuận lợi để thu hoạch để giảm rủi ro và tiết kiệm chi phí.\nNhờ đó, thay vì phải đoán “không biết mấy hôm nữa có mưa kh ông”, bà con có thêm một công\ncụ hỗ trợ ra quyết định, giúp chủ động hơn trong canh tác, bảo vệ sức khỏe cây trồng và nâng\ncao năng suất.",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "b ả n  đ ồ  \nv ù n g  t r ồ n g\nN ế u  n h ư  p h ầ n  t h ờ i  t i ế t  v à  l ờ i  k h u y ê n  n ô n g  v ụ  g i ú p  b à  c o n  q u y ế t  đ ị n h  “ k h i  n à o\nl à m ” ,  t h ì  p h ầ n  b ả n  đ ồ  s ẽ  g i ú p  t r ả  l ờ i  c â u  h ỏ i  “ l à m  ở  đ â u ,  t r ê n  d i ệ n  t í c h  n à o ,  t ì n h\nt r ạ n g  r a  s a o ” .\nT r o n g  ứ n g  d ụ n g ,  m ỗ i  t h ử a  r u ộ n g ,  m ỗ i  v ù n g  t r ồ n g  s ẽ  đ ư ợ c  v ẽ  v à  l ư u  l ạ i  t r ê n  b ả n  đ ồ .\nB à  c o n  c ó  t h ể :\nP h ó n g  t o  n g a y  k h u  v ự c  c ủ a  m ì n h ,  k h o a n h  v ù n g  t h ử a  r u ộ n g ,  đ ặ t  t ê n ,  g h i  d i ệ n\nt í c h ,  l o ạ i  c â y  t r ồ n g .\nN h ì n  t r ê n  b ả n  đ ồ  s ẽ  t h ấ y  t o à n  b ộ  h ệ  t h ố n g  r u ộ n g  c ủ a  g i a  đ ì n h :  r u ộ n g  n à o  đ a n g\ng i e o ,  r u ộ n g  n à o  c h u ẩ n  b ị  t h u  h o ạ c h ,  r u ộ n g  n à o  c ó  c ả n h  b á o  s â u  b ệ n h  h o ặ c  t h ờ i\nt i ế t  b ấ t  l ợ i .\nK h i  r a  đ ồ n g ,  c h ỉ  c ầ n  m ở  đ i ệ n  t h o ạ i  l à  x á c  đ ị n h  đ ú n g  v ị  t r í  l ô  t h ử a ,  t r á n h  n h ầ m\nl ẫ n ,  r ấ t  t i ệ n  k h i  l à m  v i ệ c  v ớ i  h ợ p  t á c  x ã  h o ặ c  c á n  b ộ  k ỹ  t h u ậ t .\nV ớ i  h ợ p  t á c  x ã  v à  đ ị a  p h ư ơ n g ,  b ả n  đ ồ  g i ú p :\nN h ì n  t h ấ y  b ứ c  t r a n h  c h u n g  c ủ a  c ả  v ù n g :  d i ệ n  t í c h ,  c ơ  c ấ u  c â y  t r ồ n g ,  k h u  v ự c\nđ a n g  g ặ p  r ủ i  r o .\nD ễ  d à n g  l ậ p  k ế  h o ạ c h  h ỗ  t r ợ ,  p h â n  b ổ  v ậ t  t ư ,  l ê n  l ị c h  p h u n  p h ò n g ,  t h u  h o ạ c h  t ậ p\nt r u n g .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "C h ẩ n  đ o á n  b ệ n h\nt r ê n  c â y  t r ồ n g\nT r o n g  t h ự c  t ế ,  k h ô n g  p h ả i  b à  c o n  n à o  c ũ n g  c ó  đ i ề u  k i ệ n  g ặ p  c á n  b ộ  k ỹ\nt h u ậ t  t h ư ờ n g  x u y ê n ,  n h i ề u  l o ạ i  b ệ n h  l á  n h ì n  k h á  g i ố n g  n h a u ,  n ế u  đ o á n\ns a i  v à  p h u n  n h ầ m  t h u ố c  t h ì  t ố n  t i ề n  m à  b ệ n h  v ẫ n  k h ô n g  k h ỏ i ,  t h ậ m  c h í\nc â y  c ò n  y ế u  h ơ n .\nV ớ i  O p e n A g r i ,  b à  c o n  c h ỉ  c ầ n  d ù n g  đ i ệ n  t h o ạ i  c h ụ p  l ạ i  h ì n h  c h i ế c  l á\nđ a n g  b ị  b ệ n h ,  s a u  đ ó  g ử i  l ê n  ứ n g  d ụ n g .  H ệ  t h ố n g  s ẽ  s o  s á n h  v ớ i  k h o\nh ì n h  ả n h  đ ã  đ ư ợ c  “ h ọ c ”  t r ư ớ c  đ ó ,  r ồ i  đ ư a  r a  g ợ i  ý :  l á  đ a n g  c ó  d ấ u  h i ệ u\ng i ố n g  v ớ i  m ộ t  s ố  l o ạ i  b ệ n h  n à o ,  t h ư ờ n g  g ặ p  t r ê n  l o ạ i  c â y  g ì ,  ở  g i a i  đ o ạ n\nn à o .\nT r ê n  m à n  h ì n h ,  b à  c o n  s ẽ  n h ậ n  đ ư ợ c  m ộ t  s ố  p h ư ơ n g  á n  b ệ n h  c ó  k h ả\nn ă n g  c a o ,  k è m  t h e o  m ô  t ả  t r i ệ u  c h ứ n g  d ễ  h i ể u  v à  g ợ i  ý  h ư ớ n g  x ử  l ý  c ơ\nb ả n  ( v í  d ụ :  n ê n  k i ể m  t r a  t h ê m  g ì ,  n ê n  h ỏ i  c á n  b ộ  k ỹ  t h u ậ t  v ề  l o ạ i  t h u ố c\nn à o ,  c ầ n  c h ú  ý  đ i ề u  k i ệ n  ẩ m  đ ộ ,  t h o á t  n ư ớ c … ) .\nM ụ c  t i ê u  c ủ a  t í n h  n ă n g  n à y  k h ô n g  p h ả i  l à  t h a y  t h ế  c h u y ê n  g i a ,  m à  l à\ng i ú p  b à  c o n  “ n g h i  n g ờ  đ ú n g  h ư ớ n g ”  s ớ m  h ơ n ,  t r á n h  đ ể  b ệ n h  l â y  l a n\nr ộ n g  m ớ i  p h á t  h i ệ n .  N h ờ  đ ó ,  b à  c o n  c ó  t h ể  t i ế t  k i ệ m  c h i  p h í  t h u ố c ,  g i ả m\ns ố  l ầ n  p h u n ,  b ả o  v ệ  s ứ c  k h ỏ e  c h o  m ì n h  v à  m ô i  t r ư ờ n g ,  đ ồ n g  t h ờ i  g i ữ\nđ ư ợ c  n ă n g  s u ấ t  v à  c h ấ t  l ư ợ n g  n ô n g  s ả n  t ố t  h ơ n .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "D ự  b á o  r ủ i  r o\nT r o n g  s ả n  x u ấ t ,  đ i ề u  b à  c o n  l o  n h ấ t  k h ô n g  c h ỉ  l à  “ h i ệ n  t ạ i  đ a n g  b ị  g ì ”  m à  l à  “ s ắ p  t ớ i  c ó\nn g u y  c ơ  g ì  k h ô n g ” :  c ó  đ ợ t  s â u  b ệ n h  n à o  d ễ  b ù n g  l ê n ,  c ó  g i a i  đ o ạ n  t h ờ i  t i ế t  n à o  b ấ t  l ợ i\nc h o  c â y  t r ồ n g ,  c ó  n g u y  c ơ  m ấ t  m ù a  ở  k h u  v ự c  n à o …  N ế u  b i ế t  t r ư ớ c ,  b à  c o n  c ó  t h ể  c h ủ\nđ ộ n g  p h ò n g  h ơ n  l à  c h ữ a .\nT ừ  c á c  n g u ồ n  d ữ  l i ệ u  l ị c h  s ử  v ề  s â u  b ệ n h ,  t h ờ i  t i ế t  v à  v ù n g  t r ồ n g ,  h ệ  t h ố n g  s ẽ  t ổ n g\nh ợ p  l ạ i  t h à n h  n h ữ n g  c ả n h  b á o  r ủ i  r o  r ấ t  d ễ  h i ể u ,  v í  d ụ :\n“ T r o n g  7 – 1 0  n g à y  t ớ i ,  k h u  v ự c  n à y  c ó  n g u y  c ơ  c a o  x u ấ t  h i ệ n  s â u / b ệ n h  X  t r ê n  c â y\nt r ồ n g  Y . ”\n“ Đ ộ  ẩ m  c a o ,  m ư a  k é o  d à i ,  n g u y  c ơ  b ệ n h  l á  t ă n g ,  n ê n  k i ể m  t r a  đ ồ n g  r u ộ n g  t h ư ờ n g\nx u y ê n  h ơ n . ”\n“ T h ờ i  g i a n  n à y ,  n ế u  g i e o  t r ồ n g  m u ộ n ,  n g u y  c ơ  g ặ p  h ạ n  c u ố i  v ụ  s ẽ  c a o  h ơ n . ”\nT h a y  v ì  b ắ t  b à  c o n  đ ọ c  n h ữ n g  b á o  c á o  d à i  v à  p h ứ c  t ạ p ,  I C T U - O p e n A g r i  h i ể n  t h ị  m ứ c\nđ ộ  r ủ i  r o  t h e o  m à u  s ắ c ,  t h e o  k h u  v ự c ,  k è m  t h e o  l ờ i  k h u y ê n  c ụ  t h ể :  n ê n  t ă n g  c ư ờ n g\nt h ă m  đ ồ n g ,  n ê n  c h u ẩ n  b ị  p h ư ơ n g  á n  p h ò n g  t r ừ ,  h a y  n ê n  đ i ề u  c h ỉ n h  l ị c h  g i e o  t r ồ n g .\nN h ờ  v ậ y ,  n g ư ờ i  n ô n g  d â n  v à  h ợ p  t á c  x ã  k h ô n g  c ò n  b ị  đ ộ n g  c h ạ y  t h e o  t h ờ i  t i ế t  v à  s â u\nb ệ n h ,  m à  c ó  t h ê m  m ộ t  c ô n g  c ụ  d ự  b á o  s ớ m ,  g i ú p  g i ả m  t h i ệ t  h ạ i ,  t ố i  ư u  c h i  p h í  v à  ổ n\nđ ị n h  n ă n g  s u ấ t  c h o  c ả  v ụ .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Cảm ơnvì lắngnghe",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-02-01 07:26:16",
    "avatar_path": null,
    "final_video_path": null
  },
  "dd4b6e41-2c51-43e9-896c-71277c8846fc": {
    "id": "dd4b6e41-2c51-43e9-896c-71277c8846fc",
    "filename": "Open_Agri.pdf",
    "file_path": "static/uploads/presentations\\dd4b6e41-2c51-43e9-896c-71277c8846fc\\Open_Agri.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "Open Agri",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/dd4b6e41-2c51-43e9-896c-71277c8846fc/slide_1.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\dd4b6e41-2c51-43e9-896c-71277c8846fc\\slide_1.wav"
      },
      {
        "slide_num": 2,
        "content": "Về dự án của\nchúng tôi\nOpenAgri – Nền tảng hỗ trợ ra quyết định cho người nông dân.\nHiện nay, rất nhiều bà con nông dân vẫn phải dựa vào kinh nghiệm và… may mắn để quyết định: trồng cây gì, khi\nnào gieo, khi nào phun thuốc, khi nào thu hoạch.\nTrong khi đó, thời tiết thay đổi thất thường, sâu bệnh xuất hiện khó lường, giá nông sản lên xuống mỗi ngày. Nếu\nquyết định sai, bà con có thể mất mùa, lỗ vốn, thậm chí nợ nần.\nOpenAgri ra đời với mong muốn trở thành một người trợ lý thông minh cho người nông dân và nhà quản lý, giúp\ngiảm rủi ro, tăng năng suất và tăng thu nhập.\nThay vì phải tự đoán, bà con chỉ cần mở ứng dụng trên điện thoại là có thể:\nXem được tình trạng sức khỏe ruộng của mình qua màu sắc hiển thị trên bản đồ: vùng nào cây đang khỏe,\nvùng nào có dấu hiệu bất thường cần kiểm tra.\nNhận cảnh báo sớm về nguy cơ sâu bệnh tại khu vực của mình, dựa trên dữ liệu lịch sử và điều kiện thời tiết.\nXem thời tiết nông vụ trong 7 ngày tới để quyết định thời điểm gieo trồng, tưới nước, phun thuốc, thu hoạch\ncho phù hợp.\nTheo dõi giá cả một số loại nông sản hằng ngày, giúp lựa chọn thời điểm bán ra hợp lý hơn.\nQuản lý các thửa ruộng, diện tích, loại cây trồng, lịch sử canh tác ngay trên bản đồ, dễ dàng tra cứu và tổng\nhợp.\nVề phía cơ quan quản lý và hợp tác xã, OpenAgri hỗ trợ:\nNắm được bức tranh tổng thể vùng trồng, diện tích, cơ cấu cây trồng.\nTheo dõi tình hình sâu bệnh, năng suất dự kiến, từ đó đưa ra khuyến cáo phù hợp và kịp thời cho bà con.\nCó thêm dữ liệu để lập kế hoạch sản xuất, tiêu thụ, kết nối với doanh nghiệp thu mua.",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/dd4b6e41-2c51-43e9-896c-71277c8846fc/slide_2.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\dd4b6e41-2c51-43e9-896c-71277c8846fc\\slide_2.wav"
      },
      {
        "slide_num": 3,
        "content": "Dự báo thời tiết và\nđưa ra lời khuyên\ncho nông dân\nTrong sản xuất nông nghiệp, chỉ  cần lệch một trận mưa hay một đợt nắng nóng là bà con có thể\nmất trắng cả vụ. Nhưng thực tế, nhiều khi bà con không kịp xem dự báo thời tiết, hoặc bản tin\nchỉ nói chung chung cho cả tỉnh, không sát với ruộng của mình.\nVì vậy, trong ứng dụng OpenAg ri, chúng em xây dựng một mục thời tiết nông vụ riêng cho từng\nkhu ruộng.\nChỉ cần mở điện thoại, bà con sẽ thấy ngay:\nThời tiết hôm nay và 7 ngày tới tại đúng vị trí ruộng của mình: có mưa hay không, nhiệt độ,\nđộ ẩm, khả năng nắng nóng kéo dài…\nNhững cảnh báo ngắn gọn, dễ hiểu, ví dụ như:\n“2–3 ngày tới khả năng mưa lớn, nên hạn chế phun thuốc trừ sâu để tránh bị rửa trôi.”\n“Nắng nóng kéo dài, nên chú ý tưới bổ sung cho lúa/gia tăng che phủ cho rau màu.”\n“Trời âm u, ẩm độ cao, nguy c ơ một số bệnh lá phát triển mạ nh, nên kiểm tra đồng\nruộng thường xuyên hơn.”\nKhông chỉ dừng ở việc “báo thời tiết”, OpenAgri cố gắng dịch thông tin thời tiết thành lời\nkhuyên nông vụ cụ thể cho bà con: nên gieo khi nào, nên tránh phun thuốc vào lúc nào, đâu là\nthời điểm thuận lợi để thu hoạch để giảm rủi ro và tiết kiệm chi phí.\nNhờ đó, thay vì phải đoán “không biết mấy hôm nữa có mưa kh ông”, bà con có thêm một công\ncụ hỗ trợ ra quyết định, giúp chủ động hơn trong canh tác, bảo vệ sức khỏe cây trồng và nâng\ncao năng suất.",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/dd4b6e41-2c51-43e9-896c-71277c8846fc/slide_3.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\dd4b6e41-2c51-43e9-896c-71277c8846fc\\slide_3.wav"
      },
      {
        "slide_num": 4,
        "content": "b ả n  đ ồ  \nv ù n g  t r ồ n g\nN ế u  n h ư  p h ầ n  t h ờ i  t i ế t  v à  l ờ i  k h u y ê n  n ô n g  v ụ  g i ú p  b à  c o n  q u y ế t  đ ị n h  “ k h i  n à o\nl à m ” ,  t h ì  p h ầ n  b ả n  đ ồ  s ẽ  g i ú p  t r ả  l ờ i  c â u  h ỏ i  “ l à m  ở  đ â u ,  t r ê n  d i ệ n  t í c h  n à o ,  t ì n h\nt r ạ n g  r a  s a o ” .\nT r o n g  ứ n g  d ụ n g ,  m ỗ i  t h ử a  r u ộ n g ,  m ỗ i  v ù n g  t r ồ n g  s ẽ  đ ư ợ c  v ẽ  v à  l ư u  l ạ i  t r ê n  b ả n  đ ồ .\nB à  c o n  c ó  t h ể :\nP h ó n g  t o  n g a y  k h u  v ự c  c ủ a  m ì n h ,  k h o a n h  v ù n g  t h ử a  r u ộ n g ,  đ ặ t  t ê n ,  g h i  d i ệ n\nt í c h ,  l o ạ i  c â y  t r ồ n g .\nN h ì n  t r ê n  b ả n  đ ồ  s ẽ  t h ấ y  t o à n  b ộ  h ệ  t h ố n g  r u ộ n g  c ủ a  g i a  đ ì n h :  r u ộ n g  n à o  đ a n g\ng i e o ,  r u ộ n g  n à o  c h u ẩ n  b ị  t h u  h o ạ c h ,  r u ộ n g  n à o  c ó  c ả n h  b á o  s â u  b ệ n h  h o ặ c  t h ờ i\nt i ế t  b ấ t  l ợ i .\nK h i  r a  đ ồ n g ,  c h ỉ  c ầ n  m ở  đ i ệ n  t h o ạ i  l à  x á c  đ ị n h  đ ú n g  v ị  t r í  l ô  t h ử a ,  t r á n h  n h ầ m\nl ẫ n ,  r ấ t  t i ệ n  k h i  l à m  v i ệ c  v ớ i  h ợ p  t á c  x ã  h o ặ c  c á n  b ộ  k ỹ  t h u ậ t .\nV ớ i  h ợ p  t á c  x ã  v à  đ ị a  p h ư ơ n g ,  b ả n  đ ồ  g i ú p :\nN h ì n  t h ấ y  b ứ c  t r a n h  c h u n g  c ủ a  c ả  v ù n g :  d i ệ n  t í c h ,  c ơ  c ấ u  c â y  t r ồ n g ,  k h u  v ự c\nđ a n g  g ặ p  r ủ i  r o .\nD ễ  d à n g  l ậ p  k ế  h o ạ c h  h ỗ  t r ợ ,  p h â n  b ổ  v ậ t  t ư ,  l ê n  l ị c h  p h u n  p h ò n g ,  t h u  h o ạ c h  t ậ p\nt r u n g .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/dd4b6e41-2c51-43e9-896c-71277c8846fc/slide_4.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\dd4b6e41-2c51-43e9-896c-71277c8846fc\\slide_4.wav"
      },
      {
        "slide_num": 5,
        "content": "C h ẩ n  đ o á n  b ệ n h\nt r ê n  c â y  t r ồ n g\nT r o n g  t h ự c  t ế ,  k h ô n g  p h ả i  b à  c o n  n à o  c ũ n g  c ó  đ i ề u  k i ệ n  g ặ p  c á n  b ộ  k ỹ\nt h u ậ t  t h ư ờ n g  x u y ê n ,  n h i ề u  l o ạ i  b ệ n h  l á  n h ì n  k h á  g i ố n g  n h a u ,  n ế u  đ o á n\ns a i  v à  p h u n  n h ầ m  t h u ố c  t h ì  t ố n  t i ề n  m à  b ệ n h  v ẫ n  k h ô n g  k h ỏ i ,  t h ậ m  c h í\nc â y  c ò n  y ế u  h ơ n .\nV ớ i  O p e n A g r i ,  b à  c o n  c h ỉ  c ầ n  d ù n g  đ i ệ n  t h o ạ i  c h ụ p  l ạ i  h ì n h  c h i ế c  l á\nđ a n g  b ị  b ệ n h ,  s a u  đ ó  g ử i  l ê n  ứ n g  d ụ n g .  H ệ  t h ố n g  s ẽ  s o  s á n h  v ớ i  k h o\nh ì n h  ả n h  đ ã  đ ư ợ c  “ h ọ c ”  t r ư ớ c  đ ó ,  r ồ i  đ ư a  r a  g ợ i  ý :  l á  đ a n g  c ó  d ấ u  h i ệ u\ng i ố n g  v ớ i  m ộ t  s ố  l o ạ i  b ệ n h  n à o ,  t h ư ờ n g  g ặ p  t r ê n  l o ạ i  c â y  g ì ,  ở  g i a i  đ o ạ n\nn à o .\nT r ê n  m à n  h ì n h ,  b à  c o n  s ẽ  n h ậ n  đ ư ợ c  m ộ t  s ố  p h ư ơ n g  á n  b ệ n h  c ó  k h ả\nn ă n g  c a o ,  k è m  t h e o  m ô  t ả  t r i ệ u  c h ứ n g  d ễ  h i ể u  v à  g ợ i  ý  h ư ớ n g  x ử  l ý  c ơ\nb ả n  ( v í  d ụ :  n ê n  k i ể m  t r a  t h ê m  g ì ,  n ê n  h ỏ i  c á n  b ộ  k ỹ  t h u ậ t  v ề  l o ạ i  t h u ố c\nn à o ,  c ầ n  c h ú  ý  đ i ề u  k i ệ n  ẩ m  đ ộ ,  t h o á t  n ư ớ c … ) .\nM ụ c  t i ê u  c ủ a  t í n h  n ă n g  n à y  k h ô n g  p h ả i  l à  t h a y  t h ế  c h u y ê n  g i a ,  m à  l à\ng i ú p  b à  c o n  “ n g h i  n g ờ  đ ú n g  h ư ớ n g ”  s ớ m  h ơ n ,  t r á n h  đ ể  b ệ n h  l â y  l a n\nr ộ n g  m ớ i  p h á t  h i ệ n .  N h ờ  đ ó ,  b à  c o n  c ó  t h ể  t i ế t  k i ệ m  c h i  p h í  t h u ố c ,  g i ả m\ns ố  l ầ n  p h u n ,  b ả o  v ệ  s ứ c  k h ỏ e  c h o  m ì n h  v à  m ô i  t r ư ờ n g ,  đ ồ n g  t h ờ i  g i ữ\nđ ư ợ c  n ă n g  s u ấ t  v à  c h ấ t  l ư ợ n g  n ô n g  s ả n  t ố t  h ơ n .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/dd4b6e41-2c51-43e9-896c-71277c8846fc/slide_5.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\dd4b6e41-2c51-43e9-896c-71277c8846fc\\slide_5.wav"
      },
      {
        "slide_num": 6,
        "content": "D ự  b á o  r ủ i  r o\nT r o n g  s ả n  x u ấ t ,  đ i ề u  b à  c o n  l o  n h ấ t  k h ô n g  c h ỉ  l à  “ h i ệ n  t ạ i  đ a n g  b ị  g ì ”  m à  l à  “ s ắ p  t ớ i  c ó\nn g u y  c ơ  g ì  k h ô n g ” :  c ó  đ ợ t  s â u  b ệ n h  n à o  d ễ  b ù n g  l ê n ,  c ó  g i a i  đ o ạ n  t h ờ i  t i ế t  n à o  b ấ t  l ợ i\nc h o  c â y  t r ồ n g ,  c ó  n g u y  c ơ  m ấ t  m ù a  ở  k h u  v ự c  n à o …  N ế u  b i ế t  t r ư ớ c ,  b à  c o n  c ó  t h ể  c h ủ\nđ ộ n g  p h ò n g  h ơ n  l à  c h ữ a .\nT ừ  c á c  n g u ồ n  d ữ  l i ệ u  l ị c h  s ử  v ề  s â u  b ệ n h ,  t h ờ i  t i ế t  v à  v ù n g  t r ồ n g ,  h ệ  t h ố n g  s ẽ  t ổ n g\nh ợ p  l ạ i  t h à n h  n h ữ n g  c ả n h  b á o  r ủ i  r o  r ấ t  d ễ  h i ể u ,  v í  d ụ :\n“ T r o n g  7 – 1 0  n g à y  t ớ i ,  k h u  v ự c  n à y  c ó  n g u y  c ơ  c a o  x u ấ t  h i ệ n  s â u / b ệ n h  X  t r ê n  c â y\nt r ồ n g  Y . ”\n“ Đ ộ  ẩ m  c a o ,  m ư a  k é o  d à i ,  n g u y  c ơ  b ệ n h  l á  t ă n g ,  n ê n  k i ể m  t r a  đ ồ n g  r u ộ n g  t h ư ờ n g\nx u y ê n  h ơ n . ”\n“ T h ờ i  g i a n  n à y ,  n ế u  g i e o  t r ồ n g  m u ộ n ,  n g u y  c ơ  g ặ p  h ạ n  c u ố i  v ụ  s ẽ  c a o  h ơ n . ”\nT h a y  v ì  b ắ t  b à  c o n  đ ọ c  n h ữ n g  b á o  c á o  d à i  v à  p h ứ c  t ạ p ,  I C T U - O p e n A g r i  h i ể n  t h ị  m ứ c\nđ ộ  r ủ i  r o  t h e o  m à u  s ắ c ,  t h e o  k h u  v ự c ,  k è m  t h e o  l ờ i  k h u y ê n  c ụ  t h ể :  n ê n  t ă n g  c ư ờ n g\nt h ă m  đ ồ n g ,  n ê n  c h u ẩ n  b ị  p h ư ơ n g  á n  p h ò n g  t r ừ ,  h a y  n ê n  đ i ề u  c h ỉ n h  l ị c h  g i e o  t r ồ n g .\nN h ờ  v ậ y ,  n g ư ờ i  n ô n g  d â n  v à  h ợ p  t á c  x ã  k h ô n g  c ò n  b ị  đ ộ n g  c h ạ y  t h e o  t h ờ i  t i ế t  v à  s â u\nb ệ n h ,  m à  c ó  t h ê m  m ộ t  c ô n g  c ụ  d ự  b á o  s ớ m ,  g i ú p  g i ả m  t h i ệ t  h ạ i ,  t ố i  ư u  c h i  p h í  v à  ổ n\nđ ị n h  n ă n g  s u ấ t  c h o  c ả  v ụ .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/dd4b6e41-2c51-43e9-896c-71277c8846fc/slide_6.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\dd4b6e41-2c51-43e9-896c-71277c8846fc\\slide_6.wav"
      },
      {
        "slide_num": 7,
        "content": "Cảm ơnvì lắngnghe",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-02-01 07:27:33",
    "avatar_path": null,
    "final_video_path": null
  },
  "a2ddcc89-85d0-4000-8d1c-b091659051d7": {
    "id": "a2ddcc89-85d0-4000-8d1c-b091659051d7",
    "filename": "Open_Agri.pdf",
    "file_path": "static/uploads/presentations\\a2ddcc89-85d0-4000-8d1c-b091659051d7\\Open_Agri.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "Open Agri",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/a2ddcc89-85d0-4000-8d1c-b091659051d7/slide_1.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\a2ddcc89-85d0-4000-8d1c-b091659051d7\\slide_1.wav"
      },
      {
        "slide_num": 2,
        "content": "Về dự án của\nchúng tôi\nOpenAgri – Nền tảng hỗ trợ ra quyết định cho người nông dân.\nHiện nay, rất nhiều bà con nông dân vẫn phải dựa vào kinh nghiệm và… may mắn để quyết định: trồng cây gì, khi\nnào gieo, khi nào phun thuốc, khi nào thu hoạch.\nTrong khi đó, thời tiết thay đổi thất thường, sâu bệnh xuất hiện khó lường, giá nông sản lên xuống mỗi ngày. Nếu\nquyết định sai, bà con có thể mất mùa, lỗ vốn, thậm chí nợ nần.\nOpenAgri ra đời với mong muốn trở thành một người trợ lý thông minh cho người nông dân và nhà quản lý, giúp\ngiảm rủi ro, tăng năng suất và tăng thu nhập.\nThay vì phải tự đoán, bà con chỉ cần mở ứng dụng trên điện thoại là có thể:\nXem được tình trạng sức khỏe ruộng của mình qua màu sắc hiển thị trên bản đồ: vùng nào cây đang khỏe,\nvùng nào có dấu hiệu bất thường cần kiểm tra.\nNhận cảnh báo sớm về nguy cơ sâu bệnh tại khu vực của mình, dựa trên dữ liệu lịch sử và điều kiện thời tiết.\nXem thời tiết nông vụ trong 7 ngày tới để quyết định thời điểm gieo trồng, tưới nước, phun thuốc, thu hoạch\ncho phù hợp.\nTheo dõi giá cả một số loại nông sản hằng ngày, giúp lựa chọn thời điểm bán ra hợp lý hơn.\nQuản lý các thửa ruộng, diện tích, loại cây trồng, lịch sử canh tác ngay trên bản đồ, dễ dàng tra cứu và tổng\nhợp.\nVề phía cơ quan quản lý và hợp tác xã, OpenAgri hỗ trợ:\nNắm được bức tranh tổng thể vùng trồng, diện tích, cơ cấu cây trồng.\nTheo dõi tình hình sâu bệnh, năng suất dự kiến, từ đó đưa ra khuyến cáo phù hợp và kịp thời cho bà con.\nCó thêm dữ liệu để lập kế hoạch sản xuất, tiêu thụ, kết nối với doanh nghiệp thu mua.",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/a2ddcc89-85d0-4000-8d1c-b091659051d7/slide_2.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\a2ddcc89-85d0-4000-8d1c-b091659051d7\\slide_2.wav"
      },
      {
        "slide_num": 3,
        "content": "Dự báo thời tiết và\nđưa ra lời khuyên\ncho nông dân\nTrong sản xuất nông nghiệp, chỉ  cần lệch một trận mưa hay một đợt nắng nóng là bà con có thể\nmất trắng cả vụ. Nhưng thực tế, nhiều khi bà con không kịp xem dự báo thời tiết, hoặc bản tin\nchỉ nói chung chung cho cả tỉnh, không sát với ruộng của mình.\nVì vậy, trong ứng dụng OpenAg ri, chúng em xây dựng một mục thời tiết nông vụ riêng cho từng\nkhu ruộng.\nChỉ cần mở điện thoại, bà con sẽ thấy ngay:\nThời tiết hôm nay và 7 ngày tới tại đúng vị trí ruộng của mình: có mưa hay không, nhiệt độ,\nđộ ẩm, khả năng nắng nóng kéo dài…\nNhững cảnh báo ngắn gọn, dễ hiểu, ví dụ như:\n“2–3 ngày tới khả năng mưa lớn, nên hạn chế phun thuốc trừ sâu để tránh bị rửa trôi.”\n“Nắng nóng kéo dài, nên chú ý tưới bổ sung cho lúa/gia tăng che phủ cho rau màu.”\n“Trời âm u, ẩm độ cao, nguy c ơ một số bệnh lá phát triển mạ nh, nên kiểm tra đồng\nruộng thường xuyên hơn.”\nKhông chỉ dừng ở việc “báo thời tiết”, OpenAgri cố gắng dịch thông tin thời tiết thành lời\nkhuyên nông vụ cụ thể cho bà con: nên gieo khi nào, nên tránh phun thuốc vào lúc nào, đâu là\nthời điểm thuận lợi để thu hoạch để giảm rủi ro và tiết kiệm chi phí.\nNhờ đó, thay vì phải đoán “không biết mấy hôm nữa có mưa kh ông”, bà con có thêm một công\ncụ hỗ trợ ra quyết định, giúp chủ động hơn trong canh tác, bảo vệ sức khỏe cây trồng và nâng\ncao năng suất.",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/a2ddcc89-85d0-4000-8d1c-b091659051d7/slide_3.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\a2ddcc89-85d0-4000-8d1c-b091659051d7\\slide_3.wav"
      },
      {
        "slide_num": 4,
        "content": "b ả n  đ ồ  \nv ù n g  t r ồ n g\nN ế u  n h ư  p h ầ n  t h ờ i  t i ế t  v à  l ờ i  k h u y ê n  n ô n g  v ụ  g i ú p  b à  c o n  q u y ế t  đ ị n h  “ k h i  n à o\nl à m ” ,  t h ì  p h ầ n  b ả n  đ ồ  s ẽ  g i ú p  t r ả  l ờ i  c â u  h ỏ i  “ l à m  ở  đ â u ,  t r ê n  d i ệ n  t í c h  n à o ,  t ì n h\nt r ạ n g  r a  s a o ” .\nT r o n g  ứ n g  d ụ n g ,  m ỗ i  t h ử a  r u ộ n g ,  m ỗ i  v ù n g  t r ồ n g  s ẽ  đ ư ợ c  v ẽ  v à  l ư u  l ạ i  t r ê n  b ả n  đ ồ .\nB à  c o n  c ó  t h ể :\nP h ó n g  t o  n g a y  k h u  v ự c  c ủ a  m ì n h ,  k h o a n h  v ù n g  t h ử a  r u ộ n g ,  đ ặ t  t ê n ,  g h i  d i ệ n\nt í c h ,  l o ạ i  c â y  t r ồ n g .\nN h ì n  t r ê n  b ả n  đ ồ  s ẽ  t h ấ y  t o à n  b ộ  h ệ  t h ố n g  r u ộ n g  c ủ a  g i a  đ ì n h :  r u ộ n g  n à o  đ a n g\ng i e o ,  r u ộ n g  n à o  c h u ẩ n  b ị  t h u  h o ạ c h ,  r u ộ n g  n à o  c ó  c ả n h  b á o  s â u  b ệ n h  h o ặ c  t h ờ i\nt i ế t  b ấ t  l ợ i .\nK h i  r a  đ ồ n g ,  c h ỉ  c ầ n  m ở  đ i ệ n  t h o ạ i  l à  x á c  đ ị n h  đ ú n g  v ị  t r í  l ô  t h ử a ,  t r á n h  n h ầ m\nl ẫ n ,  r ấ t  t i ệ n  k h i  l à m  v i ệ c  v ớ i  h ợ p  t á c  x ã  h o ặ c  c á n  b ộ  k ỹ  t h u ậ t .\nV ớ i  h ợ p  t á c  x ã  v à  đ ị a  p h ư ơ n g ,  b ả n  đ ồ  g i ú p :\nN h ì n  t h ấ y  b ứ c  t r a n h  c h u n g  c ủ a  c ả  v ù n g :  d i ệ n  t í c h ,  c ơ  c ấ u  c â y  t r ồ n g ,  k h u  v ự c\nđ a n g  g ặ p  r ủ i  r o .\nD ễ  d à n g  l ậ p  k ế  h o ạ c h  h ỗ  t r ợ ,  p h â n  b ổ  v ậ t  t ư ,  l ê n  l ị c h  p h u n  p h ò n g ,  t h u  h o ạ c h  t ậ p\nt r u n g .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/a2ddcc89-85d0-4000-8d1c-b091659051d7/slide_4.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\a2ddcc89-85d0-4000-8d1c-b091659051d7\\slide_4.wav"
      },
      {
        "slide_num": 5,
        "content": "C h ẩ n  đ o á n  b ệ n h\nt r ê n  c â y  t r ồ n g\nT r o n g  t h ự c  t ế ,  k h ô n g  p h ả i  b à  c o n  n à o  c ũ n g  c ó  đ i ề u  k i ệ n  g ặ p  c á n  b ộ  k ỹ\nt h u ậ t  t h ư ờ n g  x u y ê n ,  n h i ề u  l o ạ i  b ệ n h  l á  n h ì n  k h á  g i ố n g  n h a u ,  n ế u  đ o á n\ns a i  v à  p h u n  n h ầ m  t h u ố c  t h ì  t ố n  t i ề n  m à  b ệ n h  v ẫ n  k h ô n g  k h ỏ i ,  t h ậ m  c h í\nc â y  c ò n  y ế u  h ơ n .\nV ớ i  O p e n A g r i ,  b à  c o n  c h ỉ  c ầ n  d ù n g  đ i ệ n  t h o ạ i  c h ụ p  l ạ i  h ì n h  c h i ế c  l á\nđ a n g  b ị  b ệ n h ,  s a u  đ ó  g ử i  l ê n  ứ n g  d ụ n g .  H ệ  t h ố n g  s ẽ  s o  s á n h  v ớ i  k h o\nh ì n h  ả n h  đ ã  đ ư ợ c  “ h ọ c ”  t r ư ớ c  đ ó ,  r ồ i  đ ư a  r a  g ợ i  ý :  l á  đ a n g  c ó  d ấ u  h i ệ u\ng i ố n g  v ớ i  m ộ t  s ố  l o ạ i  b ệ n h  n à o ,  t h ư ờ n g  g ặ p  t r ê n  l o ạ i  c â y  g ì ,  ở  g i a i  đ o ạ n\nn à o .\nT r ê n  m à n  h ì n h ,  b à  c o n  s ẽ  n h ậ n  đ ư ợ c  m ộ t  s ố  p h ư ơ n g  á n  b ệ n h  c ó  k h ả\nn ă n g  c a o ,  k è m  t h e o  m ô  t ả  t r i ệ u  c h ứ n g  d ễ  h i ể u  v à  g ợ i  ý  h ư ớ n g  x ử  l ý  c ơ\nb ả n  ( v í  d ụ :  n ê n  k i ể m  t r a  t h ê m  g ì ,  n ê n  h ỏ i  c á n  b ộ  k ỹ  t h u ậ t  v ề  l o ạ i  t h u ố c\nn à o ,  c ầ n  c h ú  ý  đ i ề u  k i ệ n  ẩ m  đ ộ ,  t h o á t  n ư ớ c … ) .\nM ụ c  t i ê u  c ủ a  t í n h  n ă n g  n à y  k h ô n g  p h ả i  l à  t h a y  t h ế  c h u y ê n  g i a ,  m à  l à\ng i ú p  b à  c o n  “ n g h i  n g ờ  đ ú n g  h ư ớ n g ”  s ớ m  h ơ n ,  t r á n h  đ ể  b ệ n h  l â y  l a n\nr ộ n g  m ớ i  p h á t  h i ệ n .  N h ờ  đ ó ,  b à  c o n  c ó  t h ể  t i ế t  k i ệ m  c h i  p h í  t h u ố c ,  g i ả m\ns ố  l ầ n  p h u n ,  b ả o  v ệ  s ứ c  k h ỏ e  c h o  m ì n h  v à  m ô i  t r ư ờ n g ,  đ ồ n g  t h ờ i  g i ữ\nđ ư ợ c  n ă n g  s u ấ t  v à  c h ấ t  l ư ợ n g  n ô n g  s ả n  t ố t  h ơ n .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/a2ddcc89-85d0-4000-8d1c-b091659051d7/slide_5.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\a2ddcc89-85d0-4000-8d1c-b091659051d7\\slide_5.wav"
      },
      {
        "slide_num": 6,
        "content": "D ự  b á o  r ủ i  r o\nT r o n g  s ả n  x u ấ t ,  đ i ề u  b à  c o n  l o  n h ấ t  k h ô n g  c h ỉ  l à  “ h i ệ n  t ạ i  đ a n g  b ị  g ì ”  m à  l à  “ s ắ p  t ớ i  c ó\nn g u y  c ơ  g ì  k h ô n g ” :  c ó  đ ợ t  s â u  b ệ n h  n à o  d ễ  b ù n g  l ê n ,  c ó  g i a i  đ o ạ n  t h ờ i  t i ế t  n à o  b ấ t  l ợ i\nc h o  c â y  t r ồ n g ,  c ó  n g u y  c ơ  m ấ t  m ù a  ở  k h u  v ự c  n à o …  N ế u  b i ế t  t r ư ớ c ,  b à  c o n  c ó  t h ể  c h ủ\nđ ộ n g  p h ò n g  h ơ n  l à  c h ữ a .\nT ừ  c á c  n g u ồ n  d ữ  l i ệ u  l ị c h  s ử  v ề  s â u  b ệ n h ,  t h ờ i  t i ế t  v à  v ù n g  t r ồ n g ,  h ệ  t h ố n g  s ẽ  t ổ n g\nh ợ p  l ạ i  t h à n h  n h ữ n g  c ả n h  b á o  r ủ i  r o  r ấ t  d ễ  h i ể u ,  v í  d ụ :\n“ T r o n g  7 – 1 0  n g à y  t ớ i ,  k h u  v ự c  n à y  c ó  n g u y  c ơ  c a o  x u ấ t  h i ệ n  s â u / b ệ n h  X  t r ê n  c â y\nt r ồ n g  Y . ”\n“ Đ ộ  ẩ m  c a o ,  m ư a  k é o  d à i ,  n g u y  c ơ  b ệ n h  l á  t ă n g ,  n ê n  k i ể m  t r a  đ ồ n g  r u ộ n g  t h ư ờ n g\nx u y ê n  h ơ n . ”\n“ T h ờ i  g i a n  n à y ,  n ế u  g i e o  t r ồ n g  m u ộ n ,  n g u y  c ơ  g ặ p  h ạ n  c u ố i  v ụ  s ẽ  c a o  h ơ n . ”\nT h a y  v ì  b ắ t  b à  c o n  đ ọ c  n h ữ n g  b á o  c á o  d à i  v à  p h ứ c  t ạ p ,  I C T U - O p e n A g r i  h i ể n  t h ị  m ứ c\nđ ộ  r ủ i  r o  t h e o  m à u  s ắ c ,  t h e o  k h u  v ự c ,  k è m  t h e o  l ờ i  k h u y ê n  c ụ  t h ể :  n ê n  t ă n g  c ư ờ n g\nt h ă m  đ ồ n g ,  n ê n  c h u ẩ n  b ị  p h ư ơ n g  á n  p h ò n g  t r ừ ,  h a y  n ê n  đ i ề u  c h ỉ n h  l ị c h  g i e o  t r ồ n g .\nN h ờ  v ậ y ,  n g ư ờ i  n ô n g  d â n  v à  h ợ p  t á c  x ã  k h ô n g  c ò n  b ị  đ ộ n g  c h ạ y  t h e o  t h ờ i  t i ế t  v à  s â u\nb ệ n h ,  m à  c ó  t h ê m  m ộ t  c ô n g  c ụ  d ự  b á o  s ớ m ,  g i ú p  g i ả m  t h i ệ t  h ạ i ,  t ố i  ư u  c h i  p h í  v à  ổ n\nđ ị n h  n ă n g  s u ấ t  c h o  c ả  v ụ .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/a2ddcc89-85d0-4000-8d1c-b091659051d7/slide_6.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\a2ddcc89-85d0-4000-8d1c-b091659051d7\\slide_6.wav"
      },
      {
        "slide_num": 7,
        "content": "Cảm ơnvì lắngnghe",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-02-01 19:55:09",
    "avatar_path": null,
    "final_video_path": null
  },
  "8a2b91bf-a5a6-4ca5-9089-62e9e711d3ae": {
    "id": "8a2b91bf-a5a6-4ca5-9089-62e9e711d3ae",
    "filename": "Open_Agri.pdf",
    "file_path": "static/uploads/presentations\\8a2b91bf-a5a6-4ca5-9089-62e9e711d3ae\\Open_Agri.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "Open Agri",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Về dự án của\nchúng tôi\nOpenAgri – Nền tảng hỗ trợ ra quyết định cho người nông dân.\nHiện nay, rất nhiều bà con nông dân vẫn phải dựa vào kinh nghiệm và… may mắn để quyết định: trồng cây gì, khi\nnào gieo, khi nào phun thuốc, khi nào thu hoạch.\nTrong khi đó, thời tiết thay đổi thất thường, sâu bệnh xuất hiện khó lường, giá nông sản lên xuống mỗi ngày. Nếu\nquyết định sai, bà con có thể mất mùa, lỗ vốn, thậm chí nợ nần.\nOpenAgri ra đời với mong muốn trở thành một người trợ lý thông minh cho người nông dân và nhà quản lý, giúp\ngiảm rủi ro, tăng năng suất và tăng thu nhập.\nThay vì phải tự đoán, bà con chỉ cần mở ứng dụng trên điện thoại là có thể:\nXem được tình trạng sức khỏe ruộng của mình qua màu sắc hiển thị trên bản đồ: vùng nào cây đang khỏe,\nvùng nào có dấu hiệu bất thường cần kiểm tra.\nNhận cảnh báo sớm về nguy cơ sâu bệnh tại khu vực của mình, dựa trên dữ liệu lịch sử và điều kiện thời tiết.\nXem thời tiết nông vụ trong 7 ngày tới để quyết định thời điểm gieo trồng, tưới nước, phun thuốc, thu hoạch\ncho phù hợp.\nTheo dõi giá cả một số loại nông sản hằng ngày, giúp lựa chọn thời điểm bán ra hợp lý hơn.\nQuản lý các thửa ruộng, diện tích, loại cây trồng, lịch sử canh tác ngay trên bản đồ, dễ dàng tra cứu và tổng\nhợp.\nVề phía cơ quan quản lý và hợp tác xã, OpenAgri hỗ trợ:\nNắm được bức tranh tổng thể vùng trồng, diện tích, cơ cấu cây trồng.\nTheo dõi tình hình sâu bệnh, năng suất dự kiến, từ đó đưa ra khuyến cáo phù hợp và kịp thời cho bà con.\nCó thêm dữ liệu để lập kế hoạch sản xuất, tiêu thụ, kết nối với doanh nghiệp thu mua.",
        "notes": "",
        "total_slides": 7,
        "generated_text": "Chào mừng quý vị đến với phần giới thiệu về dự án của chúng tôi, OpenAgri – nền tảng hỗ trợ ra quyết định thông minh dành cho người nông dân.\n\nHiện nay, hàng triệu bà con nông dân trên khắp cả nước vẫn đang phải đưa ra những quyết định canh tác quan trọng như trồng cây gì, khi nào gieo hạt, phun thuốc hay thu hoạch, dựa chủ yếu vào kinh nghiệm cá nhân và đôi khi là cả may mắn. Trong bối cảnh biến đổi khí hậu diễn biến phức tạp, sâu bệnh xuất hiện bất ngờ, và giá nông sản biến động từng ngày, một quyết định sai lầm có thể dẫn đến mất mùa, thua lỗ, thậm chí là nợ nần.\n\nThấu hiểu những trăn trở đó, OpenAgri ra đời với sứ mệnh trở thành một người trợ lý thông minh, đáng tin cậy cho người nông dân và cả các nhà quản lý nông nghiệp. Mục tiêu của chúng tôi là giúp giảm thiểu rủi ro, tối ưu hóa năng suất và nâng cao thu nhập bền vững cho bà con.\n\nVậy OpenAgri mang lại điều gì cho bà con nông dân? Thay vì phải tự phán đoán hay lo lắng, giờ đây, chỉ với một ứng dụng trên điện thoại, bà con có thể:\n\nDễ dàng theo dõi tình trạng sức khỏe của từng thửa ruộng qua bản đồ màu sắc trực quan, nhanh chóng nhận biết đâu là vùng cây đang phát triển tốt, và đâu là nơi có dấu hiệu bất thường cần kiểm tra kỹ lưỡng hơn.\n\nNhận được cảnh báo sớm về nguy cơ sâu bệnh tại khu vực của mình, được dự báo dựa trên dữ liệu lịch sử và điều kiện thời tiết thực tế, giúp bà con chủ động phòng ngừa hiệu quả.\n\nXem dự báo thời tiết nông vụ chi tiết cho bảy ngày tới, từ đó đưa ra quyết định chính xác về thời điểm gieo trồng, tưới nước, phun thuốc hay thu hoạch cho phù hợp.\n\nCập nhật giá cả của một số loại nông sản mỗi ngày, hỗ trợ bà con lựa chọn thời điểm bán ra hợp lý nhất để tối đa hóa lợi nhuận.\n\nVà quản lý toàn bộ thông tin về các thửa ruộng, diện tích, loại cây trồng và lịch sử canh tác ngay trên bản đồ số, giúp việc tra cứu và tổng hợp trở nên vô cùng tiện lợi.\n\nKhông chỉ dừng lại ở đó, OpenAgri còn là công cụ đắc lực cho các cơ quan quản lý và hợp tác xã. Nền tảng này giúp họ:\n\nNắm bắt bức tranh tổng thể về vùng trồng, diện tích và cơ cấu cây trồng một cách rõ ràng và kịp thời.\n\nTheo dõi sát sao tình hình sâu bệnh, dự kiến năng suất, từ đó đưa ra những khuyến cáo phù hợp và kịp thời đến từng hộ nông dân.\n\nVà cung cấp dữ liệu quan trọng để lập kế hoạch sản xuất, tiêu thụ, cũng như kết nối hiệu quả với các doanh nghiệp thu mua, góp phần xây dựng chuỗi giá trị nông sản bền vững.\n\nOpenAgri không chỉ là một nền tảng công nghệ, mà là một cam kết đồng hành cùng ngành nông nghiệp Việt Nam hướng tới một tương lai phát triển thông minh và thịnh vượng hơn. Cảm ơn quý vị đã lắng nghe.",
        "edited_text": "Chào mừng quý vị đến với phần giới thiệu về dự án của chúng tôi, OpenAgri – nền tảng hỗ trợ ra quyết định thông minh dành cho người nông dân.\n\nHiện nay, hàng triệu bà con nông dân trên khắp cả nước vẫn đang phải đưa ra những quyết định canh tác quan trọng như trồng cây gì, khi nào gieo hạt, phun thuốc hay thu hoạch, dựa chủ yếu vào kinh nghiệm cá nhân và đôi khi là cả may mắn. Trong bối cảnh biến đổi khí hậu diễn biến phức tạp, sâu bệnh xuất hiện bất ngờ, và giá nông sản biến động từng ngày, một quyết định sai lầm có thể dẫn đến mất mùa, thua lỗ, thậm chí là nợ nần.\n\nThấu hiểu những trăn trở đó, OpenAgri ra đời với sứ mệnh trở thành một người trợ lý thông minh, đáng tin cậy cho người nông dân và cả các nhà quản lý nông nghiệp. Mục tiêu của chúng tôi là giúp giảm thiểu rủi ro, tối ưu hóa năng suất và nâng cao thu nhập bền vững cho bà con.\n\nVậy OpenAgri mang lại điều gì cho bà con nông dân? Thay vì phải tự phán đoán hay lo lắng, giờ đây, chỉ với một ứng dụng trên điện thoại, bà con có thể:\n\nDễ dàng theo dõi tình trạng sức khỏe của từng thửa ruộng qua bản đồ màu sắc trực quan, nhanh chóng nhận biết đâu là vùng cây đang phát triển tốt, và đâu là nơi có dấu hiệu bất thường cần kiểm tra kỹ lưỡng hơn.\n\nNhận được cảnh báo sớm về nguy cơ sâu bệnh tại khu vực của mình, được dự báo dựa trên dữ liệu lịch sử và điều kiện thời tiết thực tế, giúp bà con chủ động phòng ngừa hiệu quả.\n\nXem dự báo thời tiết nông vụ chi tiết cho bảy ngày tới, từ đó đưa ra quyết định chính xác về thời điểm gieo trồng, tưới nước, phun thuốc hay thu hoạch cho phù hợp.\n\nCập nhật giá cả của một số loại nông sản mỗi ngày, hỗ trợ bà con lựa chọn thời điểm bán ra hợp lý nhất để tối đa hóa lợi nhuận.\n\nVà quản lý toàn bộ thông tin về các thửa ruộng, diện tích, loại cây trồng và lịch sử canh tác ngay trên bản đồ số, giúp việc tra cứu và tổng hợp trở nên vô cùng tiện lợi.\n\nKhông chỉ dừng lại ở đó, OpenAgri còn là công cụ đắc lực cho các cơ quan quản lý và hợp tác xã. Nền tảng này giúp họ:\n\nNắm bắt bức tranh tổng thể về vùng trồng, diện tích và cơ cấu cây trồng một cách rõ ràng và kịp thời.\n\nTheo dõi sát sao tình hình sâu bệnh, dự kiến năng suất, từ đó đưa ra những khuyến cáo phù hợp và kịp thời đến từng hộ nông dân.\n\nVà cung cấp dữ liệu quan trọng để lập kế hoạch sản xuất, tiêu thụ, cũng như kết nối hiệu quả với các doanh nghiệp thu mua, góp phần xây dựng chuỗi giá trị nông sản bền vững.\n\nOpenAgri không chỉ là một nền tảng công nghệ, mà là một cam kết đồng hành cùng ngành nông nghiệp Việt Nam hướng tới một tương lai phát triển thông minh và thịnh vượng hơn. Cảm ơn quý vị đã lắng nghe.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Dự báo thời tiết và\nđưa ra lời khuyên\ncho nông dân\nTrong sản xuất nông nghiệp, chỉ  cần lệch một trận mưa hay một đợt nắng nóng là bà con có thể\nmất trắng cả vụ. Nhưng thực tế, nhiều khi bà con không kịp xem dự báo thời tiết, hoặc bản tin\nchỉ nói chung chung cho cả tỉnh, không sát với ruộng của mình.\nVì vậy, trong ứng dụng OpenAg ri, chúng em xây dựng một mục thời tiết nông vụ riêng cho từng\nkhu ruộng.\nChỉ cần mở điện thoại, bà con sẽ thấy ngay:\nThời tiết hôm nay và 7 ngày tới tại đúng vị trí ruộng của mình: có mưa hay không, nhiệt độ,\nđộ ẩm, khả năng nắng nóng kéo dài…\nNhững cảnh báo ngắn gọn, dễ hiểu, ví dụ như:\n“2–3 ngày tới khả năng mưa lớn, nên hạn chế phun thuốc trừ sâu để tránh bị rửa trôi.”\n“Nắng nóng kéo dài, nên chú ý tưới bổ sung cho lúa/gia tăng che phủ cho rau màu.”\n“Trời âm u, ẩm độ cao, nguy c ơ một số bệnh lá phát triển mạ nh, nên kiểm tra đồng\nruộng thường xuyên hơn.”\nKhông chỉ dừng ở việc “báo thời tiết”, OpenAgri cố gắng dịch thông tin thời tiết thành lời\nkhuyên nông vụ cụ thể cho bà con: nên gieo khi nào, nên tránh phun thuốc vào lúc nào, đâu là\nthời điểm thuận lợi để thu hoạch để giảm rủi ro và tiết kiệm chi phí.\nNhờ đó, thay vì phải đoán “không biết mấy hôm nữa có mưa kh ông”, bà con có thêm một công\ncụ hỗ trợ ra quyết định, giúp chủ động hơn trong canh tác, bảo vệ sức khỏe cây trồng và nâng\ncao năng suất.",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "b ả n  đ ồ  \nv ù n g  t r ồ n g\nN ế u  n h ư  p h ầ n  t h ờ i  t i ế t  v à  l ờ i  k h u y ê n  n ô n g  v ụ  g i ú p  b à  c o n  q u y ế t  đ ị n h  “ k h i  n à o\nl à m ” ,  t h ì  p h ầ n  b ả n  đ ồ  s ẽ  g i ú p  t r ả  l ờ i  c â u  h ỏ i  “ l à m  ở  đ â u ,  t r ê n  d i ệ n  t í c h  n à o ,  t ì n h\nt r ạ n g  r a  s a o ” .\nT r o n g  ứ n g  d ụ n g ,  m ỗ i  t h ử a  r u ộ n g ,  m ỗ i  v ù n g  t r ồ n g  s ẽ  đ ư ợ c  v ẽ  v à  l ư u  l ạ i  t r ê n  b ả n  đ ồ .\nB à  c o n  c ó  t h ể :\nP h ó n g  t o  n g a y  k h u  v ự c  c ủ a  m ì n h ,  k h o a n h  v ù n g  t h ử a  r u ộ n g ,  đ ặ t  t ê n ,  g h i  d i ệ n\nt í c h ,  l o ạ i  c â y  t r ồ n g .\nN h ì n  t r ê n  b ả n  đ ồ  s ẽ  t h ấ y  t o à n  b ộ  h ệ  t h ố n g  r u ộ n g  c ủ a  g i a  đ ì n h :  r u ộ n g  n à o  đ a n g\ng i e o ,  r u ộ n g  n à o  c h u ẩ n  b ị  t h u  h o ạ c h ,  r u ộ n g  n à o  c ó  c ả n h  b á o  s â u  b ệ n h  h o ặ c  t h ờ i\nt i ế t  b ấ t  l ợ i .\nK h i  r a  đ ồ n g ,  c h ỉ  c ầ n  m ở  đ i ệ n  t h o ạ i  l à  x á c  đ ị n h  đ ú n g  v ị  t r í  l ô  t h ử a ,  t r á n h  n h ầ m\nl ẫ n ,  r ấ t  t i ệ n  k h i  l à m  v i ệ c  v ớ i  h ợ p  t á c  x ã  h o ặ c  c á n  b ộ  k ỹ  t h u ậ t .\nV ớ i  h ợ p  t á c  x ã  v à  đ ị a  p h ư ơ n g ,  b ả n  đ ồ  g i ú p :\nN h ì n  t h ấ y  b ứ c  t r a n h  c h u n g  c ủ a  c ả  v ù n g :  d i ệ n  t í c h ,  c ơ  c ấ u  c â y  t r ồ n g ,  k h u  v ự c\nđ a n g  g ặ p  r ủ i  r o .\nD ễ  d à n g  l ậ p  k ế  h o ạ c h  h ỗ  t r ợ ,  p h â n  b ổ  v ậ t  t ư ,  l ê n  l ị c h  p h u n  p h ò n g ,  t h u  h o ạ c h  t ậ p\nt r u n g .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "C h ẩ n  đ o á n  b ệ n h\nt r ê n  c â y  t r ồ n g\nT r o n g  t h ự c  t ế ,  k h ô n g  p h ả i  b à  c o n  n à o  c ũ n g  c ó  đ i ề u  k i ệ n  g ặ p  c á n  b ộ  k ỹ\nt h u ậ t  t h ư ờ n g  x u y ê n ,  n h i ề u  l o ạ i  b ệ n h  l á  n h ì n  k h á  g i ố n g  n h a u ,  n ế u  đ o á n\ns a i  v à  p h u n  n h ầ m  t h u ố c  t h ì  t ố n  t i ề n  m à  b ệ n h  v ẫ n  k h ô n g  k h ỏ i ,  t h ậ m  c h í\nc â y  c ò n  y ế u  h ơ n .\nV ớ i  O p e n A g r i ,  b à  c o n  c h ỉ  c ầ n  d ù n g  đ i ệ n  t h o ạ i  c h ụ p  l ạ i  h ì n h  c h i ế c  l á\nđ a n g  b ị  b ệ n h ,  s a u  đ ó  g ử i  l ê n  ứ n g  d ụ n g .  H ệ  t h ố n g  s ẽ  s o  s á n h  v ớ i  k h o\nh ì n h  ả n h  đ ã  đ ư ợ c  “ h ọ c ”  t r ư ớ c  đ ó ,  r ồ i  đ ư a  r a  g ợ i  ý :  l á  đ a n g  c ó  d ấ u  h i ệ u\ng i ố n g  v ớ i  m ộ t  s ố  l o ạ i  b ệ n h  n à o ,  t h ư ờ n g  g ặ p  t r ê n  l o ạ i  c â y  g ì ,  ở  g i a i  đ o ạ n\nn à o .\nT r ê n  m à n  h ì n h ,  b à  c o n  s ẽ  n h ậ n  đ ư ợ c  m ộ t  s ố  p h ư ơ n g  á n  b ệ n h  c ó  k h ả\nn ă n g  c a o ,  k è m  t h e o  m ô  t ả  t r i ệ u  c h ứ n g  d ễ  h i ể u  v à  g ợ i  ý  h ư ớ n g  x ử  l ý  c ơ\nb ả n  ( v í  d ụ :  n ê n  k i ể m  t r a  t h ê m  g ì ,  n ê n  h ỏ i  c á n  b ộ  k ỹ  t h u ậ t  v ề  l o ạ i  t h u ố c\nn à o ,  c ầ n  c h ú  ý  đ i ề u  k i ệ n  ẩ m  đ ộ ,  t h o á t  n ư ớ c … ) .\nM ụ c  t i ê u  c ủ a  t í n h  n ă n g  n à y  k h ô n g  p h ả i  l à  t h a y  t h ế  c h u y ê n  g i a ,  m à  l à\ng i ú p  b à  c o n  “ n g h i  n g ờ  đ ú n g  h ư ớ n g ”  s ớ m  h ơ n ,  t r á n h  đ ể  b ệ n h  l â y  l a n\nr ộ n g  m ớ i  p h á t  h i ệ n .  N h ờ  đ ó ,  b à  c o n  c ó  t h ể  t i ế t  k i ệ m  c h i  p h í  t h u ố c ,  g i ả m\ns ố  l ầ n  p h u n ,  b ả o  v ệ  s ứ c  k h ỏ e  c h o  m ì n h  v à  m ô i  t r ư ờ n g ,  đ ồ n g  t h ờ i  g i ữ\nđ ư ợ c  n ă n g  s u ấ t  v à  c h ấ t  l ư ợ n g  n ô n g  s ả n  t ố t  h ơ n .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "D ự  b á o  r ủ i  r o\nT r o n g  s ả n  x u ấ t ,  đ i ề u  b à  c o n  l o  n h ấ t  k h ô n g  c h ỉ  l à  “ h i ệ n  t ạ i  đ a n g  b ị  g ì ”  m à  l à  “ s ắ p  t ớ i  c ó\nn g u y  c ơ  g ì  k h ô n g ” :  c ó  đ ợ t  s â u  b ệ n h  n à o  d ễ  b ù n g  l ê n ,  c ó  g i a i  đ o ạ n  t h ờ i  t i ế t  n à o  b ấ t  l ợ i\nc h o  c â y  t r ồ n g ,  c ó  n g u y  c ơ  m ấ t  m ù a  ở  k h u  v ự c  n à o …  N ế u  b i ế t  t r ư ớ c ,  b à  c o n  c ó  t h ể  c h ủ\nđ ộ n g  p h ò n g  h ơ n  l à  c h ữ a .\nT ừ  c á c  n g u ồ n  d ữ  l i ệ u  l ị c h  s ử  v ề  s â u  b ệ n h ,  t h ờ i  t i ế t  v à  v ù n g  t r ồ n g ,  h ệ  t h ố n g  s ẽ  t ổ n g\nh ợ p  l ạ i  t h à n h  n h ữ n g  c ả n h  b á o  r ủ i  r o  r ấ t  d ễ  h i ể u ,  v í  d ụ :\n“ T r o n g  7 – 1 0  n g à y  t ớ i ,  k h u  v ự c  n à y  c ó  n g u y  c ơ  c a o  x u ấ t  h i ệ n  s â u / b ệ n h  X  t r ê n  c â y\nt r ồ n g  Y . ”\n“ Đ ộ  ẩ m  c a o ,  m ư a  k é o  d à i ,  n g u y  c ơ  b ệ n h  l á  t ă n g ,  n ê n  k i ể m  t r a  đ ồ n g  r u ộ n g  t h ư ờ n g\nx u y ê n  h ơ n . ”\n“ T h ờ i  g i a n  n à y ,  n ế u  g i e o  t r ồ n g  m u ộ n ,  n g u y  c ơ  g ặ p  h ạ n  c u ố i  v ụ  s ẽ  c a o  h ơ n . ”\nT h a y  v ì  b ắ t  b à  c o n  đ ọ c  n h ữ n g  b á o  c á o  d à i  v à  p h ứ c  t ạ p ,  I C T U - O p e n A g r i  h i ể n  t h ị  m ứ c\nđ ộ  r ủ i  r o  t h e o  m à u  s ắ c ,  t h e o  k h u  v ự c ,  k è m  t h e o  l ờ i  k h u y ê n  c ụ  t h ể :  n ê n  t ă n g  c ư ờ n g\nt h ă m  đ ồ n g ,  n ê n  c h u ẩ n  b ị  p h ư ơ n g  á n  p h ò n g  t r ừ ,  h a y  n ê n  đ i ề u  c h ỉ n h  l ị c h  g i e o  t r ồ n g .\nN h ờ  v ậ y ,  n g ư ờ i  n ô n g  d â n  v à  h ợ p  t á c  x ã  k h ô n g  c ò n  b ị  đ ộ n g  c h ạ y  t h e o  t h ờ i  t i ế t  v à  s â u\nb ệ n h ,  m à  c ó  t h ê m  m ộ t  c ô n g  c ụ  d ự  b á o  s ớ m ,  g i ú p  g i ả m  t h i ệ t  h ạ i ,  t ố i  ư u  c h i  p h í  v à  ổ n\nđ ị n h  n ă n g  s u ấ t  c h o  c ả  v ụ .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Cảm ơnvì lắngnghe",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-02-01 20:10:10",
    "avatar_path": null,
    "final_video_path": null
  },
  "0a4c4e74-a189-4669-be94-2c0288517be6": {
    "id": "0a4c4e74-a189-4669-be94-2c0288517be6",
    "filename": "Open_Agri.pdf",
    "file_path": "static/uploads/presentations\\0a4c4e74-a189-4669-be94-2c0288517be6\\Open_Agri.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "Open Agri",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/0a4c4e74-a189-4669-be94-2c0288517be6/slide_1.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\0a4c4e74-a189-4669-be94-2c0288517be6\\slide_1.wav"
      },
      {
        "slide_num": 2,
        "content": "Về dự án của\nchúng tôi\nOpenAgri – Nền tảng hỗ trợ ra quyết định cho người nông dân.\nHiện nay, rất nhiều bà con nông dân vẫn phải dựa vào kinh nghiệm và… may mắn để quyết định: trồng cây gì, khi\nnào gieo, khi nào phun thuốc, khi nào thu hoạch.\nTrong khi đó, thời tiết thay đổi thất thường, sâu bệnh xuất hiện khó lường, giá nông sản lên xuống mỗi ngày. Nếu\nquyết định sai, bà con có thể mất mùa, lỗ vốn, thậm chí nợ nần.\nOpenAgri ra đời với mong muốn trở thành một người trợ lý thông minh cho người nông dân và nhà quản lý, giúp\ngiảm rủi ro, tăng năng suất và tăng thu nhập.\nThay vì phải tự đoán, bà con chỉ cần mở ứng dụng trên điện thoại là có thể:\nXem được tình trạng sức khỏe ruộng của mình qua màu sắc hiển thị trên bản đồ: vùng nào cây đang khỏe,\nvùng nào có dấu hiệu bất thường cần kiểm tra.\nNhận cảnh báo sớm về nguy cơ sâu bệnh tại khu vực của mình, dựa trên dữ liệu lịch sử và điều kiện thời tiết.\nXem thời tiết nông vụ trong 7 ngày tới để quyết định thời điểm gieo trồng, tưới nước, phun thuốc, thu hoạch\ncho phù hợp.\nTheo dõi giá cả một số loại nông sản hằng ngày, giúp lựa chọn thời điểm bán ra hợp lý hơn.\nQuản lý các thửa ruộng, diện tích, loại cây trồng, lịch sử canh tác ngay trên bản đồ, dễ dàng tra cứu và tổng\nhợp.\nVề phía cơ quan quản lý và hợp tác xã, OpenAgri hỗ trợ:\nNắm được bức tranh tổng thể vùng trồng, diện tích, cơ cấu cây trồng.\nTheo dõi tình hình sâu bệnh, năng suất dự kiến, từ đó đưa ra khuyến cáo phù hợp và kịp thời cho bà con.\nCó thêm dữ liệu để lập kế hoạch sản xuất, tiêu thụ, kết nối với doanh nghiệp thu mua.",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/0a4c4e74-a189-4669-be94-2c0288517be6/slide_2.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\0a4c4e74-a189-4669-be94-2c0288517be6\\slide_2.wav"
      },
      {
        "slide_num": 3,
        "content": "Dự báo thời tiết và\nđưa ra lời khuyên\ncho nông dân\nTrong sản xuất nông nghiệp, chỉ  cần lệch một trận mưa hay một đợt nắng nóng là bà con có thể\nmất trắng cả vụ. Nhưng thực tế, nhiều khi bà con không kịp xem dự báo thời tiết, hoặc bản tin\nchỉ nói chung chung cho cả tỉnh, không sát với ruộng của mình.\nVì vậy, trong ứng dụng OpenAg ri, chúng em xây dựng một mục thời tiết nông vụ riêng cho từng\nkhu ruộng.\nChỉ cần mở điện thoại, bà con sẽ thấy ngay:\nThời tiết hôm nay và 7 ngày tới tại đúng vị trí ruộng của mình: có mưa hay không, nhiệt độ,\nđộ ẩm, khả năng nắng nóng kéo dài…\nNhững cảnh báo ngắn gọn, dễ hiểu, ví dụ như:\n“2–3 ngày tới khả năng mưa lớn, nên hạn chế phun thuốc trừ sâu để tránh bị rửa trôi.”\n“Nắng nóng kéo dài, nên chú ý tưới bổ sung cho lúa/gia tăng che phủ cho rau màu.”\n“Trời âm u, ẩm độ cao, nguy c ơ một số bệnh lá phát triển mạ nh, nên kiểm tra đồng\nruộng thường xuyên hơn.”\nKhông chỉ dừng ở việc “báo thời tiết”, OpenAgri cố gắng dịch thông tin thời tiết thành lời\nkhuyên nông vụ cụ thể cho bà con: nên gieo khi nào, nên tránh phun thuốc vào lúc nào, đâu là\nthời điểm thuận lợi để thu hoạch để giảm rủi ro và tiết kiệm chi phí.\nNhờ đó, thay vì phải đoán “không biết mấy hôm nữa có mưa kh ông”, bà con có thêm một công\ncụ hỗ trợ ra quyết định, giúp chủ động hơn trong canh tác, bảo vệ sức khỏe cây trồng và nâng\ncao năng suất.",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/0a4c4e74-a189-4669-be94-2c0288517be6/slide_3.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\0a4c4e74-a189-4669-be94-2c0288517be6\\slide_3.wav"
      },
      {
        "slide_num": 4,
        "content": "b ả n  đ ồ  \nv ù n g  t r ồ n g\nN ế u  n h ư  p h ầ n  t h ờ i  t i ế t  v à  l ờ i  k h u y ê n  n ô n g  v ụ  g i ú p  b à  c o n  q u y ế t  đ ị n h  “ k h i  n à o\nl à m ” ,  t h ì  p h ầ n  b ả n  đ ồ  s ẽ  g i ú p  t r ả  l ờ i  c â u  h ỏ i  “ l à m  ở  đ â u ,  t r ê n  d i ệ n  t í c h  n à o ,  t ì n h\nt r ạ n g  r a  s a o ” .\nT r o n g  ứ n g  d ụ n g ,  m ỗ i  t h ử a  r u ộ n g ,  m ỗ i  v ù n g  t r ồ n g  s ẽ  đ ư ợ c  v ẽ  v à  l ư u  l ạ i  t r ê n  b ả n  đ ồ .\nB à  c o n  c ó  t h ể :\nP h ó n g  t o  n g a y  k h u  v ự c  c ủ a  m ì n h ,  k h o a n h  v ù n g  t h ử a  r u ộ n g ,  đ ặ t  t ê n ,  g h i  d i ệ n\nt í c h ,  l o ạ i  c â y  t r ồ n g .\nN h ì n  t r ê n  b ả n  đ ồ  s ẽ  t h ấ y  t o à n  b ộ  h ệ  t h ố n g  r u ộ n g  c ủ a  g i a  đ ì n h :  r u ộ n g  n à o  đ a n g\ng i e o ,  r u ộ n g  n à o  c h u ẩ n  b ị  t h u  h o ạ c h ,  r u ộ n g  n à o  c ó  c ả n h  b á o  s â u  b ệ n h  h o ặ c  t h ờ i\nt i ế t  b ấ t  l ợ i .\nK h i  r a  đ ồ n g ,  c h ỉ  c ầ n  m ở  đ i ệ n  t h o ạ i  l à  x á c  đ ị n h  đ ú n g  v ị  t r í  l ô  t h ử a ,  t r á n h  n h ầ m\nl ẫ n ,  r ấ t  t i ệ n  k h i  l à m  v i ệ c  v ớ i  h ợ p  t á c  x ã  h o ặ c  c á n  b ộ  k ỹ  t h u ậ t .\nV ớ i  h ợ p  t á c  x ã  v à  đ ị a  p h ư ơ n g ,  b ả n  đ ồ  g i ú p :\nN h ì n  t h ấ y  b ứ c  t r a n h  c h u n g  c ủ a  c ả  v ù n g :  d i ệ n  t í c h ,  c ơ  c ấ u  c â y  t r ồ n g ,  k h u  v ự c\nđ a n g  g ặ p  r ủ i  r o .\nD ễ  d à n g  l ậ p  k ế  h o ạ c h  h ỗ  t r ợ ,  p h â n  b ổ  v ậ t  t ư ,  l ê n  l ị c h  p h u n  p h ò n g ,  t h u  h o ạ c h  t ậ p\nt r u n g .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/0a4c4e74-a189-4669-be94-2c0288517be6/slide_4.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\0a4c4e74-a189-4669-be94-2c0288517be6\\slide_4.wav"
      },
      {
        "slide_num": 5,
        "content": "C h ẩ n  đ o á n  b ệ n h\nt r ê n  c â y  t r ồ n g\nT r o n g  t h ự c  t ế ,  k h ô n g  p h ả i  b à  c o n  n à o  c ũ n g  c ó  đ i ề u  k i ệ n  g ặ p  c á n  b ộ  k ỹ\nt h u ậ t  t h ư ờ n g  x u y ê n ,  n h i ề u  l o ạ i  b ệ n h  l á  n h ì n  k h á  g i ố n g  n h a u ,  n ế u  đ o á n\ns a i  v à  p h u n  n h ầ m  t h u ố c  t h ì  t ố n  t i ề n  m à  b ệ n h  v ẫ n  k h ô n g  k h ỏ i ,  t h ậ m  c h í\nc â y  c ò n  y ế u  h ơ n .\nV ớ i  O p e n A g r i ,  b à  c o n  c h ỉ  c ầ n  d ù n g  đ i ệ n  t h o ạ i  c h ụ p  l ạ i  h ì n h  c h i ế c  l á\nđ a n g  b ị  b ệ n h ,  s a u  đ ó  g ử i  l ê n  ứ n g  d ụ n g .  H ệ  t h ố n g  s ẽ  s o  s á n h  v ớ i  k h o\nh ì n h  ả n h  đ ã  đ ư ợ c  “ h ọ c ”  t r ư ớ c  đ ó ,  r ồ i  đ ư a  r a  g ợ i  ý :  l á  đ a n g  c ó  d ấ u  h i ệ u\ng i ố n g  v ớ i  m ộ t  s ố  l o ạ i  b ệ n h  n à o ,  t h ư ờ n g  g ặ p  t r ê n  l o ạ i  c â y  g ì ,  ở  g i a i  đ o ạ n\nn à o .\nT r ê n  m à n  h ì n h ,  b à  c o n  s ẽ  n h ậ n  đ ư ợ c  m ộ t  s ố  p h ư ơ n g  á n  b ệ n h  c ó  k h ả\nn ă n g  c a o ,  k è m  t h e o  m ô  t ả  t r i ệ u  c h ứ n g  d ễ  h i ể u  v à  g ợ i  ý  h ư ớ n g  x ử  l ý  c ơ\nb ả n  ( v í  d ụ :  n ê n  k i ể m  t r a  t h ê m  g ì ,  n ê n  h ỏ i  c á n  b ộ  k ỹ  t h u ậ t  v ề  l o ạ i  t h u ố c\nn à o ,  c ầ n  c h ú  ý  đ i ề u  k i ệ n  ẩ m  đ ộ ,  t h o á t  n ư ớ c … ) .\nM ụ c  t i ê u  c ủ a  t í n h  n ă n g  n à y  k h ô n g  p h ả i  l à  t h a y  t h ế  c h u y ê n  g i a ,  m à  l à\ng i ú p  b à  c o n  “ n g h i  n g ờ  đ ú n g  h ư ớ n g ”  s ớ m  h ơ n ,  t r á n h  đ ể  b ệ n h  l â y  l a n\nr ộ n g  m ớ i  p h á t  h i ệ n .  N h ờ  đ ó ,  b à  c o n  c ó  t h ể  t i ế t  k i ệ m  c h i  p h í  t h u ố c ,  g i ả m\ns ố  l ầ n  p h u n ,  b ả o  v ệ  s ứ c  k h ỏ e  c h o  m ì n h  v à  m ô i  t r ư ờ n g ,  đ ồ n g  t h ờ i  g i ữ\nđ ư ợ c  n ă n g  s u ấ t  v à  c h ấ t  l ư ợ n g  n ô n g  s ả n  t ố t  h ơ n .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/0a4c4e74-a189-4669-be94-2c0288517be6/slide_5.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\0a4c4e74-a189-4669-be94-2c0288517be6\\slide_5.wav"
      },
      {
        "slide_num": 6,
        "content": "D ự  b á o  r ủ i  r o\nT r o n g  s ả n  x u ấ t ,  đ i ề u  b à  c o n  l o  n h ấ t  k h ô n g  c h ỉ  l à  “ h i ệ n  t ạ i  đ a n g  b ị  g ì ”  m à  l à  “ s ắ p  t ớ i  c ó\nn g u y  c ơ  g ì  k h ô n g ” :  c ó  đ ợ t  s â u  b ệ n h  n à o  d ễ  b ù n g  l ê n ,  c ó  g i a i  đ o ạ n  t h ờ i  t i ế t  n à o  b ấ t  l ợ i\nc h o  c â y  t r ồ n g ,  c ó  n g u y  c ơ  m ấ t  m ù a  ở  k h u  v ự c  n à o …  N ế u  b i ế t  t r ư ớ c ,  b à  c o n  c ó  t h ể  c h ủ\nđ ộ n g  p h ò n g  h ơ n  l à  c h ữ a .\nT ừ  c á c  n g u ồ n  d ữ  l i ệ u  l ị c h  s ử  v ề  s â u  b ệ n h ,  t h ờ i  t i ế t  v à  v ù n g  t r ồ n g ,  h ệ  t h ố n g  s ẽ  t ổ n g\nh ợ p  l ạ i  t h à n h  n h ữ n g  c ả n h  b á o  r ủ i  r o  r ấ t  d ễ  h i ể u ,  v í  d ụ :\n“ T r o n g  7 – 1 0  n g à y  t ớ i ,  k h u  v ự c  n à y  c ó  n g u y  c ơ  c a o  x u ấ t  h i ệ n  s â u / b ệ n h  X  t r ê n  c â y\nt r ồ n g  Y . ”\n“ Đ ộ  ẩ m  c a o ,  m ư a  k é o  d à i ,  n g u y  c ơ  b ệ n h  l á  t ă n g ,  n ê n  k i ể m  t r a  đ ồ n g  r u ộ n g  t h ư ờ n g\nx u y ê n  h ơ n . ”\n“ T h ờ i  g i a n  n à y ,  n ế u  g i e o  t r ồ n g  m u ộ n ,  n g u y  c ơ  g ặ p  h ạ n  c u ố i  v ụ  s ẽ  c a o  h ơ n . ”\nT h a y  v ì  b ắ t  b à  c o n  đ ọ c  n h ữ n g  b á o  c á o  d à i  v à  p h ứ c  t ạ p ,  I C T U - O p e n A g r i  h i ể n  t h ị  m ứ c\nđ ộ  r ủ i  r o  t h e o  m à u  s ắ c ,  t h e o  k h u  v ự c ,  k è m  t h e o  l ờ i  k h u y ê n  c ụ  t h ể :  n ê n  t ă n g  c ư ờ n g\nt h ă m  đ ồ n g ,  n ê n  c h u ẩ n  b ị  p h ư ơ n g  á n  p h ò n g  t r ừ ,  h a y  n ê n  đ i ề u  c h ỉ n h  l ị c h  g i e o  t r ồ n g .\nN h ờ  v ậ y ,  n g ư ờ i  n ô n g  d â n  v à  h ợ p  t á c  x ã  k h ô n g  c ò n  b ị  đ ộ n g  c h ạ y  t h e o  t h ờ i  t i ế t  v à  s â u\nb ệ n h ,  m à  c ó  t h ê m  m ộ t  c ô n g  c ụ  d ự  b á o  s ớ m ,  g i ú p  g i ả m  t h i ệ t  h ạ i ,  t ố i  ư u  c h i  p h í  v à  ổ n\nđ ị n h  n ă n g  s u ấ t  c h o  c ả  v ụ .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/0a4c4e74-a189-4669-be94-2c0288517be6/slide_6.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\0a4c4e74-a189-4669-be94-2c0288517be6\\slide_6.wav"
      },
      {
        "slide_num": 7,
        "content": "Cảm ơnvì lắngnghe",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-02-01 20:13:01",
    "avatar_path": null,
    "final_video_path": null
  },
  "ac375b1f-ca6c-4972-b2a2-e37bef11dba7": {
    "id": "ac375b1f-ca6c-4972-b2a2-e37bef11dba7",
    "filename": "Open_Agri.pdf",
    "file_path": "static/uploads/presentations\\ac375b1f-ca6c-4972-b2a2-e37bef11dba7\\Open_Agri.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "Open Agri",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Về dự án của\nchúng tôi\nOpenAgri – Nền tảng hỗ trợ ra quyết định cho người nông dân.\nHiện nay, rất nhiều bà con nông dân vẫn phải dựa vào kinh nghiệm và… may mắn để quyết định: trồng cây gì, khi\nnào gieo, khi nào phun thuốc, khi nào thu hoạch.\nTrong khi đó, thời tiết thay đổi thất thường, sâu bệnh xuất hiện khó lường, giá nông sản lên xuống mỗi ngày. Nếu\nquyết định sai, bà con có thể mất mùa, lỗ vốn, thậm chí nợ nần.\nOpenAgri ra đời với mong muốn trở thành một người trợ lý thông minh cho người nông dân và nhà quản lý, giúp\ngiảm rủi ro, tăng năng suất và tăng thu nhập.\nThay vì phải tự đoán, bà con chỉ cần mở ứng dụng trên điện thoại là có thể:\nXem được tình trạng sức khỏe ruộng của mình qua màu sắc hiển thị trên bản đồ: vùng nào cây đang khỏe,\nvùng nào có dấu hiệu bất thường cần kiểm tra.\nNhận cảnh báo sớm về nguy cơ sâu bệnh tại khu vực của mình, dựa trên dữ liệu lịch sử và điều kiện thời tiết.\nXem thời tiết nông vụ trong 7 ngày tới để quyết định thời điểm gieo trồng, tưới nước, phun thuốc, thu hoạch\ncho phù hợp.\nTheo dõi giá cả một số loại nông sản hằng ngày, giúp lựa chọn thời điểm bán ra hợp lý hơn.\nQuản lý các thửa ruộng, diện tích, loại cây trồng, lịch sử canh tác ngay trên bản đồ, dễ dàng tra cứu và tổng\nhợp.\nVề phía cơ quan quản lý và hợp tác xã, OpenAgri hỗ trợ:\nNắm được bức tranh tổng thể vùng trồng, diện tích, cơ cấu cây trồng.\nTheo dõi tình hình sâu bệnh, năng suất dự kiến, từ đó đưa ra khuyến cáo phù hợp và kịp thời cho bà con.\nCó thêm dữ liệu để lập kế hoạch sản xuất, tiêu thụ, kết nối với doanh nghiệp thu mua.",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Dự báo thời tiết và\nđưa ra lời khuyên\ncho nông dân\nTrong sản xuất nông nghiệp, chỉ  cần lệch một trận mưa hay một đợt nắng nóng là bà con có thể\nmất trắng cả vụ. Nhưng thực tế, nhiều khi bà con không kịp xem dự báo thời tiết, hoặc bản tin\nchỉ nói chung chung cho cả tỉnh, không sát với ruộng của mình.\nVì vậy, trong ứng dụng OpenAg ri, chúng em xây dựng một mục thời tiết nông vụ riêng cho từng\nkhu ruộng.\nChỉ cần mở điện thoại, bà con sẽ thấy ngay:\nThời tiết hôm nay và 7 ngày tới tại đúng vị trí ruộng của mình: có mưa hay không, nhiệt độ,\nđộ ẩm, khả năng nắng nóng kéo dài…\nNhững cảnh báo ngắn gọn, dễ hiểu, ví dụ như:\n“2–3 ngày tới khả năng mưa lớn, nên hạn chế phun thuốc trừ sâu để tránh bị rửa trôi.”\n“Nắng nóng kéo dài, nên chú ý tưới bổ sung cho lúa/gia tăng che phủ cho rau màu.”\n“Trời âm u, ẩm độ cao, nguy c ơ một số bệnh lá phát triển mạ nh, nên kiểm tra đồng\nruộng thường xuyên hơn.”\nKhông chỉ dừng ở việc “báo thời tiết”, OpenAgri cố gắng dịch thông tin thời tiết thành lời\nkhuyên nông vụ cụ thể cho bà con: nên gieo khi nào, nên tránh phun thuốc vào lúc nào, đâu là\nthời điểm thuận lợi để thu hoạch để giảm rủi ro và tiết kiệm chi phí.\nNhờ đó, thay vì phải đoán “không biết mấy hôm nữa có mưa kh ông”, bà con có thêm một công\ncụ hỗ trợ ra quyết định, giúp chủ động hơn trong canh tác, bảo vệ sức khỏe cây trồng và nâng\ncao năng suất.",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "b ả n  đ ồ  \nv ù n g  t r ồ n g\nN ế u  n h ư  p h ầ n  t h ờ i  t i ế t  v à  l ờ i  k h u y ê n  n ô n g  v ụ  g i ú p  b à  c o n  q u y ế t  đ ị n h  “ k h i  n à o\nl à m ” ,  t h ì  p h ầ n  b ả n  đ ồ  s ẽ  g i ú p  t r ả  l ờ i  c â u  h ỏ i  “ l à m  ở  đ â u ,  t r ê n  d i ệ n  t í c h  n à o ,  t ì n h\nt r ạ n g  r a  s a o ” .\nT r o n g  ứ n g  d ụ n g ,  m ỗ i  t h ử a  r u ộ n g ,  m ỗ i  v ù n g  t r ồ n g  s ẽ  đ ư ợ c  v ẽ  v à  l ư u  l ạ i  t r ê n  b ả n  đ ồ .\nB à  c o n  c ó  t h ể :\nP h ó n g  t o  n g a y  k h u  v ự c  c ủ a  m ì n h ,  k h o a n h  v ù n g  t h ử a  r u ộ n g ,  đ ặ t  t ê n ,  g h i  d i ệ n\nt í c h ,  l o ạ i  c â y  t r ồ n g .\nN h ì n  t r ê n  b ả n  đ ồ  s ẽ  t h ấ y  t o à n  b ộ  h ệ  t h ố n g  r u ộ n g  c ủ a  g i a  đ ì n h :  r u ộ n g  n à o  đ a n g\ng i e o ,  r u ộ n g  n à o  c h u ẩ n  b ị  t h u  h o ạ c h ,  r u ộ n g  n à o  c ó  c ả n h  b á o  s â u  b ệ n h  h o ặ c  t h ờ i\nt i ế t  b ấ t  l ợ i .\nK h i  r a  đ ồ n g ,  c h ỉ  c ầ n  m ở  đ i ệ n  t h o ạ i  l à  x á c  đ ị n h  đ ú n g  v ị  t r í  l ô  t h ử a ,  t r á n h  n h ầ m\nl ẫ n ,  r ấ t  t i ệ n  k h i  l à m  v i ệ c  v ớ i  h ợ p  t á c  x ã  h o ặ c  c á n  b ộ  k ỹ  t h u ậ t .\nV ớ i  h ợ p  t á c  x ã  v à  đ ị a  p h ư ơ n g ,  b ả n  đ ồ  g i ú p :\nN h ì n  t h ấ y  b ứ c  t r a n h  c h u n g  c ủ a  c ả  v ù n g :  d i ệ n  t í c h ,  c ơ  c ấ u  c â y  t r ồ n g ,  k h u  v ự c\nđ a n g  g ặ p  r ủ i  r o .\nD ễ  d à n g  l ậ p  k ế  h o ạ c h  h ỗ  t r ợ ,  p h â n  b ổ  v ậ t  t ư ,  l ê n  l ị c h  p h u n  p h ò n g ,  t h u  h o ạ c h  t ậ p\nt r u n g .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "C h ẩ n  đ o á n  b ệ n h\nt r ê n  c â y  t r ồ n g\nT r o n g  t h ự c  t ế ,  k h ô n g  p h ả i  b à  c o n  n à o  c ũ n g  c ó  đ i ề u  k i ệ n  g ặ p  c á n  b ộ  k ỹ\nt h u ậ t  t h ư ờ n g  x u y ê n ,  n h i ề u  l o ạ i  b ệ n h  l á  n h ì n  k h á  g i ố n g  n h a u ,  n ế u  đ o á n\ns a i  v à  p h u n  n h ầ m  t h u ố c  t h ì  t ố n  t i ề n  m à  b ệ n h  v ẫ n  k h ô n g  k h ỏ i ,  t h ậ m  c h í\nc â y  c ò n  y ế u  h ơ n .\nV ớ i  O p e n A g r i ,  b à  c o n  c h ỉ  c ầ n  d ù n g  đ i ệ n  t h o ạ i  c h ụ p  l ạ i  h ì n h  c h i ế c  l á\nđ a n g  b ị  b ệ n h ,  s a u  đ ó  g ử i  l ê n  ứ n g  d ụ n g .  H ệ  t h ố n g  s ẽ  s o  s á n h  v ớ i  k h o\nh ì n h  ả n h  đ ã  đ ư ợ c  “ h ọ c ”  t r ư ớ c  đ ó ,  r ồ i  đ ư a  r a  g ợ i  ý :  l á  đ a n g  c ó  d ấ u  h i ệ u\ng i ố n g  v ớ i  m ộ t  s ố  l o ạ i  b ệ n h  n à o ,  t h ư ờ n g  g ặ p  t r ê n  l o ạ i  c â y  g ì ,  ở  g i a i  đ o ạ n\nn à o .\nT r ê n  m à n  h ì n h ,  b à  c o n  s ẽ  n h ậ n  đ ư ợ c  m ộ t  s ố  p h ư ơ n g  á n  b ệ n h  c ó  k h ả\nn ă n g  c a o ,  k è m  t h e o  m ô  t ả  t r i ệ u  c h ứ n g  d ễ  h i ể u  v à  g ợ i  ý  h ư ớ n g  x ử  l ý  c ơ\nb ả n  ( v í  d ụ :  n ê n  k i ể m  t r a  t h ê m  g ì ,  n ê n  h ỏ i  c á n  b ộ  k ỹ  t h u ậ t  v ề  l o ạ i  t h u ố c\nn à o ,  c ầ n  c h ú  ý  đ i ề u  k i ệ n  ẩ m  đ ộ ,  t h o á t  n ư ớ c … ) .\nM ụ c  t i ê u  c ủ a  t í n h  n ă n g  n à y  k h ô n g  p h ả i  l à  t h a y  t h ế  c h u y ê n  g i a ,  m à  l à\ng i ú p  b à  c o n  “ n g h i  n g ờ  đ ú n g  h ư ớ n g ”  s ớ m  h ơ n ,  t r á n h  đ ể  b ệ n h  l â y  l a n\nr ộ n g  m ớ i  p h á t  h i ệ n .  N h ờ  đ ó ,  b à  c o n  c ó  t h ể  t i ế t  k i ệ m  c h i  p h í  t h u ố c ,  g i ả m\ns ố  l ầ n  p h u n ,  b ả o  v ệ  s ứ c  k h ỏ e  c h o  m ì n h  v à  m ô i  t r ư ờ n g ,  đ ồ n g  t h ờ i  g i ữ\nđ ư ợ c  n ă n g  s u ấ t  v à  c h ấ t  l ư ợ n g  n ô n g  s ả n  t ố t  h ơ n .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "D ự  b á o  r ủ i  r o\nT r o n g  s ả n  x u ấ t ,  đ i ề u  b à  c o n  l o  n h ấ t  k h ô n g  c h ỉ  l à  “ h i ệ n  t ạ i  đ a n g  b ị  g ì ”  m à  l à  “ s ắ p  t ớ i  c ó\nn g u y  c ơ  g ì  k h ô n g ” :  c ó  đ ợ t  s â u  b ệ n h  n à o  d ễ  b ù n g  l ê n ,  c ó  g i a i  đ o ạ n  t h ờ i  t i ế t  n à o  b ấ t  l ợ i\nc h o  c â y  t r ồ n g ,  c ó  n g u y  c ơ  m ấ t  m ù a  ở  k h u  v ự c  n à o …  N ế u  b i ế t  t r ư ớ c ,  b à  c o n  c ó  t h ể  c h ủ\nđ ộ n g  p h ò n g  h ơ n  l à  c h ữ a .\nT ừ  c á c  n g u ồ n  d ữ  l i ệ u  l ị c h  s ử  v ề  s â u  b ệ n h ,  t h ờ i  t i ế t  v à  v ù n g  t r ồ n g ,  h ệ  t h ố n g  s ẽ  t ổ n g\nh ợ p  l ạ i  t h à n h  n h ữ n g  c ả n h  b á o  r ủ i  r o  r ấ t  d ễ  h i ể u ,  v í  d ụ :\n“ T r o n g  7 – 1 0  n g à y  t ớ i ,  k h u  v ự c  n à y  c ó  n g u y  c ơ  c a o  x u ấ t  h i ệ n  s â u / b ệ n h  X  t r ê n  c â y\nt r ồ n g  Y . ”\n“ Đ ộ  ẩ m  c a o ,  m ư a  k é o  d à i ,  n g u y  c ơ  b ệ n h  l á  t ă n g ,  n ê n  k i ể m  t r a  đ ồ n g  r u ộ n g  t h ư ờ n g\nx u y ê n  h ơ n . ”\n“ T h ờ i  g i a n  n à y ,  n ế u  g i e o  t r ồ n g  m u ộ n ,  n g u y  c ơ  g ặ p  h ạ n  c u ố i  v ụ  s ẽ  c a o  h ơ n . ”\nT h a y  v ì  b ắ t  b à  c o n  đ ọ c  n h ữ n g  b á o  c á o  d à i  v à  p h ứ c  t ạ p ,  I C T U - O p e n A g r i  h i ể n  t h ị  m ứ c\nđ ộ  r ủ i  r o  t h e o  m à u  s ắ c ,  t h e o  k h u  v ự c ,  k è m  t h e o  l ờ i  k h u y ê n  c ụ  t h ể :  n ê n  t ă n g  c ư ờ n g\nt h ă m  đ ồ n g ,  n ê n  c h u ẩ n  b ị  p h ư ơ n g  á n  p h ò n g  t r ừ ,  h a y  n ê n  đ i ề u  c h ỉ n h  l ị c h  g i e o  t r ồ n g .\nN h ờ  v ậ y ,  n g ư ờ i  n ô n g  d â n  v à  h ợ p  t á c  x ã  k h ô n g  c ò n  b ị  đ ộ n g  c h ạ y  t h e o  t h ờ i  t i ế t  v à  s â u\nb ệ n h ,  m à  c ó  t h ê m  m ộ t  c ô n g  c ụ  d ự  b á o  s ớ m ,  g i ú p  g i ả m  t h i ệ t  h ạ i ,  t ố i  ư u  c h i  p h í  v à  ổ n\nđ ị n h  n ă n g  s u ấ t  c h o  c ả  v ụ .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Cảm ơnvì lắngnghe",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-02-01 20:17:03",
    "avatar_path": null,
    "final_video_path": null
  },
  "447926ba-820c-49c5-82fa-5f1bd7cb3ad6": {
    "id": "447926ba-820c-49c5-82fa-5f1bd7cb3ad6",
    "filename": "Maui_Xaml_Binding_Lab_Handout.pdf",
    "file_path": "static/uploads/presentations\\447926ba-820c-49c5-82fa-5f1bd7cb3ad6\\Maui_Xaml_Binding_Lab_Handout.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "LAB HANDOUT \nMAUI XAML Binding Practice with CommunityToolkit.Mvvm \n \nCourse / Module \nMobile Application Development (.NET MAUI) \nLab Title \nTask Manager – XAML Data Binding & MVVM Toolkit \nDuration \n3 hours (180 minutes) \nLab Type \nIndividual – Hands-on Practice \n \n1. Lab Objectives \nAfter completing this lab, students will be able to: \n• Explain the purpose of data binding in .NET MAUI \n• Apply MVVM pattern using CommunityToolkit.Mvvm \n• Correctly use common binding modes in XAML \n• Bind UI elements to ViewModel properties and commands \n• Use converters and MultiBinding in real UI scenarios \n \n2. Software & Tools \n• Visual Studio 2022 or later \n• .NET MAUI workload installed \n• NuGet package: \no CommunityToolkit.Mvvm",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "3. Problem Description \nYou are required to build a single-screen Task Manager application using .NET MAUI \n(XAML). \nThe application allows users to: - Enter a task name - Add the task to a list - Mark tasks as \ncompleted - View task statistics (total and completed) \n    Constraints - No navigation between pages - No database or API - No code-\nbehind logic for UI behavior - All interactions must be implemented using data \nbinding and commands \n \n4. User Interface Specification \nMain Screen Components \n1. Application title: MY TASKS \n2. Text input for new task \n3. Add button \n4. Task list (CollectionView) \n5. Checkbox for task completion \n6. Summary section displaying: \no Total tasks \no Completed tasks \n \n5. Required Binding Types \nYour solution must demonstrate the following bindings: \nNo Binding Type Required Usage \n1 OneWay Display task title \n2 TwoWay Entry ↔ ViewModel property \n3 OneWayToSource Selected task \n4 Command Add task action \n5 RelativeSource Access ViewModel from item template \n6 x:Reference UI-to-UI binding \n7 Converter Completed task text style \n8 MultiBinding Summary text \n9 ObservableCollection Auto-update task list \n10 INotifyPropertyChanged ViewModel updates",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "6. Data Model \nCreate a TaskItem model that contains: \n• Title (string) \n• IsCompleted (bool) \nThe model must inherit from ObservableObject. \n \n7. ViewModel Requirements \nCreate TasksViewModel with the following: \nProperties \n• NewTaskTitle (string) \n• Tasks (ObservableCollection) \n• SelectedTask (TaskItem) \n• TotalCount (int) \n• CompletedCount (int) \nCommands \n• AddTaskCommand \nUse [ObservableProperty] and [RelayCommand] attributes where applicable. \n \n8. XAML Requirements \n• Bind Entry.Text using TwoWay binding \n• Bind Button.Command to ViewModel command \n• Use CollectionView for task list \n• Bind CheckBox.IsChecked using TwoWay binding \n• Use a Value Converter to apply strikethrough to completed tasks \n• Use MultiBinding for summary text \n• Use x:Reference at least once \n \n9. Suggested Lab Steps \n1. Create a new .NET MAUI project",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "2. Install CommunityToolkit.Mvvm \n3. Create the model class \n4. Create the ViewModel \n5. Design the UI in XAML \n6. Apply required bindings \n7. Test UI behavior \n \n10. Assessment Rubric (10 Marks) \nCriteria Marks \nCorrect MVVM structure 2 \nProper use of binding modes 3 \nCommand implementation 2 \nConverter & MultiBinding 2 \nUI completeness & clarity 1 \n \n11. Submission Requirements \nStudents must submit: \n• Source code folder or Git repository \n• Screenshot of running application \n \n12. Notes \n• Code-behind should be minimal or empty \n• Focus on binding correctness, not UI aesthetics \n• Naming conventions and clean structure are required \n \nEnd of Lab",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-02-01 20:21:59",
    "avatar_path": null,
    "final_video_path": null
  },
  "e4fabf07-a184-416e-aa76-d665e2d1e086": {
    "id": "e4fabf07-a184-416e-aa76-d665e2d1e086",
    "filename": "Maui_Xaml_Binding_Lab_Handout.pdf",
    "file_path": "static/uploads/presentations\\e4fabf07-a184-416e-aa76-d665e2d1e086\\Maui_Xaml_Binding_Lab_Handout.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "LAB HANDOUT \nMAUI XAML Binding Practice with CommunityToolkit.Mvvm \n \nCourse / Module \nMobile Application Development (.NET MAUI) \nLab Title \nTask Manager – XAML Data Binding & MVVM Toolkit \nDuration \n3 hours (180 minutes) \nLab Type \nIndividual – Hands-on Practice \n \n1. Lab Objectives \nAfter completing this lab, students will be able to: \n• Explain the purpose of data binding in .NET MAUI \n• Apply MVVM pattern using CommunityToolkit.Mvvm \n• Correctly use common binding modes in XAML \n• Bind UI elements to ViewModel properties and commands \n• Use converters and MultiBinding in real UI scenarios \n \n2. Software & Tools \n• Visual Studio 2022 or later \n• .NET MAUI workload installed \n• NuGet package: \no CommunityToolkit.Mvvm",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "3. Problem Description \nYou are required to build a single-screen Task Manager application using .NET MAUI \n(XAML). \nThe application allows users to: - Enter a task name - Add the task to a list - Mark tasks as \ncompleted - View task statistics (total and completed) \n    Constraints - No navigation between pages - No database or API - No code-\nbehind logic for UI behavior - All interactions must be implemented using data \nbinding and commands \n \n4. User Interface Specification \nMain Screen Components \n1. Application title: MY TASKS \n2. Text input for new task \n3. Add button \n4. Task list (CollectionView) \n5. Checkbox for task completion \n6. Summary section displaying: \no Total tasks \no Completed tasks \n \n5. Required Binding Types \nYour solution must demonstrate the following bindings: \nNo Binding Type Required Usage \n1 OneWay Display task title \n2 TwoWay Entry ↔ ViewModel property \n3 OneWayToSource Selected task \n4 Command Add task action \n5 RelativeSource Access ViewModel from item template \n6 x:Reference UI-to-UI binding \n7 Converter Completed task text style \n8 MultiBinding Summary text \n9 ObservableCollection Auto-update task list \n10 INotifyPropertyChanged ViewModel updates",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "6. Data Model \nCreate a TaskItem model that contains: \n• Title (string) \n• IsCompleted (bool) \nThe model must inherit from ObservableObject. \n \n7. ViewModel Requirements \nCreate TasksViewModel with the following: \nProperties \n• NewTaskTitle (string) \n• Tasks (ObservableCollection) \n• SelectedTask (TaskItem) \n• TotalCount (int) \n• CompletedCount (int) \nCommands \n• AddTaskCommand \nUse [ObservableProperty] and [RelayCommand] attributes where applicable. \n \n8. XAML Requirements \n• Bind Entry.Text using TwoWay binding \n• Bind Button.Command to ViewModel command \n• Use CollectionView for task list \n• Bind CheckBox.IsChecked using TwoWay binding \n• Use a Value Converter to apply strikethrough to completed tasks \n• Use MultiBinding for summary text \n• Use x:Reference at least once \n \n9. Suggested Lab Steps \n1. Create a new .NET MAUI project",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "2. Install CommunityToolkit.Mvvm \n3. Create the model class \n4. Create the ViewModel \n5. Design the UI in XAML \n6. Apply required bindings \n7. Test UI behavior \n \n10. Assessment Rubric (10 Marks) \nCriteria Marks \nCorrect MVVM structure 2 \nProper use of binding modes 3 \nCommand implementation 2 \nConverter & MultiBinding 2 \nUI completeness & clarity 1 \n \n11. Submission Requirements \nStudents must submit: \n• Source code folder or Git repository \n• Screenshot of running application \n \n12. Notes \n• Code-behind should be minimal or empty \n• Focus on binding correctness, not UI aesthetics \n• Naming conventions and clean structure are required \n \nEnd of Lab",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-02-01 20:27:22",
    "avatar_path": null,
    "final_video_path": null
  },
  "f0e34f90-477e-49e3-974c-9bc0e99ce91e": {
    "id": "f0e34f90-477e-49e3-974c-9bc0e99ce91e",
    "filename": "Open_Agri.pdf",
    "file_path": "static/uploads/presentations\\f0e34f90-477e-49e3-974c-9bc0e99ce91e\\Open_Agri.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "Open Agri",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/f0e34f90-477e-49e3-974c-9bc0e99ce91e/slide_1.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\f0e34f90-477e-49e3-974c-9bc0e99ce91e\\slide_1.wav"
      },
      {
        "slide_num": 2,
        "content": "Về dự án của\nchúng tôi\nOpenAgri – Nền tảng hỗ trợ ra quyết định cho người nông dân.\nHiện nay, rất nhiều bà con nông dân vẫn phải dựa vào kinh nghiệm và… may mắn để quyết định: trồng cây gì, khi\nnào gieo, khi nào phun thuốc, khi nào thu hoạch.\nTrong khi đó, thời tiết thay đổi thất thường, sâu bệnh xuất hiện khó lường, giá nông sản lên xuống mỗi ngày. Nếu\nquyết định sai, bà con có thể mất mùa, lỗ vốn, thậm chí nợ nần.\nOpenAgri ra đời với mong muốn trở thành một người trợ lý thông minh cho người nông dân và nhà quản lý, giúp\ngiảm rủi ro, tăng năng suất và tăng thu nhập.\nThay vì phải tự đoán, bà con chỉ cần mở ứng dụng trên điện thoại là có thể:\nXem được tình trạng sức khỏe ruộng của mình qua màu sắc hiển thị trên bản đồ: vùng nào cây đang khỏe,\nvùng nào có dấu hiệu bất thường cần kiểm tra.\nNhận cảnh báo sớm về nguy cơ sâu bệnh tại khu vực của mình, dựa trên dữ liệu lịch sử và điều kiện thời tiết.\nXem thời tiết nông vụ trong 7 ngày tới để quyết định thời điểm gieo trồng, tưới nước, phun thuốc, thu hoạch\ncho phù hợp.\nTheo dõi giá cả một số loại nông sản hằng ngày, giúp lựa chọn thời điểm bán ra hợp lý hơn.\nQuản lý các thửa ruộng, diện tích, loại cây trồng, lịch sử canh tác ngay trên bản đồ, dễ dàng tra cứu và tổng\nhợp.\nVề phía cơ quan quản lý và hợp tác xã, OpenAgri hỗ trợ:\nNắm được bức tranh tổng thể vùng trồng, diện tích, cơ cấu cây trồng.\nTheo dõi tình hình sâu bệnh, năng suất dự kiến, từ đó đưa ra khuyến cáo phù hợp và kịp thời cho bà con.\nCó thêm dữ liệu để lập kế hoạch sản xuất, tiêu thụ, kết nối với doanh nghiệp thu mua.",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/f0e34f90-477e-49e3-974c-9bc0e99ce91e/slide_2.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\f0e34f90-477e-49e3-974c-9bc0e99ce91e\\slide_2.wav"
      },
      {
        "slide_num": 3,
        "content": "Dự báo thời tiết và\nđưa ra lời khuyên\ncho nông dân\nTrong sản xuất nông nghiệp, chỉ  cần lệch một trận mưa hay một đợt nắng nóng là bà con có thể\nmất trắng cả vụ. Nhưng thực tế, nhiều khi bà con không kịp xem dự báo thời tiết, hoặc bản tin\nchỉ nói chung chung cho cả tỉnh, không sát với ruộng của mình.\nVì vậy, trong ứng dụng OpenAg ri, chúng em xây dựng một mục thời tiết nông vụ riêng cho từng\nkhu ruộng.\nChỉ cần mở điện thoại, bà con sẽ thấy ngay:\nThời tiết hôm nay và 7 ngày tới tại đúng vị trí ruộng của mình: có mưa hay không, nhiệt độ,\nđộ ẩm, khả năng nắng nóng kéo dài…\nNhững cảnh báo ngắn gọn, dễ hiểu, ví dụ như:\n“2–3 ngày tới khả năng mưa lớn, nên hạn chế phun thuốc trừ sâu để tránh bị rửa trôi.”\n“Nắng nóng kéo dài, nên chú ý tưới bổ sung cho lúa/gia tăng che phủ cho rau màu.”\n“Trời âm u, ẩm độ cao, nguy c ơ một số bệnh lá phát triển mạ nh, nên kiểm tra đồng\nruộng thường xuyên hơn.”\nKhông chỉ dừng ở việc “báo thời tiết”, OpenAgri cố gắng dịch thông tin thời tiết thành lời\nkhuyên nông vụ cụ thể cho bà con: nên gieo khi nào, nên tránh phun thuốc vào lúc nào, đâu là\nthời điểm thuận lợi để thu hoạch để giảm rủi ro và tiết kiệm chi phí.\nNhờ đó, thay vì phải đoán “không biết mấy hôm nữa có mưa kh ông”, bà con có thêm một công\ncụ hỗ trợ ra quyết định, giúp chủ động hơn trong canh tác, bảo vệ sức khỏe cây trồng và nâng\ncao năng suất.",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/f0e34f90-477e-49e3-974c-9bc0e99ce91e/slide_3.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\f0e34f90-477e-49e3-974c-9bc0e99ce91e\\slide_3.wav"
      },
      {
        "slide_num": 4,
        "content": "b ả n  đ ồ  \nv ù n g  t r ồ n g\nN ế u  n h ư  p h ầ n  t h ờ i  t i ế t  v à  l ờ i  k h u y ê n  n ô n g  v ụ  g i ú p  b à  c o n  q u y ế t  đ ị n h  “ k h i  n à o\nl à m ” ,  t h ì  p h ầ n  b ả n  đ ồ  s ẽ  g i ú p  t r ả  l ờ i  c â u  h ỏ i  “ l à m  ở  đ â u ,  t r ê n  d i ệ n  t í c h  n à o ,  t ì n h\nt r ạ n g  r a  s a o ” .\nT r o n g  ứ n g  d ụ n g ,  m ỗ i  t h ử a  r u ộ n g ,  m ỗ i  v ù n g  t r ồ n g  s ẽ  đ ư ợ c  v ẽ  v à  l ư u  l ạ i  t r ê n  b ả n  đ ồ .\nB à  c o n  c ó  t h ể :\nP h ó n g  t o  n g a y  k h u  v ự c  c ủ a  m ì n h ,  k h o a n h  v ù n g  t h ử a  r u ộ n g ,  đ ặ t  t ê n ,  g h i  d i ệ n\nt í c h ,  l o ạ i  c â y  t r ồ n g .\nN h ì n  t r ê n  b ả n  đ ồ  s ẽ  t h ấ y  t o à n  b ộ  h ệ  t h ố n g  r u ộ n g  c ủ a  g i a  đ ì n h :  r u ộ n g  n à o  đ a n g\ng i e o ,  r u ộ n g  n à o  c h u ẩ n  b ị  t h u  h o ạ c h ,  r u ộ n g  n à o  c ó  c ả n h  b á o  s â u  b ệ n h  h o ặ c  t h ờ i\nt i ế t  b ấ t  l ợ i .\nK h i  r a  đ ồ n g ,  c h ỉ  c ầ n  m ở  đ i ệ n  t h o ạ i  l à  x á c  đ ị n h  đ ú n g  v ị  t r í  l ô  t h ử a ,  t r á n h  n h ầ m\nl ẫ n ,  r ấ t  t i ệ n  k h i  l à m  v i ệ c  v ớ i  h ợ p  t á c  x ã  h o ặ c  c á n  b ộ  k ỹ  t h u ậ t .\nV ớ i  h ợ p  t á c  x ã  v à  đ ị a  p h ư ơ n g ,  b ả n  đ ồ  g i ú p :\nN h ì n  t h ấ y  b ứ c  t r a n h  c h u n g  c ủ a  c ả  v ù n g :  d i ệ n  t í c h ,  c ơ  c ấ u  c â y  t r ồ n g ,  k h u  v ự c\nđ a n g  g ặ p  r ủ i  r o .\nD ễ  d à n g  l ậ p  k ế  h o ạ c h  h ỗ  t r ợ ,  p h â n  b ổ  v ậ t  t ư ,  l ê n  l ị c h  p h u n  p h ò n g ,  t h u  h o ạ c h  t ậ p\nt r u n g .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/f0e34f90-477e-49e3-974c-9bc0e99ce91e/slide_4.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\f0e34f90-477e-49e3-974c-9bc0e99ce91e\\slide_4.wav"
      },
      {
        "slide_num": 5,
        "content": "C h ẩ n  đ o á n  b ệ n h\nt r ê n  c â y  t r ồ n g\nT r o n g  t h ự c  t ế ,  k h ô n g  p h ả i  b à  c o n  n à o  c ũ n g  c ó  đ i ề u  k i ệ n  g ặ p  c á n  b ộ  k ỹ\nt h u ậ t  t h ư ờ n g  x u y ê n ,  n h i ề u  l o ạ i  b ệ n h  l á  n h ì n  k h á  g i ố n g  n h a u ,  n ế u  đ o á n\ns a i  v à  p h u n  n h ầ m  t h u ố c  t h ì  t ố n  t i ề n  m à  b ệ n h  v ẫ n  k h ô n g  k h ỏ i ,  t h ậ m  c h í\nc â y  c ò n  y ế u  h ơ n .\nV ớ i  O p e n A g r i ,  b à  c o n  c h ỉ  c ầ n  d ù n g  đ i ệ n  t h o ạ i  c h ụ p  l ạ i  h ì n h  c h i ế c  l á\nđ a n g  b ị  b ệ n h ,  s a u  đ ó  g ử i  l ê n  ứ n g  d ụ n g .  H ệ  t h ố n g  s ẽ  s o  s á n h  v ớ i  k h o\nh ì n h  ả n h  đ ã  đ ư ợ c  “ h ọ c ”  t r ư ớ c  đ ó ,  r ồ i  đ ư a  r a  g ợ i  ý :  l á  đ a n g  c ó  d ấ u  h i ệ u\ng i ố n g  v ớ i  m ộ t  s ố  l o ạ i  b ệ n h  n à o ,  t h ư ờ n g  g ặ p  t r ê n  l o ạ i  c â y  g ì ,  ở  g i a i  đ o ạ n\nn à o .\nT r ê n  m à n  h ì n h ,  b à  c o n  s ẽ  n h ậ n  đ ư ợ c  m ộ t  s ố  p h ư ơ n g  á n  b ệ n h  c ó  k h ả\nn ă n g  c a o ,  k è m  t h e o  m ô  t ả  t r i ệ u  c h ứ n g  d ễ  h i ể u  v à  g ợ i  ý  h ư ớ n g  x ử  l ý  c ơ\nb ả n  ( v í  d ụ :  n ê n  k i ể m  t r a  t h ê m  g ì ,  n ê n  h ỏ i  c á n  b ộ  k ỹ  t h u ậ t  v ề  l o ạ i  t h u ố c\nn à o ,  c ầ n  c h ú  ý  đ i ề u  k i ệ n  ẩ m  đ ộ ,  t h o á t  n ư ớ c … ) .\nM ụ c  t i ê u  c ủ a  t í n h  n ă n g  n à y  k h ô n g  p h ả i  l à  t h a y  t h ế  c h u y ê n  g i a ,  m à  l à\ng i ú p  b à  c o n  “ n g h i  n g ờ  đ ú n g  h ư ớ n g ”  s ớ m  h ơ n ,  t r á n h  đ ể  b ệ n h  l â y  l a n\nr ộ n g  m ớ i  p h á t  h i ệ n .  N h ờ  đ ó ,  b à  c o n  c ó  t h ể  t i ế t  k i ệ m  c h i  p h í  t h u ố c ,  g i ả m\ns ố  l ầ n  p h u n ,  b ả o  v ệ  s ứ c  k h ỏ e  c h o  m ì n h  v à  m ô i  t r ư ờ n g ,  đ ồ n g  t h ờ i  g i ữ\nđ ư ợ c  n ă n g  s u ấ t  v à  c h ấ t  l ư ợ n g  n ô n g  s ả n  t ố t  h ơ n .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/f0e34f90-477e-49e3-974c-9bc0e99ce91e/slide_5.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\f0e34f90-477e-49e3-974c-9bc0e99ce91e\\slide_5.wav"
      },
      {
        "slide_num": 6,
        "content": "D ự  b á o  r ủ i  r o\nT r o n g  s ả n  x u ấ t ,  đ i ề u  b à  c o n  l o  n h ấ t  k h ô n g  c h ỉ  l à  “ h i ệ n  t ạ i  đ a n g  b ị  g ì ”  m à  l à  “ s ắ p  t ớ i  c ó\nn g u y  c ơ  g ì  k h ô n g ” :  c ó  đ ợ t  s â u  b ệ n h  n à o  d ễ  b ù n g  l ê n ,  c ó  g i a i  đ o ạ n  t h ờ i  t i ế t  n à o  b ấ t  l ợ i\nc h o  c â y  t r ồ n g ,  c ó  n g u y  c ơ  m ấ t  m ù a  ở  k h u  v ự c  n à o …  N ế u  b i ế t  t r ư ớ c ,  b à  c o n  c ó  t h ể  c h ủ\nđ ộ n g  p h ò n g  h ơ n  l à  c h ữ a .\nT ừ  c á c  n g u ồ n  d ữ  l i ệ u  l ị c h  s ử  v ề  s â u  b ệ n h ,  t h ờ i  t i ế t  v à  v ù n g  t r ồ n g ,  h ệ  t h ố n g  s ẽ  t ổ n g\nh ợ p  l ạ i  t h à n h  n h ữ n g  c ả n h  b á o  r ủ i  r o  r ấ t  d ễ  h i ể u ,  v í  d ụ :\n“ T r o n g  7 – 1 0  n g à y  t ớ i ,  k h u  v ự c  n à y  c ó  n g u y  c ơ  c a o  x u ấ t  h i ệ n  s â u / b ệ n h  X  t r ê n  c â y\nt r ồ n g  Y . ”\n“ Đ ộ  ẩ m  c a o ,  m ư a  k é o  d à i ,  n g u y  c ơ  b ệ n h  l á  t ă n g ,  n ê n  k i ể m  t r a  đ ồ n g  r u ộ n g  t h ư ờ n g\nx u y ê n  h ơ n . ”\n“ T h ờ i  g i a n  n à y ,  n ế u  g i e o  t r ồ n g  m u ộ n ,  n g u y  c ơ  g ặ p  h ạ n  c u ố i  v ụ  s ẽ  c a o  h ơ n . ”\nT h a y  v ì  b ắ t  b à  c o n  đ ọ c  n h ữ n g  b á o  c á o  d à i  v à  p h ứ c  t ạ p ,  I C T U - O p e n A g r i  h i ể n  t h ị  m ứ c\nđ ộ  r ủ i  r o  t h e o  m à u  s ắ c ,  t h e o  k h u  v ự c ,  k è m  t h e o  l ờ i  k h u y ê n  c ụ  t h ể :  n ê n  t ă n g  c ư ờ n g\nt h ă m  đ ồ n g ,  n ê n  c h u ẩ n  b ị  p h ư ơ n g  á n  p h ò n g  t r ừ ,  h a y  n ê n  đ i ề u  c h ỉ n h  l ị c h  g i e o  t r ồ n g .\nN h ờ  v ậ y ,  n g ư ờ i  n ô n g  d â n  v à  h ợ p  t á c  x ã  k h ô n g  c ò n  b ị  đ ộ n g  c h ạ y  t h e o  t h ờ i  t i ế t  v à  s â u\nb ệ n h ,  m à  c ó  t h ê m  m ộ t  c ô n g  c ụ  d ự  b á o  s ớ m ,  g i ú p  g i ả m  t h i ệ t  h ạ i ,  t ố i  ư u  c h i  p h í  v à  ổ n\nđ ị n h  n ă n g  s u ấ t  c h o  c ả  v ụ .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/f0e34f90-477e-49e3-974c-9bc0e99ce91e/slide_6.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\f0e34f90-477e-49e3-974c-9bc0e99ce91e\\slide_6.wav"
      },
      {
        "slide_num": 7,
        "content": "Cảm ơnvì lắngnghe",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/f0e34f90-477e-49e3-974c-9bc0e99ce91e/slide_7.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\f0e34f90-477e-49e3-974c-9bc0e99ce91e\\slide_7.wav"
      }
    ],
    "created_at": "2026-02-01 20:27:30",
    "avatar_path": null,
    "final_video_path": null
  },
  "2499f1d0-3850-4f94-a938-dce37317c5da": {
    "id": "2499f1d0-3850-4f94-a938-dce37317c5da",
    "filename": "Open_Agri.pdf",
    "file_path": "static/uploads/presentations\\2499f1d0-3850-4f94-a938-dce37317c5da\\Open_Agri.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "Open Agri",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/2499f1d0-3850-4f94-a938-dce37317c5da/slide_1.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\2499f1d0-3850-4f94-a938-dce37317c5da\\slide_1.wav"
      },
      {
        "slide_num": 2,
        "content": "Về dự án của\nchúng tôi\nOpenAgri – Nền tảng hỗ trợ ra quyết định cho người nông dân.\nHiện nay, rất nhiều bà con nông dân vẫn phải dựa vào kinh nghiệm và… may mắn để quyết định: trồng cây gì, khi\nnào gieo, khi nào phun thuốc, khi nào thu hoạch.\nTrong khi đó, thời tiết thay đổi thất thường, sâu bệnh xuất hiện khó lường, giá nông sản lên xuống mỗi ngày. Nếu\nquyết định sai, bà con có thể mất mùa, lỗ vốn, thậm chí nợ nần.\nOpenAgri ra đời với mong muốn trở thành một người trợ lý thông minh cho người nông dân và nhà quản lý, giúp\ngiảm rủi ro, tăng năng suất và tăng thu nhập.\nThay vì phải tự đoán, bà con chỉ cần mở ứng dụng trên điện thoại là có thể:\nXem được tình trạng sức khỏe ruộng của mình qua màu sắc hiển thị trên bản đồ: vùng nào cây đang khỏe,\nvùng nào có dấu hiệu bất thường cần kiểm tra.\nNhận cảnh báo sớm về nguy cơ sâu bệnh tại khu vực của mình, dựa trên dữ liệu lịch sử và điều kiện thời tiết.\nXem thời tiết nông vụ trong 7 ngày tới để quyết định thời điểm gieo trồng, tưới nước, phun thuốc, thu hoạch\ncho phù hợp.\nTheo dõi giá cả một số loại nông sản hằng ngày, giúp lựa chọn thời điểm bán ra hợp lý hơn.\nQuản lý các thửa ruộng, diện tích, loại cây trồng, lịch sử canh tác ngay trên bản đồ, dễ dàng tra cứu và tổng\nhợp.\nVề phía cơ quan quản lý và hợp tác xã, OpenAgri hỗ trợ:\nNắm được bức tranh tổng thể vùng trồng, diện tích, cơ cấu cây trồng.\nTheo dõi tình hình sâu bệnh, năng suất dự kiến, từ đó đưa ra khuyến cáo phù hợp và kịp thời cho bà con.\nCó thêm dữ liệu để lập kế hoạch sản xuất, tiêu thụ, kết nối với doanh nghiệp thu mua.",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/2499f1d0-3850-4f94-a938-dce37317c5da/slide_2.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\2499f1d0-3850-4f94-a938-dce37317c5da\\slide_2.wav"
      },
      {
        "slide_num": 3,
        "content": "Dự báo thời tiết và\nđưa ra lời khuyên\ncho nông dân\nTrong sản xuất nông nghiệp, chỉ  cần lệch một trận mưa hay một đợt nắng nóng là bà con có thể\nmất trắng cả vụ. Nhưng thực tế, nhiều khi bà con không kịp xem dự báo thời tiết, hoặc bản tin\nchỉ nói chung chung cho cả tỉnh, không sát với ruộng của mình.\nVì vậy, trong ứng dụng OpenAg ri, chúng em xây dựng một mục thời tiết nông vụ riêng cho từng\nkhu ruộng.\nChỉ cần mở điện thoại, bà con sẽ thấy ngay:\nThời tiết hôm nay và 7 ngày tới tại đúng vị trí ruộng của mình: có mưa hay không, nhiệt độ,\nđộ ẩm, khả năng nắng nóng kéo dài…\nNhững cảnh báo ngắn gọn, dễ hiểu, ví dụ như:\n“2–3 ngày tới khả năng mưa lớn, nên hạn chế phun thuốc trừ sâu để tránh bị rửa trôi.”\n“Nắng nóng kéo dài, nên chú ý tưới bổ sung cho lúa/gia tăng che phủ cho rau màu.”\n“Trời âm u, ẩm độ cao, nguy c ơ một số bệnh lá phát triển mạ nh, nên kiểm tra đồng\nruộng thường xuyên hơn.”\nKhông chỉ dừng ở việc “báo thời tiết”, OpenAgri cố gắng dịch thông tin thời tiết thành lời\nkhuyên nông vụ cụ thể cho bà con: nên gieo khi nào, nên tránh phun thuốc vào lúc nào, đâu là\nthời điểm thuận lợi để thu hoạch để giảm rủi ro và tiết kiệm chi phí.\nNhờ đó, thay vì phải đoán “không biết mấy hôm nữa có mưa kh ông”, bà con có thêm một công\ncụ hỗ trợ ra quyết định, giúp chủ động hơn trong canh tác, bảo vệ sức khỏe cây trồng và nâng\ncao năng suất.",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/2499f1d0-3850-4f94-a938-dce37317c5da/slide_3.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\2499f1d0-3850-4f94-a938-dce37317c5da\\slide_3.wav"
      },
      {
        "slide_num": 4,
        "content": "b ả n  đ ồ  \nv ù n g  t r ồ n g\nN ế u  n h ư  p h ầ n  t h ờ i  t i ế t  v à  l ờ i  k h u y ê n  n ô n g  v ụ  g i ú p  b à  c o n  q u y ế t  đ ị n h  “ k h i  n à o\nl à m ” ,  t h ì  p h ầ n  b ả n  đ ồ  s ẽ  g i ú p  t r ả  l ờ i  c â u  h ỏ i  “ l à m  ở  đ â u ,  t r ê n  d i ệ n  t í c h  n à o ,  t ì n h\nt r ạ n g  r a  s a o ” .\nT r o n g  ứ n g  d ụ n g ,  m ỗ i  t h ử a  r u ộ n g ,  m ỗ i  v ù n g  t r ồ n g  s ẽ  đ ư ợ c  v ẽ  v à  l ư u  l ạ i  t r ê n  b ả n  đ ồ .\nB à  c o n  c ó  t h ể :\nP h ó n g  t o  n g a y  k h u  v ự c  c ủ a  m ì n h ,  k h o a n h  v ù n g  t h ử a  r u ộ n g ,  đ ặ t  t ê n ,  g h i  d i ệ n\nt í c h ,  l o ạ i  c â y  t r ồ n g .\nN h ì n  t r ê n  b ả n  đ ồ  s ẽ  t h ấ y  t o à n  b ộ  h ệ  t h ố n g  r u ộ n g  c ủ a  g i a  đ ì n h :  r u ộ n g  n à o  đ a n g\ng i e o ,  r u ộ n g  n à o  c h u ẩ n  b ị  t h u  h o ạ c h ,  r u ộ n g  n à o  c ó  c ả n h  b á o  s â u  b ệ n h  h o ặ c  t h ờ i\nt i ế t  b ấ t  l ợ i .\nK h i  r a  đ ồ n g ,  c h ỉ  c ầ n  m ở  đ i ệ n  t h o ạ i  l à  x á c  đ ị n h  đ ú n g  v ị  t r í  l ô  t h ử a ,  t r á n h  n h ầ m\nl ẫ n ,  r ấ t  t i ệ n  k h i  l à m  v i ệ c  v ớ i  h ợ p  t á c  x ã  h o ặ c  c á n  b ộ  k ỹ  t h u ậ t .\nV ớ i  h ợ p  t á c  x ã  v à  đ ị a  p h ư ơ n g ,  b ả n  đ ồ  g i ú p :\nN h ì n  t h ấ y  b ứ c  t r a n h  c h u n g  c ủ a  c ả  v ù n g :  d i ệ n  t í c h ,  c ơ  c ấ u  c â y  t r ồ n g ,  k h u  v ự c\nđ a n g  g ặ p  r ủ i  r o .\nD ễ  d à n g  l ậ p  k ế  h o ạ c h  h ỗ  t r ợ ,  p h â n  b ổ  v ậ t  t ư ,  l ê n  l ị c h  p h u n  p h ò n g ,  t h u  h o ạ c h  t ậ p\nt r u n g .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/2499f1d0-3850-4f94-a938-dce37317c5da/slide_4.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\2499f1d0-3850-4f94-a938-dce37317c5da\\slide_4.wav"
      },
      {
        "slide_num": 5,
        "content": "C h ẩ n  đ o á n  b ệ n h\nt r ê n  c â y  t r ồ n g\nT r o n g  t h ự c  t ế ,  k h ô n g  p h ả i  b à  c o n  n à o  c ũ n g  c ó  đ i ề u  k i ệ n  g ặ p  c á n  b ộ  k ỹ\nt h u ậ t  t h ư ờ n g  x u y ê n ,  n h i ề u  l o ạ i  b ệ n h  l á  n h ì n  k h á  g i ố n g  n h a u ,  n ế u  đ o á n\ns a i  v à  p h u n  n h ầ m  t h u ố c  t h ì  t ố n  t i ề n  m à  b ệ n h  v ẫ n  k h ô n g  k h ỏ i ,  t h ậ m  c h í\nc â y  c ò n  y ế u  h ơ n .\nV ớ i  O p e n A g r i ,  b à  c o n  c h ỉ  c ầ n  d ù n g  đ i ệ n  t h o ạ i  c h ụ p  l ạ i  h ì n h  c h i ế c  l á\nđ a n g  b ị  b ệ n h ,  s a u  đ ó  g ử i  l ê n  ứ n g  d ụ n g .  H ệ  t h ố n g  s ẽ  s o  s á n h  v ớ i  k h o\nh ì n h  ả n h  đ ã  đ ư ợ c  “ h ọ c ”  t r ư ớ c  đ ó ,  r ồ i  đ ư a  r a  g ợ i  ý :  l á  đ a n g  c ó  d ấ u  h i ệ u\ng i ố n g  v ớ i  m ộ t  s ố  l o ạ i  b ệ n h  n à o ,  t h ư ờ n g  g ặ p  t r ê n  l o ạ i  c â y  g ì ,  ở  g i a i  đ o ạ n\nn à o .\nT r ê n  m à n  h ì n h ,  b à  c o n  s ẽ  n h ậ n  đ ư ợ c  m ộ t  s ố  p h ư ơ n g  á n  b ệ n h  c ó  k h ả\nn ă n g  c a o ,  k è m  t h e o  m ô  t ả  t r i ệ u  c h ứ n g  d ễ  h i ể u  v à  g ợ i  ý  h ư ớ n g  x ử  l ý  c ơ\nb ả n  ( v í  d ụ :  n ê n  k i ể m  t r a  t h ê m  g ì ,  n ê n  h ỏ i  c á n  b ộ  k ỹ  t h u ậ t  v ề  l o ạ i  t h u ố c\nn à o ,  c ầ n  c h ú  ý  đ i ề u  k i ệ n  ẩ m  đ ộ ,  t h o á t  n ư ớ c … ) .\nM ụ c  t i ê u  c ủ a  t í n h  n ă n g  n à y  k h ô n g  p h ả i  l à  t h a y  t h ế  c h u y ê n  g i a ,  m à  l à\ng i ú p  b à  c o n  “ n g h i  n g ờ  đ ú n g  h ư ớ n g ”  s ớ m  h ơ n ,  t r á n h  đ ể  b ệ n h  l â y  l a n\nr ộ n g  m ớ i  p h á t  h i ệ n .  N h ờ  đ ó ,  b à  c o n  c ó  t h ể  t i ế t  k i ệ m  c h i  p h í  t h u ố c ,  g i ả m\ns ố  l ầ n  p h u n ,  b ả o  v ệ  s ứ c  k h ỏ e  c h o  m ì n h  v à  m ô i  t r ư ờ n g ,  đ ồ n g  t h ờ i  g i ữ\nđ ư ợ c  n ă n g  s u ấ t  v à  c h ấ t  l ư ợ n g  n ô n g  s ả n  t ố t  h ơ n .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/2499f1d0-3850-4f94-a938-dce37317c5da/slide_5.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\2499f1d0-3850-4f94-a938-dce37317c5da\\slide_5.wav"
      },
      {
        "slide_num": 6,
        "content": "D ự  b á o  r ủ i  r o\nT r o n g  s ả n  x u ấ t ,  đ i ề u  b à  c o n  l o  n h ấ t  k h ô n g  c h ỉ  l à  “ h i ệ n  t ạ i  đ a n g  b ị  g ì ”  m à  l à  “ s ắ p  t ớ i  c ó\nn g u y  c ơ  g ì  k h ô n g ” :  c ó  đ ợ t  s â u  b ệ n h  n à o  d ễ  b ù n g  l ê n ,  c ó  g i a i  đ o ạ n  t h ờ i  t i ế t  n à o  b ấ t  l ợ i\nc h o  c â y  t r ồ n g ,  c ó  n g u y  c ơ  m ấ t  m ù a  ở  k h u  v ự c  n à o …  N ế u  b i ế t  t r ư ớ c ,  b à  c o n  c ó  t h ể  c h ủ\nđ ộ n g  p h ò n g  h ơ n  l à  c h ữ a .\nT ừ  c á c  n g u ồ n  d ữ  l i ệ u  l ị c h  s ử  v ề  s â u  b ệ n h ,  t h ờ i  t i ế t  v à  v ù n g  t r ồ n g ,  h ệ  t h ố n g  s ẽ  t ổ n g\nh ợ p  l ạ i  t h à n h  n h ữ n g  c ả n h  b á o  r ủ i  r o  r ấ t  d ễ  h i ể u ,  v í  d ụ :\n“ T r o n g  7 – 1 0  n g à y  t ớ i ,  k h u  v ự c  n à y  c ó  n g u y  c ơ  c a o  x u ấ t  h i ệ n  s â u / b ệ n h  X  t r ê n  c â y\nt r ồ n g  Y . ”\n“ Đ ộ  ẩ m  c a o ,  m ư a  k é o  d à i ,  n g u y  c ơ  b ệ n h  l á  t ă n g ,  n ê n  k i ể m  t r a  đ ồ n g  r u ộ n g  t h ư ờ n g\nx u y ê n  h ơ n . ”\n“ T h ờ i  g i a n  n à y ,  n ế u  g i e o  t r ồ n g  m u ộ n ,  n g u y  c ơ  g ặ p  h ạ n  c u ố i  v ụ  s ẽ  c a o  h ơ n . ”\nT h a y  v ì  b ắ t  b à  c o n  đ ọ c  n h ữ n g  b á o  c á o  d à i  v à  p h ứ c  t ạ p ,  I C T U - O p e n A g r i  h i ể n  t h ị  m ứ c\nđ ộ  r ủ i  r o  t h e o  m à u  s ắ c ,  t h e o  k h u  v ự c ,  k è m  t h e o  l ờ i  k h u y ê n  c ụ  t h ể :  n ê n  t ă n g  c ư ờ n g\nt h ă m  đ ồ n g ,  n ê n  c h u ẩ n  b ị  p h ư ơ n g  á n  p h ò n g  t r ừ ,  h a y  n ê n  đ i ề u  c h ỉ n h  l ị c h  g i e o  t r ồ n g .\nN h ờ  v ậ y ,  n g ư ờ i  n ô n g  d â n  v à  h ợ p  t á c  x ã  k h ô n g  c ò n  b ị  đ ộ n g  c h ạ y  t h e o  t h ờ i  t i ế t  v à  s â u\nb ệ n h ,  m à  c ó  t h ê m  m ộ t  c ô n g  c ụ  d ự  b á o  s ớ m ,  g i ú p  g i ả m  t h i ệ t  h ạ i ,  t ố i  ư u  c h i  p h í  v à  ổ n\nđ ị n h  n ă n g  s u ấ t  c h o  c ả  v ụ .",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/2499f1d0-3850-4f94-a938-dce37317c5da/slide_6.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\2499f1d0-3850-4f94-a938-dce37317c5da\\slide_6.wav"
      },
      {
        "slide_num": 7,
        "content": "Cảm ơnvì lắngnghe",
        "notes": "",
        "total_slides": 7,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/2499f1d0-3850-4f94-a938-dce37317c5da/slide_7.wav",
        "audio_file_path": "D:\\CreateVideo-Website\\app\\../static\\audio\\2499f1d0-3850-4f94-a938-dce37317c5da\\slide_7.wav"
      }
    ],
    "created_at": "2026-02-01 20:32:21",
    "avatar_path": null,
    "final_video_path": null
  }
}