{
  "70849fb9-49fa-41d8-a4ff-d66d03529fde": {
    "id": "70849fb9-49fa-41d8-a4ff-d66d03529fde",
    "filename": "Maui_Xaml_Binding_Lab_Handout.pdf",
    "file_path": "static/uploads/presentations\\70849fb9-49fa-41d8-a4ff-d66d03529fde\\Maui_Xaml_Binding_Lab_Handout.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "LAB HANDOUT \nMAUI XAML Binding Practice with CommunityToolkit.Mvvm \n \nCourse / Module \nMobile Application Development (.NET MAUI) \nLab Title \nTask Manager – XAML Data Binding & MVVM Toolkit \nDuration \n3 hours (180 minutes) \nLab Type \nIndividual – Hands-on Practice \n \n1. Lab Objectives \nAfter completing this lab, students will be able to: \n• Explain the purpose of data binding in .NET MAUI \n• Apply MVVM pattern using CommunityToolkit.Mvvm \n• Correctly use common binding modes in XAML \n• Bind UI elements to ViewModel properties and commands \n• Use converters and MultiBinding in real UI scenarios \n \n2. Software & Tools \n• Visual Studio 2022 or later \n• .NET MAUI workload installed \n• NuGet package: \no CommunityToolkit.Mvvm",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "3. Problem Description \nYou are required to build a single-screen Task Manager application using .NET MAUI \n(XAML). \nThe application allows users to: - Enter a task name - Add the task to a list - Mark tasks as \ncompleted - View task statistics (total and completed) \n    Constraints - No navigation between pages - No database or API - No code-\nbehind logic for UI behavior - All interactions must be implemented using data \nbinding and commands \n \n4. User Interface Specification \nMain Screen Components \n1. Application title: MY TASKS \n2. Text input for new task \n3. Add button \n4. Task list (CollectionView) \n5. Checkbox for task completion \n6. Summary section displaying: \no Total tasks \no Completed tasks \n \n5. Required Binding Types \nYour solution must demonstrate the following bindings: \nNo Binding Type Required Usage \n1 OneWay Display task title \n2 TwoWay Entry ↔ ViewModel property \n3 OneWayToSource Selected task \n4 Command Add task action \n5 RelativeSource Access ViewModel from item template \n6 x:Reference UI-to-UI binding \n7 Converter Completed task text style \n8 MultiBinding Summary text \n9 ObservableCollection Auto-update task list \n10 INotifyPropertyChanged ViewModel updates",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "6. Data Model \nCreate a TaskItem model that contains: \n• Title (string) \n• IsCompleted (bool) \nThe model must inherit from ObservableObject. \n \n7. ViewModel Requirements \nCreate TasksViewModel with the following: \nProperties \n• NewTaskTitle (string) \n• Tasks (ObservableCollection) \n• SelectedTask (TaskItem) \n• TotalCount (int) \n• CompletedCount (int) \nCommands \n• AddTaskCommand \nUse [ObservableProperty] and [RelayCommand] attributes where applicable. \n \n8. XAML Requirements \n• Bind Entry.Text using TwoWay binding \n• Bind Button.Command to ViewModel command \n• Use CollectionView for task list \n• Bind CheckBox.IsChecked using TwoWay binding \n• Use a Value Converter to apply strikethrough to completed tasks \n• Use MultiBinding for summary text \n• Use x:Reference at least once \n \n9. Suggested Lab Steps \n1. Create a new .NET MAUI project",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "2. Install CommunityToolkit.Mvvm \n3. Create the model class \n4. Create the ViewModel \n5. Design the UI in XAML \n6. Apply required bindings \n7. Test UI behavior \n \n10. Assessment Rubric (10 Marks) \nCriteria Marks \nCorrect MVVM structure 2 \nProper use of binding modes 3 \nCommand implementation 2 \nConverter & MultiBinding 2 \nUI completeness & clarity 1 \n \n11. Submission Requirements \nStudents must submit: \n• Source code folder or Git repository \n• Screenshot of running application \n \n12. Notes \n• Code-behind should be minimal or empty \n• Focus on binding correctness, not UI aesthetics \n• Naming conventions and clean structure are required \n \nEnd of Lab",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-24 14:38:59",
    "avatar_path": null,
    "final_video_path": null
  },
  "a972a9ff-29c4-42e0-8b3e-d4bc4f54e3a4": {
    "id": "a972a9ff-29c4-42e0-8b3e-d4bc4f54e3a4",
    "filename": "Maui_Xaml_Binding_Lab_Handout.pdf",
    "file_path": "static/uploads/presentations\\a972a9ff-29c4-42e0-8b3e-d4bc4f54e3a4\\Maui_Xaml_Binding_Lab_Handout.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "LAB HANDOUT \nMAUI XAML Binding Practice with CommunityToolkit.Mvvm \n \nCourse / Module \nMobile Application Development (.NET MAUI) \nLab Title \nTask Manager – XAML Data Binding & MVVM Toolkit \nDuration \n3 hours (180 minutes) \nLab Type \nIndividual – Hands-on Practice \n \n1. Lab Objectives \nAfter completing this lab, students will be able to: \n• Explain the purpose of data binding in .NET MAUI \n• Apply MVVM pattern using CommunityToolkit.Mvvm \n• Correctly use common binding modes in XAML \n• Bind UI elements to ViewModel properties and commands \n• Use converters and MultiBinding in real UI scenarios \n \n2. Software & Tools \n• Visual Studio 2022 or later \n• .NET MAUI workload installed \n• NuGet package: \no CommunityToolkit.Mvvm",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "3. Problem Description \nYou are required to build a single-screen Task Manager application using .NET MAUI \n(XAML). \nThe application allows users to: - Enter a task name - Add the task to a list - Mark tasks as \ncompleted - View task statistics (total and completed) \n    Constraints - No navigation between pages - No database or API - No code-\nbehind logic for UI behavior - All interactions must be implemented using data \nbinding and commands \n \n4. User Interface Specification \nMain Screen Components \n1. Application title: MY TASKS \n2. Text input for new task \n3. Add button \n4. Task list (CollectionView) \n5. Checkbox for task completion \n6. Summary section displaying: \no Total tasks \no Completed tasks \n \n5. Required Binding Types \nYour solution must demonstrate the following bindings: \nNo Binding Type Required Usage \n1 OneWay Display task title \n2 TwoWay Entry ↔ ViewModel property \n3 OneWayToSource Selected task \n4 Command Add task action \n5 RelativeSource Access ViewModel from item template \n6 x:Reference UI-to-UI binding \n7 Converter Completed task text style \n8 MultiBinding Summary text \n9 ObservableCollection Auto-update task list \n10 INotifyPropertyChanged ViewModel updates",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "6. Data Model \nCreate a TaskItem model that contains: \n• Title (string) \n• IsCompleted (bool) \nThe model must inherit from ObservableObject. \n \n7. ViewModel Requirements \nCreate TasksViewModel with the following: \nProperties \n• NewTaskTitle (string) \n• Tasks (ObservableCollection) \n• SelectedTask (TaskItem) \n• TotalCount (int) \n• CompletedCount (int) \nCommands \n• AddTaskCommand \nUse [ObservableProperty] and [RelayCommand] attributes where applicable. \n \n8. XAML Requirements \n• Bind Entry.Text using TwoWay binding \n• Bind Button.Command to ViewModel command \n• Use CollectionView for task list \n• Bind CheckBox.IsChecked using TwoWay binding \n• Use a Value Converter to apply strikethrough to completed tasks \n• Use MultiBinding for summary text \n• Use x:Reference at least once \n \n9. Suggested Lab Steps \n1. Create a new .NET MAUI project",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "2. Install CommunityToolkit.Mvvm \n3. Create the model class \n4. Create the ViewModel \n5. Design the UI in XAML \n6. Apply required bindings \n7. Test UI behavior \n \n10. Assessment Rubric (10 Marks) \nCriteria Marks \nCorrect MVVM structure 2 \nProper use of binding modes 3 \nCommand implementation 2 \nConverter & MultiBinding 2 \nUI completeness & clarity 1 \n \n11. Submission Requirements \nStudents must submit: \n• Source code folder or Git repository \n• Screenshot of running application \n \n12. Notes \n• Code-behind should be minimal or empty \n• Focus on binding correctness, not UI aesthetics \n• Naming conventions and clean structure are required \n \nEnd of Lab",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-24 14:39:22",
    "avatar_path": null,
    "final_video_path": null
  },
  "59d41985-84f2-4769-bd06-53ab2395ebf9": {
    "id": "59d41985-84f2-4769-bd06-53ab2395ebf9",
    "filename": "Maui_Xaml_Binding_Lab_Handout.pdf",
    "file_path": "static/uploads/presentations\\59d41985-84f2-4769-bd06-53ab2395ebf9\\Maui_Xaml_Binding_Lab_Handout.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "LAB HANDOUT \nMAUI XAML Binding Practice with CommunityToolkit.Mvvm \n \nCourse / Module \nMobile Application Development (.NET MAUI) \nLab Title \nTask Manager – XAML Data Binding & MVVM Toolkit \nDuration \n3 hours (180 minutes) \nLab Type \nIndividual – Hands-on Practice \n \n1. Lab Objectives \nAfter completing this lab, students will be able to: \n• Explain the purpose of data binding in .NET MAUI \n• Apply MVVM pattern using CommunityToolkit.Mvvm \n• Correctly use common binding modes in XAML \n• Bind UI elements to ViewModel properties and commands \n• Use converters and MultiBinding in real UI scenarios \n \n2. Software & Tools \n• Visual Studio 2022 or later \n• .NET MAUI workload installed \n• NuGet package: \no CommunityToolkit.Mvvm",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "3. Problem Description \nYou are required to build a single-screen Task Manager application using .NET MAUI \n(XAML). \nThe application allows users to: - Enter a task name - Add the task to a list - Mark tasks as \ncompleted - View task statistics (total and completed) \n    Constraints - No navigation between pages - No database or API - No code-\nbehind logic for UI behavior - All interactions must be implemented using data \nbinding and commands \n \n4. User Interface Specification \nMain Screen Components \n1. Application title: MY TASKS \n2. Text input for new task \n3. Add button \n4. Task list (CollectionView) \n5. Checkbox for task completion \n6. Summary section displaying: \no Total tasks \no Completed tasks \n \n5. Required Binding Types \nYour solution must demonstrate the following bindings: \nNo Binding Type Required Usage \n1 OneWay Display task title \n2 TwoWay Entry ↔ ViewModel property \n3 OneWayToSource Selected task \n4 Command Add task action \n5 RelativeSource Access ViewModel from item template \n6 x:Reference UI-to-UI binding \n7 Converter Completed task text style \n8 MultiBinding Summary text \n9 ObservableCollection Auto-update task list \n10 INotifyPropertyChanged ViewModel updates",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "6. Data Model \nCreate a TaskItem model that contains: \n• Title (string) \n• IsCompleted (bool) \nThe model must inherit from ObservableObject. \n \n7. ViewModel Requirements \nCreate TasksViewModel with the following: \nProperties \n• NewTaskTitle (string) \n• Tasks (ObservableCollection) \n• SelectedTask (TaskItem) \n• TotalCount (int) \n• CompletedCount (int) \nCommands \n• AddTaskCommand \nUse [ObservableProperty] and [RelayCommand] attributes where applicable. \n \n8. XAML Requirements \n• Bind Entry.Text using TwoWay binding \n• Bind Button.Command to ViewModel command \n• Use CollectionView for task list \n• Bind CheckBox.IsChecked using TwoWay binding \n• Use a Value Converter to apply strikethrough to completed tasks \n• Use MultiBinding for summary text \n• Use x:Reference at least once \n \n9. Suggested Lab Steps \n1. Create a new .NET MAUI project",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "2. Install CommunityToolkit.Mvvm \n3. Create the model class \n4. Create the ViewModel \n5. Design the UI in XAML \n6. Apply required bindings \n7. Test UI behavior \n \n10. Assessment Rubric (10 Marks) \nCriteria Marks \nCorrect MVVM structure 2 \nProper use of binding modes 3 \nCommand implementation 2 \nConverter & MultiBinding 2 \nUI completeness & clarity 1 \n \n11. Submission Requirements \nStudents must submit: \n• Source code folder or Git repository \n• Screenshot of running application \n \n12. Notes \n• Code-behind should be minimal or empty \n• Focus on binding correctness, not UI aesthetics \n• Naming conventions and clean structure are required \n \nEnd of Lab",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-24 15:03:57",
    "avatar_path": null,
    "final_video_path": null
  },
  "c98460a9-7aa0-4c5e-837a-5286874379ad": {
    "id": "c98460a9-7aa0-4c5e-837a-5286874379ad",
    "filename": "Maui_Xaml_Binding_Lab_Handout.pdf",
    "file_path": "static/uploads/presentations\\c98460a9-7aa0-4c5e-837a-5286874379ad\\Maui_Xaml_Binding_Lab_Handout.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "LAB HANDOUT \nMAUI XAML Binding Practice with CommunityToolkit.Mvvm \n \nCourse / Module \nMobile Application Development (.NET MAUI) \nLab Title \nTask Manager – XAML Data Binding & MVVM Toolkit \nDuration \n3 hours (180 minutes) \nLab Type \nIndividual – Hands-on Practice \n \n1. Lab Objectives \nAfter completing this lab, students will be able to: \n• Explain the purpose of data binding in .NET MAUI \n• Apply MVVM pattern using CommunityToolkit.Mvvm \n• Correctly use common binding modes in XAML \n• Bind UI elements to ViewModel properties and commands \n• Use converters and MultiBinding in real UI scenarios \n \n2. Software & Tools \n• Visual Studio 2022 or later \n• .NET MAUI workload installed \n• NuGet package: \no CommunityToolkit.Mvvm",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Chào mừng các bạn đến với buổi thực hành hôm nay! Trong khuôn khổ môn Phát triển Ứng dụng Di động với .NET MAUI, chúng ta sẽ đi sâu vào một phần cực kỳ quan trọng và thiết yếu khi xây dựng các ứng dụng di động hiện đại: đó là Data Binding và mô hình MVVM.\n\nBuổi lab của chúng ta có tên là \"Task Manager – XAML Data Binding & MVVM Toolkit\". Đúng như tên gọi, chúng ta sẽ cùng nhau xây dựng một ứng dụng quản lý tác vụ cơ bản, nơi mà mọi logic và dữ liệu đều được quản lý một cách hiệu quả thông qua các kỹ thuật binding và kiến trúc MVVM. Đây là một buổi thực hành cá nhân kéo dài 3 tiếng, tập trung hoàn toàn vào thực hành trực tiếp, giúp các bạn có cái nhìn sâu sắc và kỹ năng thực tiễn.\n\nVậy sau 3 giờ thực hành này, chúng ta sẽ đạt được những gì?\n\nĐầu tiên, các bạn sẽ hiểu rõ **mục đích thực sự của Data Binding** trong .NET MAUI. Tại sao chúng ta cần nó? Nó giúp tách biệt UI và logic, làm cho code của chúng ta sạch hơn, dễ bảo trì hơn, và quan trọng nhất là tạo ra các ứng dụng phản hồi mượt mà hơn với dữ liệu.\n\nTiếp theo, chúng ta sẽ áp dụng **mô hình MVVM** – Model-View-ViewModel – một kiến trúc đã quá quen thuộc và hiệu quả trong phát triển ứng dụng UI. Đặc biệt, chúng ta sẽ sử dụng **CommunityToolkit.Mvvm**. Đây là một thư viện NuGet rất mạnh mẽ, giúp chúng ta triển khai MVVM một cách dễ dàng và hiệu quả hơn rất nhiều, giảm bớt boilerplate code.\n\nCác bạn cũng sẽ học cách sử dụng các **chế độ binding phổ biến trong XAML** một cách chính xác, từ OneWay, TwoWay cho đến OneTime. Chúng ta sẽ thực hành liên kết các phần tử UI như TextBox, Button với các thuộc tính và lệnh (Commands) trong ViewModel.\n\nVà để làm cho ứng dụng của chúng ta linh hoạt hơn, chúng ta sẽ khám phá cách dùng các **converters** để biến đổi dữ liệu, hoặc sử dụng **MultiBinding** để kết hợp nhiều nguồn dữ liệu khác nhau vào một UI element duy nhất. Tất cả đều là những tình huống thực tế mà bạn sẽ gặp trong quá trình phát triển ứng dụng.\n\nVề mặt công cụ, để buổi lab diễn ra suôn sẻ, các bạn chỉ cần đảm bảo máy tính của mình đã cài đặt Visual Studio 2022 trở lên, có workload .NET MAUI và đã thêm gói NuGet CommunityToolkit.Mvvm vào project của mình.\n\nHy vọng với buổi thực hành này, các bạn sẽ không chỉ nắm vững lý thuyết mà còn có thể tự tin áp dụng Data Binding và MVVM vào các dự án MAUI của mình. Đây là những kỹ năng nền tảng cực kỳ giá trị để xây dựng các ứng dụng di động hiện đại. Bây giờ, chúng ta hãy cùng bắt đầu nhé!",
        "edited_text": "Chào mừng các bạn đến với buổi thực hành hôm nay! Trong khuôn khổ môn Phát triển Ứng dụng Di động với .NET MAUI, chúng ta sẽ đi sâu vào một phần cực kỳ quan trọng và thiết yếu khi xây dựng các ứng dụng di động hiện đại: đó là Data Binding và mô hình MVVM.\n\nBuổi lab của chúng ta có tên là \"Task Manager – XAML Data Binding & MVVM Toolkit\". Đúng như tên gọi, chúng ta sẽ cùng nhau xây dựng một ứng dụng quản lý tác vụ cơ bản, nơi mà mọi logic và dữ liệu đều được quản lý một cách hiệu quả thông qua các kỹ thuật binding và kiến trúc MVVM. Đây là một buổi thực hành cá nhân kéo dài 3 tiếng, tập trung hoàn toàn vào thực hành trực tiếp, giúp các bạn có cái nhìn sâu sắc và kỹ năng thực tiễn.\n\nVậy sau 3 giờ thực hành này, chúng ta sẽ đạt được những gì?\n\nĐầu tiên, các bạn sẽ hiểu rõ **mục đích thực sự của Data Binding** trong .NET MAUI. Tại sao chúng ta cần nó? Nó giúp tách biệt UI và logic, làm cho code của chúng ta sạch hơn, dễ bảo trì hơn, và quan trọng nhất là tạo ra các ứng dụng phản hồi mượt mà hơn với dữ liệu.\n\nTiếp theo, chúng ta sẽ áp dụng **mô hình MVVM** – Model-View-ViewModel – một kiến trúc đã quá quen thuộc và hiệu quả trong phát triển ứng dụng UI. Đặc biệt, chúng ta sẽ sử dụng **CommunityToolkit.Mvvm**. Đây là một thư viện NuGet rất mạnh mẽ, giúp chúng ta triển khai MVVM một cách dễ dàng và hiệu quả hơn rất nhiều, giảm bớt boilerplate code.\n\nCác bạn cũng sẽ học cách sử dụng các **chế độ binding phổ biến trong XAML** một cách chính xác, từ OneWay, TwoWay cho đến OneTime. Chúng ta sẽ thực hành liên kết các phần tử UI như TextBox, Button với các thuộc tính và lệnh (Commands) trong ViewModel.\n\nVà để làm cho ứng dụng của chúng ta linh hoạt hơn, chúng ta sẽ khám phá cách dùng các **converters** để biến đổi dữ liệu, hoặc sử dụng **MultiBinding** để kết hợp nhiều nguồn dữ liệu khác nhau vào một UI element duy nhất. Tất cả đều là những tình huống thực tế mà bạn sẽ gặp trong quá trình phát triển ứng dụng.\n\nVề mặt công cụ, để buổi lab diễn ra suôn sẻ, các bạn chỉ cần đảm bảo máy tính của mình đã cài đặt Visual Studio 2022 trở lên, có workload .NET MAUI và đã thêm gói NuGet CommunityToolkit.Mvvm vào project của mình.\n\nHy vọng với buổi thực hành này, các bạn sẽ không chỉ nắm vững lý thuyết mà còn có thể tự tin áp dụng Data Binding và MVVM vào các dự án MAUI của mình. Đây là những kỹ năng nền tảng cực kỳ giá trị để xây dựng các ứng dụng di động hiện đại. Bây giờ, chúng ta hãy cùng bắt đầu nhé!",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "3. Problem Description \nYou are required to build a single-screen Task Manager application using .NET MAUI \n(XAML). \nThe application allows users to: - Enter a task name - Add the task to a list - Mark tasks as \ncompleted - View task statistics (total and completed) \n    Constraints - No navigation between pages - No database or API - No code-\nbehind logic for UI behavior - All interactions must be implemented using data \nbinding and commands \n \n4. User Interface Specification \nMain Screen Components \n1. Application title: MY TASKS \n2. Text input for new task \n3. Add button \n4. Task list (CollectionView) \n5. Checkbox for task completion \n6. Summary section displaying: \no Total tasks \no Completed tasks \n \n5. Required Binding Types \nYour solution must demonstrate the following bindings: \nNo Binding Type Required Usage \n1 OneWay Display task title \n2 TwoWay Entry ↔ ViewModel property \n3 OneWayToSource Selected task \n4 Command Add task action \n5 RelativeSource Access ViewModel from item template \n6 x:Reference UI-to-UI binding \n7 Converter Completed task text style \n8 MultiBinding Summary text \n9 ObservableCollection Auto-update task list \n10 INotifyPropertyChanged ViewModel updates",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Chào mọi người, hôm nay chúng ta sẽ cùng tìm hiểu về một dự án thú vị: xây dựng ứng dụng quản lý tác vụ (Task Manager) sử dụng .NET MAUI.\n\nMục tiêu của chúng ta là tạo ra một ứng dụng chỉ trên một màn hình duy nhất, nơi người dùng có thể thực hiện mọi thao tác quản lý công việc của mình. Cụ thể, người dùng có thể dễ dàng nhập tên một công việc mới, thêm nó vào danh sách, đánh dấu khi công việc đó hoàn thành, và theo dõi các số liệu thống kê cơ bản như tổng số công việc và số công việc đã hoàn thành.\n\nTuy nhiên, điểm thú vị và cũng là thử thách lớn nhất nằm ở các ràng buộc của dự án này. Đầu tiên, như đã nói, chúng ta không có chuyển trang, mọi thứ diễn ra trên một màn hình. Thứ hai, không sử dụng database hay API bên ngoài – tất cả dữ liệu sẽ được xử lý trong bộ nhớ của ứng dụng. Và quan trọng nhất, để đảm bảo tính minh bạch và dễ bảo trì, chúng ta *không được phép* viết bất kỳ logic xử lý UI nào trong phần code-behind của XAML. Thay vào đó, tất cả các tương tác người dùng phải được triển khai thông qua cơ chế data binding và commands.\n\nĐể đáp ứng các yêu cầu này, giao diện người dùng của chúng ta được thiết kế rất trực quan và đơn giản. Màn hình chính sẽ có tiêu đề rõ ràng là \"MY TASKS\". Phía trên cùng là một ô nhập liệu để người dùng gõ tên công việc mới, và ngay bên cạnh là nút \"Thêm\" để đưa công việc đó vào danh sách. Phần trung tâm sẽ là danh sách các công việc, hiển thị dưới dạng CollectionView. Mỗi công việc trong danh sách sẽ đi kèm một checkbox để người dùng dễ dàng đánh dấu hoàn thành. Cuối cùng, ở phần dưới cùng của màn hình, chúng ta sẽ có một khu vực tóm tắt, hiển thị tổng số công việc và số lượng công việc đã hoàn thành, giúp người dùng nắm bắt tình hình chung một cách nhanh chóng.\n\nĐể hiện thực hóa tất cả các tương tác này mà không cần dùng code-behind, chúng ta sẽ tận dụng triệt để các kiểu Data Binding khác nhau trong .NET MAUI. Ví dụ, kiểu `OneWay` sẽ giúp hiển thị tiêu đề công việc một chiều từ ViewModel ra UI. Kiểu `TwoWay` sẽ cực kỳ hữu ích cho ô nhập liệu, đảm bảo dữ liệu luôn được đồng bộ hai chiều giữa giao diện và ViewModel. Các nút bấm như \"Thêm\" sẽ được xử lý bằng `Command` binding, giúp tách rời logic hành động khỏi UI.\n\nTrong danh sách công việc, chúng ta sẽ cần đến `RelativeSource` để truy cập ViewModel từ bên trong item template, hoặc `x:Reference` để liên kết các thành phần UI với nhau trực tiếp. Để làm cho phần tóm tắt trở nên sống động, chúng ta sẽ dùng `MultiBinding` để kết hợp nhiều giá trị thành một chuỗi hiển thị duy nhất, và `Converter` để thay đổi phong cách hiển thị của văn bản, ví dụ như gạch ngang những công việc đã hoàn thành. Cuối cùng, để danh sách công việc tự động cập nhật mỗi khi có thay đổi, chúng ta sẽ sử dụng `ObservableCollection`, và ViewModel của chúng ta sẽ triển khai interface `INotifyPropertyChanged` để thông báo cho UI biết khi có bất kỳ thuộc tính nào thay đổi.\n\nTóm lại, mặc dù chỉ là một ứng dụng đơn màn hình, dự án này yêu cầu chúng ta phải có sự hiểu biết sâu sắc về các cơ chế Data Binding và MVVM trong .NET MAUI để xây dựng một giải pháp sạch sẽ, hiệu quả và dễ bảo trì.",
        "edited_text": "Chào mọi người, hôm nay chúng ta sẽ cùng tìm hiểu về một dự án thú vị: xây dựng ứng dụng quản lý tác vụ (Task Manager) sử dụng .NET MAUI.\n\nMục tiêu của chúng ta là tạo ra một ứng dụng chỉ trên một màn hình duy nhất, nơi người dùng có thể thực hiện mọi thao tác quản lý công việc của mình. Cụ thể, người dùng có thể dễ dàng nhập tên một công việc mới, thêm nó vào danh sách, đánh dấu khi công việc đó hoàn thành, và theo dõi các số liệu thống kê cơ bản như tổng số công việc và số công việc đã hoàn thành.\n\nTuy nhiên, điểm thú vị và cũng là thử thách lớn nhất nằm ở các ràng buộc của dự án này. Đầu tiên, như đã nói, chúng ta không có chuyển trang, mọi thứ diễn ra trên một màn hình. Thứ hai, không sử dụng database hay API bên ngoài – tất cả dữ liệu sẽ được xử lý trong bộ nhớ của ứng dụng. Và quan trọng nhất, để đảm bảo tính minh bạch và dễ bảo trì, chúng ta *không được phép* viết bất kỳ logic xử lý UI nào trong phần code-behind của XAML. Thay vào đó, tất cả các tương tác người dùng phải được triển khai thông qua cơ chế data binding và commands.\n\nĐể đáp ứng các yêu cầu này, giao diện người dùng của chúng ta được thiết kế rất trực quan và đơn giản. Màn hình chính sẽ có tiêu đề rõ ràng là \"MY TASKS\". Phía trên cùng là một ô nhập liệu để người dùng gõ tên công việc mới, và ngay bên cạnh là nút \"Thêm\" để đưa công việc đó vào danh sách. Phần trung tâm sẽ là danh sách các công việc, hiển thị dưới dạng CollectionView. Mỗi công việc trong danh sách sẽ đi kèm một checkbox để người dùng dễ dàng đánh dấu hoàn thành. Cuối cùng, ở phần dưới cùng của màn hình, chúng ta sẽ có một khu vực tóm tắt, hiển thị tổng số công việc và số lượng công việc đã hoàn thành, giúp người dùng nắm bắt tình hình chung một cách nhanh chóng.\n\nĐể hiện thực hóa tất cả các tương tác này mà không cần dùng code-behind, chúng ta sẽ tận dụng triệt để các kiểu Data Binding khác nhau trong .NET MAUI. Ví dụ, kiểu `OneWay` sẽ giúp hiển thị tiêu đề công việc một chiều từ ViewModel ra UI. Kiểu `TwoWay` sẽ cực kỳ hữu ích cho ô nhập liệu, đảm bảo dữ liệu luôn được đồng bộ hai chiều giữa giao diện và ViewModel. Các nút bấm như \"Thêm\" sẽ được xử lý bằng `Command` binding, giúp tách rời logic hành động khỏi UI.\n\nTrong danh sách công việc, chúng ta sẽ cần đến `RelativeSource` để truy cập ViewModel từ bên trong item template, hoặc `x:Reference` để liên kết các thành phần UI với nhau trực tiếp. Để làm cho phần tóm tắt trở nên sống động, chúng ta sẽ dùng `MultiBinding` để kết hợp nhiều giá trị thành một chuỗi hiển thị duy nhất, và `Converter` để thay đổi phong cách hiển thị của văn bản, ví dụ như gạch ngang những công việc đã hoàn thành. Cuối cùng, để danh sách công việc tự động cập nhật mỗi khi có thay đổi, chúng ta sẽ sử dụng `ObservableCollection`, và ViewModel của chúng ta sẽ triển khai interface `INotifyPropertyChanged` để thông báo cho UI biết khi có bất kỳ thuộc tính nào thay đổi.\n\nTóm lại, mặc dù chỉ là một ứng dụng đơn màn hình, dự án này yêu cầu chúng ta phải có sự hiểu biết sâu sắc về các cơ chế Data Binding và MVVM trong .NET MAUI để xây dựng một giải pháp sạch sẽ, hiệu quả và dễ bảo trì.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "6. Data Model \nCreate a TaskItem model that contains: \n• Title (string) \n• IsCompleted (bool) \nThe model must inherit from ObservableObject. \n \n7. ViewModel Requirements \nCreate TasksViewModel with the following: \nProperties \n• NewTaskTitle (string) \n• Tasks (ObservableCollection) \n• SelectedTask (TaskItem) \n• TotalCount (int) \n• CompletedCount (int) \nCommands \n• AddTaskCommand \nUse [ObservableProperty] and [RelayCommand] attributes where applicable. \n \n8. XAML Requirements \n• Bind Entry.Text using TwoWay binding \n• Bind Button.Command to ViewModel command \n• Use CollectionView for task list \n• Bind CheckBox.IsChecked using TwoWay binding \n• Use a Value Converter to apply strikethrough to completed tasks \n• Use MultiBinding for summary text \n• Use x:Reference at least once \n \n9. Suggested Lab Steps \n1. Create a new .NET MAUI project",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Chào mừng quý vị và các bạn,\n\nVâng, tiếp theo đây, chúng ta sẽ đi sâu hơn vào các yêu cầu kỹ thuật để xây dựng ứng dụng quản lý công việc của mình nhé. Đây là những khối cấu trúc quan trọng sẽ định hình cách ứng dụng của chúng ta hoạt động và tương tác.\n\nĐầu tiên là phần **Data Model**, hay còn gọi là mô hình dữ liệu. Chúng ta sẽ tạo một mô hình đơn giản tên là `TaskItem` để đại diện cho một công việc. Mỗi `TaskItem` sẽ có hai thuộc tính chính: `Title` – là một chuỗi để lưu tên công việc, và `IsCompleted` – một kiểu boolean để biết công việc đã hoàn thành hay chưa. Điều quan trọng ở đây là mô hình này phải kế thừa từ `ObservableObject`. Tại sao lại vậy? Bởi vì khi trạng thái của một công việc thay đổi – ví dụ, bạn đánh dấu nó là hoàn thành – thì giao diện người dùng cần phải tự động cập nhật mà không cần chúng ta phải viết quá nhiều code thủ công. `ObservableObject` chính là công cụ giúp chúng ta làm điều đó một cách hiệu quả.\n\nTiếp theo là trái tim của ứng dụng: **ViewModel** của chúng ta, cụ thể là `TasksViewModel`. ViewModel này sẽ chứa các thuộc tính để quản lý dữ liệu và trạng thái của giao diện. Chúng ta sẽ có `NewTaskTitle` để nhận đầu vào từ người dùng khi họ muốn thêm công việc mới. Một `ObservableCollection` tên là `Tasks` sẽ lưu trữ danh sách các công việc. `ObservableCollection` rất quan trọng vì nó sẽ tự động thông báo cho UI biết mỗi khi có công việc mới được thêm vào, xóa đi, hoặc thay đổi vị trí. Ngoài ra, chúng ta còn có `SelectedTask` để theo dõi công việc đang được chọn, và hai thuộc tính `TotalCount`, `CompletedCount` để hiển thị tóm tắt tổng số công việc và số công việc đã hoàn thành. Về các **Commands** (lệnh), chúng ta sẽ có `AddTaskCommand` để xử lý logic khi người dùng bấm nút thêm công việc. Để đơn giản hóa việc viết code MVVM, chúng ta sẽ tận dụng các thuộc tính `[ObservableProperty]` và `[RelayCommand]` từ MAUI Community Toolkit. Chúng giúp giảm bớt lượng code 'lặp lại' mà vẫn đảm bảo tính năng thông báo thay đổi và thực thi lệnh một cách hiệu quả.\n\nBây giờ đến phần giao diện, hay còn gọi là **XAML Requirements**. Đây là nơi chúng ta kết nối UI với ViewModel. Chúng ta sẽ sử dụng TwoWay binding cho `Entry.Text` để đảm bảo dữ liệu nhập vào từ ô văn bản có thể đi vào ViewModel và ngược lại. Tương tự, `CheckBox.IsChecked` cũng sẽ dùng TwoWay binding để cập nhật trạng thái hoàn thành của công việc. Để hiển thị danh sách công việc, chúng ta sẽ dùng `CollectionView`, một control hiện đại và mạnh mẽ hơn ListView truyền thống. Một điểm nhấn thú vị là chúng ta sẽ dùng một **Value Converter** để tạo hiệu ứng gạch ngang cho các công việc đã hoàn thành, giúp người dùng dễ dàng nhận biết. Và để hiển thị văn bản tóm tắt như \"Tổng số: X, Đã hoàn thành: Y\", chúng ta sẽ cần đến **MultiBinding** để kết hợp nhiều thuộc tính từ ViewModel vào một chuỗi văn bản duy nhất. Cuối cùng, chúng ta cũng sẽ áp dụng `x:Reference` ít nhất một lần để thực hành việc tham chiếu giữa các control trong XAML.\n\nTất nhiên, để bắt đầu tất cả những điều này, bước đầu tiên rất đơn giản: chỉ cần **tạo một dự án .NET MAUI mới**. Đó là nền tảng để chúng ta bắt đầu xây dựng mọi thứ.\n\nĐó là tổng quan về các yêu cầu chính cho mô hình dữ liệu, ViewModel và giao diện người dùng. Khi kết hợp các yếu tố này lại, chúng ta sẽ có một ứng dụng quản lý công việc hoạt động mượt mà và hiệu quả.",
        "edited_text": "Chào mừng quý vị và các bạn,\n\nVâng, tiếp theo đây, chúng ta sẽ đi sâu hơn vào các yêu cầu kỹ thuật để xây dựng ứng dụng quản lý công việc của mình nhé. Đây là những khối cấu trúc quan trọng sẽ định hình cách ứng dụng của chúng ta hoạt động và tương tác.\n\nĐầu tiên là phần **Data Model**, hay còn gọi là mô hình dữ liệu. Chúng ta sẽ tạo một mô hình đơn giản tên là `TaskItem` để đại diện cho một công việc. Mỗi `TaskItem` sẽ có hai thuộc tính chính: `Title` – là một chuỗi để lưu tên công việc, và `IsCompleted` – một kiểu boolean để biết công việc đã hoàn thành hay chưa. Điều quan trọng ở đây là mô hình này phải kế thừa từ `ObservableObject`. Tại sao lại vậy? Bởi vì khi trạng thái của một công việc thay đổi – ví dụ, bạn đánh dấu nó là hoàn thành – thì giao diện người dùng cần phải tự động cập nhật mà không cần chúng ta phải viết quá nhiều code thủ công. `ObservableObject` chính là công cụ giúp chúng ta làm điều đó một cách hiệu quả.\n\nTiếp theo là trái tim của ứng dụng: **ViewModel** của chúng ta, cụ thể là `TasksViewModel`. ViewModel này sẽ chứa các thuộc tính để quản lý dữ liệu và trạng thái của giao diện. Chúng ta sẽ có `NewTaskTitle` để nhận đầu vào từ người dùng khi họ muốn thêm công việc mới. Một `ObservableCollection` tên là `Tasks` sẽ lưu trữ danh sách các công việc. `ObservableCollection` rất quan trọng vì nó sẽ tự động thông báo cho UI biết mỗi khi có công việc mới được thêm vào, xóa đi, hoặc thay đổi vị trí. Ngoài ra, chúng ta còn có `SelectedTask` để theo dõi công việc đang được chọn, và hai thuộc tính `TotalCount`, `CompletedCount` để hiển thị tóm tắt tổng số công việc và số công việc đã hoàn thành. Về các **Commands** (lệnh), chúng ta sẽ có `AddTaskCommand` để xử lý logic khi người dùng bấm nút thêm công việc. Để đơn giản hóa việc viết code MVVM, chúng ta sẽ tận dụng các thuộc tính `[ObservableProperty]` và `[RelayCommand]` từ MAUI Community Toolkit. Chúng giúp giảm bớt lượng code 'lặp lại' mà vẫn đảm bảo tính năng thông báo thay đổi và thực thi lệnh một cách hiệu quả.\n\nBây giờ đến phần giao diện, hay còn gọi là **XAML Requirements**. Đây là nơi chúng ta kết nối UI với ViewModel. Chúng ta sẽ sử dụng TwoWay binding cho `Entry.Text` để đảm bảo dữ liệu nhập vào từ ô văn bản có thể đi vào ViewModel và ngược lại. Tương tự, `CheckBox.IsChecked` cũng sẽ dùng TwoWay binding để cập nhật trạng thái hoàn thành của công việc. Để hiển thị danh sách công việc, chúng ta sẽ dùng `CollectionView`, một control hiện đại và mạnh mẽ hơn ListView truyền thống. Một điểm nhấn thú vị là chúng ta sẽ dùng một **Value Converter** để tạo hiệu ứng gạch ngang cho các công việc đã hoàn thành, giúp người dùng dễ dàng nhận biết. Và để hiển thị văn bản tóm tắt như \"Tổng số: X, Đã hoàn thành: Y\", chúng ta sẽ cần đến **MultiBinding** để kết hợp nhiều thuộc tính từ ViewModel vào một chuỗi văn bản duy nhất. Cuối cùng, chúng ta cũng sẽ áp dụng `x:Reference` ít nhất một lần để thực hành việc tham chiếu giữa các control trong XAML.\n\nTất nhiên, để bắt đầu tất cả những điều này, bước đầu tiên rất đơn giản: chỉ cần **tạo một dự án .NET MAUI mới**. Đó là nền tảng để chúng ta bắt đầu xây dựng mọi thứ.\n\nĐó là tổng quan về các yêu cầu chính cho mô hình dữ liệu, ViewModel và giao diện người dùng. Khi kết hợp các yếu tố này lại, chúng ta sẽ có một ứng dụng quản lý công việc hoạt động mượt mà và hiệu quả.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "2. Install CommunityToolkit.Mvvm \n3. Create the model class \n4. Create the ViewModel \n5. Design the UI in XAML \n6. Apply required bindings \n7. Test UI behavior \n \n10. Assessment Rubric (10 Marks) \nCriteria Marks \nCorrect MVVM structure 2 \nProper use of binding modes 3 \nCommand implementation 2 \nConverter & MultiBinding 2 \nUI completeness & clarity 1 \n \n11. Submission Requirements \nStudents must submit: \n• Source code folder or Git repository \n• Screenshot of running application \n \n12. Notes \n• Code-behind should be minimal or empty \n• Focus on binding correctness, not UI aesthetics \n• Naming conventions and clean structure are required \n \nEnd of Lab",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Chào mừng các bạn đến với buổi hướng dẫn bài lab hôm nay! Chúng ta sẽ cùng nhau điểm qua các bước thực hiện, cũng như những tiêu chí quan trọng để hoàn thành bài tập một cách tốt nhất.\n\nĐầu tiên, để bắt đầu dự án, các bạn hãy **cài đặt thư viện CommunityToolkit.Mvvm** – đây sẽ là nền tảng giúp chúng ta triển khai mô hình MVVM một cách hiệu quả.\n\nTiếp theo, chúng ta sẽ lần lượt **tạo các lớp Model và ViewModel**. Hãy nhớ rằng Model dùng để biểu diễn dữ liệu, còn ViewModel sẽ là nơi chứa logic nghiệp vụ và phơi bày dữ liệu cho giao diện người dùng. Sau khi có Model và ViewModel, các bạn sẽ **thiết kế giao diện người dùng (UI) trong XAML**. Đây là lúc để biến ý tưởng của mình thành hình ảnh.\n\nVà một trong những bước quan trọng nhất chính là **áp dụng các binding cần thiết**. Việc này sẽ giúp UI và ViewModel của chúng ta 'nói chuyện' với nhau, đảm bảo dữ liệu luôn được đồng bộ. Cuối cùng, đừng quên **kiểm tra kỹ lưỡng hành vi của UI** để đảm bảo mọi chức năng đều hoạt động đúng như mong đợi.\n\nBây giờ, hãy nói một chút về cách bài lab này sẽ được đánh giá. Chúng ta có tổng cộng 10 điểm, và đây là những tiêu chí cụ thể:\n\nĐầu tiên là **cấu trúc MVVM chính xác (2 điểm)**. Điều này rất quan trọng vì nó thể hiện sự hiểu biết của các bạn về việc tách biệt các mối quan tâm trong ứng dụng. Kế đến, **việc sử dụng đúng các chế độ binding (3 điểm)** chiếm tỷ trọng cao nhất. Hãy cân nhắc kỹ xem khi nào thì dùng OneWay, TwoWay hay OneTime để đảm bảo luồng dữ liệu hiệu quả.\n\nTiếp theo, **cách các bạn triển khai Command (2 điểm)** cũng sẽ được chấm điểm. Command giúp chúng ta xử lý các hành động từ UI mà không cần can thiệp vào code-behind. Ngoài ra, **việc sử dụng Converter và MultiBinding (2 điểm)** cũng là một điểm cộng lớn, cho thấy các bạn có thể xử lý các tình huống binding phức tạp hơn. Và cuối cùng, **tính đầy đủ và rõ ràng của UI (1 điểm)**. Không cần quá cầu kỳ về mặt thẩm mỹ, nhưng UI cần phải thể hiện đủ các thành phần chức năng được yêu cầu.\n\nVề yêu cầu nộp bài, các bạn cần gửi hai thứ: Thứ nhất là **toàn bộ thư mục mã nguồn hoặc link đến kho Git repository** của các bạn. Và thứ hai là một **ảnh chụp màn hình (screenshot) của ứng dụng đang chạy** để chúng tôi dễ dàng kiểm tra kết quả.\n\nCuối cùng, một vài lưu ý nhỏ nhưng rất quan trọng để bài làm của các bạn đạt chất lượng cao:\n\nHãy cố gắng giữ cho **code-behind của các bạn ở mức tối thiểu hoặc hoàn toàn trống**. Đây là một trong những mục tiêu chính khi chúng ta dùng MVVM. Thứ hai, hãy **tập trung vào tính đúng đắn của binding chứ không phải yếu tố thẩm mỹ của UI**. Điều quan trọng là chức năng hoạt động. Và đừng quên, việc **tuân thủ các quy ước đặt tên và giữ cho cấu trúc dự án gọn gàng, sạch sẽ** luôn được đánh giá cao, vì nó thể hiện sự chuyên nghiệp trong cách làm việc.\n\nĐó là toàn bộ những hướng dẫn và lưu ý cho bài lab này. Chúc các bạn làm bài thật tốt và nếu có bất kỳ thắc mắc nào, đừng ngần ngại hỏi nhé!",
        "edited_text": "Chào mừng các bạn đến với buổi hướng dẫn bài lab hôm nay! Chúng ta sẽ cùng nhau điểm qua các bước thực hiện, cũng như những tiêu chí quan trọng để hoàn thành bài tập một cách tốt nhất.\n\nĐầu tiên, để bắt đầu dự án, các bạn hãy **cài đặt thư viện CommunityToolkit.Mvvm** – đây sẽ là nền tảng giúp chúng ta triển khai mô hình MVVM một cách hiệu quả.\n\nTiếp theo, chúng ta sẽ lần lượt **tạo các lớp Model và ViewModel**. Hãy nhớ rằng Model dùng để biểu diễn dữ liệu, còn ViewModel sẽ là nơi chứa logic nghiệp vụ và phơi bày dữ liệu cho giao diện người dùng. Sau khi có Model và ViewModel, các bạn sẽ **thiết kế giao diện người dùng (UI) trong XAML**. Đây là lúc để biến ý tưởng của mình thành hình ảnh.\n\nVà một trong những bước quan trọng nhất chính là **áp dụng các binding cần thiết**. Việc này sẽ giúp UI và ViewModel của chúng ta 'nói chuyện' với nhau, đảm bảo dữ liệu luôn được đồng bộ. Cuối cùng, đừng quên **kiểm tra kỹ lưỡng hành vi của UI** để đảm bảo mọi chức năng đều hoạt động đúng như mong đợi.\n\nBây giờ, hãy nói một chút về cách bài lab này sẽ được đánh giá. Chúng ta có tổng cộng 10 điểm, và đây là những tiêu chí cụ thể:\n\nĐầu tiên là **cấu trúc MVVM chính xác (2 điểm)**. Điều này rất quan trọng vì nó thể hiện sự hiểu biết của các bạn về việc tách biệt các mối quan tâm trong ứng dụng. Kế đến, **việc sử dụng đúng các chế độ binding (3 điểm)** chiếm tỷ trọng cao nhất. Hãy cân nhắc kỹ xem khi nào thì dùng OneWay, TwoWay hay OneTime để đảm bảo luồng dữ liệu hiệu quả.\n\nTiếp theo, **cách các bạn triển khai Command (2 điểm)** cũng sẽ được chấm điểm. Command giúp chúng ta xử lý các hành động từ UI mà không cần can thiệp vào code-behind. Ngoài ra, **việc sử dụng Converter và MultiBinding (2 điểm)** cũng là một điểm cộng lớn, cho thấy các bạn có thể xử lý các tình huống binding phức tạp hơn. Và cuối cùng, **tính đầy đủ và rõ ràng của UI (1 điểm)**. Không cần quá cầu kỳ về mặt thẩm mỹ, nhưng UI cần phải thể hiện đủ các thành phần chức năng được yêu cầu.\n\nVề yêu cầu nộp bài, các bạn cần gửi hai thứ: Thứ nhất là **toàn bộ thư mục mã nguồn hoặc link đến kho Git repository** của các bạn. Và thứ hai là một **ảnh chụp màn hình (screenshot) của ứng dụng đang chạy** để chúng tôi dễ dàng kiểm tra kết quả.\n\nCuối cùng, một vài lưu ý nhỏ nhưng rất quan trọng để bài làm của các bạn đạt chất lượng cao:\n\nHãy cố gắng giữ cho **code-behind của các bạn ở mức tối thiểu hoặc hoàn toàn trống**. Đây là một trong những mục tiêu chính khi chúng ta dùng MVVM. Thứ hai, hãy **tập trung vào tính đúng đắn của binding chứ không phải yếu tố thẩm mỹ của UI**. Điều quan trọng là chức năng hoạt động. Và đừng quên, việc **tuân thủ các quy ước đặt tên và giữ cho cấu trúc dự án gọn gàng, sạch sẽ** luôn được đánh giá cao, vì nó thể hiện sự chuyên nghiệp trong cách làm việc.\n\nĐó là toàn bộ những hướng dẫn và lưu ý cho bài lab này. Chúc các bạn làm bài thật tốt và nếu có bất kỳ thắc mắc nào, đừng ngần ngại hỏi nhé!",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-24 15:06:27",
    "avatar_path": null,
    "final_video_path": null
  },
  "3e609cb1-e938-4b15-ba5b-e4145086a81e": {
    "id": "3e609cb1-e938-4b15-ba5b-e4145086a81e",
    "filename": "CHUONG_6_DAN_TOC.pptx",
    "file_path": "static/uploads/presentations\\5f39ee09-b261-4fb4-a88d-ee11f075067e\\CHUONG_6_DAN_TOC.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Chương 6\u000bVẤN ĐỀ DÂN TỘC VÀ TÔN GIÁO \nTRONG THỜI KỲ QUÁ ĐỘ \nLÊN CHỦ NGHĨA XÃ HỘI\nGiảng viên: ThS. Đặng Thị Kim Dung",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "1. Dân tộc trong thời kỳ quá độ lên chủ nghĩa xã hội",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "NỘI DUNG BÀI",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Dân tộc quốc gia\n(Nation)",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "ĐẶC TRƯNG CỦA DÂN TỘC",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "ĐẶC TRƯNG \u000bCỦA DÂN TỘC\nKHÔNG GIAN SINH TỒN\nVỊ TRÍ ĐỊA LÝ CỦA DÂN TỘC\nTHỂ HIỆN \nCHỦ QUYỀN CỦA MỘT DÂN TỘC",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "ĐẶC TRƯNG \u000bCỦA DÂN TỘC\nMối quan hệ kinh tế là nền tảng cho sự vững chắc của cộng đồng dân tộc",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "ĐẶC TRƯNG \u000bCỦA DÂN TỘC",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Bản sắc riêng của từng dân tộc\nVăn hóa của các cộng đồng\n tộc người trong một quốc gia\nĐẶC TRƯNG \u000bCỦA DÂN TỘC",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Đây là yếu tố phân biệt dân tộc – quốc gia và dân tộc – tộc người\nNhà nước là đặc trưng cho thể chế chính trị của dân tộc\nĐẶC TRƯNG \u000bCỦA DÂN TỘC",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Khái niệm dân tộc\nDân tộc tộc người (ethnie)",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Đặc trưng Dân tộc – tộc người",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "1.2. Chủ nghĩa Mác – Lênin về vấn đề dân tộc\n1.2.1. Hai xu hướng khách quan của sự phát triển quan hệ dân tộc\n1.2.2. Cương lĩnh dân tộc của chủ nghĩa Mác - Lênin",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Xu hướng thứ nhất\u000bCộng đồng dân cư muốn tách ra \u000bhình thành cộng đồng dân tộc độc lập\nNguyên nhân\nThức tỉnh, trưởng thành về ý thức dân tộc\nQuyền sống của mình\nCác cộng đồng dân cư tách ra thành lập các dân tộc độc lập",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Xu hướng thứ nhất\u000bCộng đồng dân cư muốn tách ra hình thành cộng đồng dân tộc độc lập",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Xu hướng thứ hai\u000bCác dân tộc trong từng quốc gia, dân tộc ở nhiều quốc gia liên hiệp lại\nNguyên nhân\nChủ nghĩa đế quốc đi \nxâm lược các nước thuộc địa",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "NATO (4/4/1949)\nKhối quấn sự Bắc Đại Tây Dương",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Xu hướng thứ hai\u000bCác dân tộc trong từng quốc gia, dân tộc ở nhiều quốc gia liên hiệp lại\nNguyên nhân\nChủ nghĩa đế quốc đi \nxâm lược các nước thuộc địa\nDo sự phát triển của lực lượng sản xuất",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "BIỂU HIỆN CỦA HAI XU HƯỚNG KHÁCH QUAN TRONG PHÁT TRIỂN QUAN HỆ DÂN TỘC TRONG GIAI ĐOẠN HIỆN NAY\nTHẢO LUẬN",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Đôngtimore tách khỏi Inđônêxia 5/2002\nNam Ossetia tách khỏi Gruzia sau sự kiện 8/2008",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Kôsôvô\ntách khỏi Sécbia\n17/2/2008\nNgười dân Kôsôvô \nhân hoan nhân ngày độc lập",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Biểu hiện xu hướng liên hiệp lại giữa \ncác dân tộc trong giai đoạn hiện nay",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "EU\nLiên minh Châu Âu\nASEAN – Hiệp hội các quốc gia ĐNÁ\nUAE\nTiểu vương quốc Ả rập thống nhất",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "1.2.3. Cương lĩnh dân tộc của chủ nghĩa Mác - Lênin",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Quyền thiêng liêng \ncủa các \ndân tộc",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Bình đẳng giữa các dân tộc trong một quốc gia",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "BÌNH ĐẲNG TRONG HIẾN PHÁP VÀ THỰC TIỄN",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Bình đẳng giữa các \nquốc gia\nChống chủ nghĩa \nphân biệt chủng tộc,\n bá quyền",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "HIỆN NAY CÁC\n QUỐC GIA DÂN TỘC TRÊN THẾ GIỚI ĐÃ BÌNH ĐẲNG CHƯA? TẠI SAO?",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Trung Quốc với mưu đồ chiếm biển Đông\nẢnh chụp trên cao cho thấy Trung Quốc đang đẩy mạnh xây dựng trên đảo Phú Lâm thuộc quần đảo Hoàng Sa",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "“Bảo đảm lợi ích tối cao của quốc gia – dân tộc, trên cơ sở các nguyên tắc cơ bản của luật pháp quốc tế, bình đẳng và cùng có lợi, thực hiện nhất quán đường lối đối ngoại độc lập, tự chủ, hòa bình, hợp tác và phát triển”\nĐảng cộng sản Việt Nam: Văn kiện đại hội đại biểu toàn quốc lần thứ XII, HN, 2016, tr.153.",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 36,
        "content": "",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 37,
        "content": "Quyền làm chủ        \n        Quyền tự quyết định con đường phát triển                     \n        Quyền tự do phân lập và quyền tự nguyện liên hiệp",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 38,
        "content": "Sau thất bại mô hình CNXH ở các nước Đông Âu và Liên Xô năm 1991\nĐặt ra yêu cầu gì\n đối với việc lựa chọn \ncon đường phát triển ở Việt Nam \nvà các nước XHCN?",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 39,
        "content": "Đường lối đổi mới từ năm 1986",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 40,
        "content": "Kinh tế thị trường định hướng XHCN\nTăng trưởng kinh tế",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 41,
        "content": "",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 42,
        "content": "Phân tích \u000bvụ việc\u000b Kích động thành lập “Vương quốc Mông” \u000bở Mường Nhé, \u000bĐiện Biên",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 43,
        "content": "CÁC DÂN TỘC \nĐƯỢC QUYỀN TỰ QUYẾT\nQUYỀN ĐƯỢC PHÂN LẬP VÀ \nLIÊN HIỆP \nTHAM GIA \nTỔ CHỨC QUỐC TẾ\nĐỨNG TRÊN QUAN ĐIỂM CNDVLS \nVÀ LẬP TRƯỜNG GIAI CẤP \nCÔNG NHÂN",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 44,
        "content": "Liên hiệp công nhân tất cả các dân tộc\nPhản ánh sự thống nhất giữa giải phóng dân tộc, giải phóng giai cấp\nPhản ánh sự gắn bó tinh thần của CN yêu nước và CN quốc tế chân chinh\nLà cơ sở để đoan kết các tầng lớp nhân dân lao động",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 45,
        "content": "Giá trị lịch sử của Cương lĩnh và việc tiếp thu, vận dụng ở Việt Nam\n- Nêu rõ chính sách của Quốc tế Cộng sản về vấn đề dân tộc và thuộc địa.\n- Động lực to lớn với phong trào giải phóng dân tộc ở các nước thuộc địa.\n- Chủ tịch Hồ Chí Minh đã tiếp thu, vận dụng sáng tạo để giải quyết đúng đắn quan hệ giai cấp - dân tộc, dân tộc, quốc tế ở nước ta.",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 46,
        "content": "1.3. Dân tộc và quan hệ dân tộc ở Việt Nam\n1.3.1. Đặc điểm dân tộc Việt Nam",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 47,
        "content": "1.3.2. Quan điểm, chính sách của Đảng và Nhà nước ta về vấn đề dân tộc và công tác dân tộc trong thời kỳ mới\nNội dung đối nội của chính sách dân tộc\n+ Bình đẳng giữa các dân tộc\n+ Đoàn kết các dân tộc.\n+ Tương trợ nhau cùng phát triển.\nNội dung đối ngoại của chính sách dân tộc\n+ Thực hiện quan hệ dân tộc trên tinh thần độc lập tự chủ, mở rộng, đa phương hóa các quan hệ quốc tế. Việt Nam sẵn sàng là bạn, là đối tác tin cậy của các nước trong cộng đồng quốc tế, phấn đấu vì hòa bình, độc lập và phát triển.",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-28 15:10:35",
    "avatar_path": null,
    "final_video_path": null
  },
  "866a9b9c-e768-44e1-8b8a-dd471dae5022": {
    "id": "866a9b9c-e768-44e1-8b8a-dd471dae5022",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/8f62a5c6-4a0b-4263-b11e-1c05afec02d9/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 15:28:24",
    "avatar_path": null,
    "final_video_path": null
  },
  "d6ad2e2b-458f-405c-a70d-a8951dfd8ceb": {
    "id": "d6ad2e2b-458f-405c-a70d-a8951dfd8ceb",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/ae125ccc-47db-4ed3-9d9b-3df330694f71/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 16:05:45",
    "avatar_path": null,
    "final_video_path": null
  },
  "78131c65-e6af-4757-a4a9-cba2f48f79b0": {
    "id": "78131c65-e6af-4757-a4a9-cba2f48f79b0",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/cf04d0b3-a4f0-43f2-b3b9-24e2efbfc0ab/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 16:06:07",
    "avatar_path": null,
    "final_video_path": null
  },
  "12ec0b2e-10bc-482c-b9a4-63705091a1b5": {
    "id": "12ec0b2e-10bc-482c-b9a4-63705091a1b5",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/57a06e11-9365-4800-98cd-34524f6a169d/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 18:29:54",
    "avatar_path": null,
    "final_video_path": null
  },
  "ad0a346d-d3f9-4b7c-84a7-dafb9e52919e": {
    "id": "ad0a346d-d3f9-4b7c-84a7-dafb9e52919e",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/4c84b539-6d71-4504-a651-5769c30daf68/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 18:48:11",
    "avatar_path": null,
    "final_video_path": null
  },
  "f7e5affb-d423-479a-8960-160ff3bcc24c": {
    "id": "f7e5affb-d423-479a-8960-160ff3bcc24c",
    "filename": "ORAL_EXAM_DESIGN.pdf",
    "file_path": "static/uploads/presentations/8ebb5afa-1f16-487e-a3e5-00a12af66a9c/ORAL_EXAM_DESIGN.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "ORAL EXAM DESIGN \n.NET MAUI – XAML UI & Data Binding (CommunityToolkit.Mvvm) \n \n1. Exam Overview \nExam Type: Practical + Oral Examination \nFormat: Team-based (2 students / team) \nNumber of Teams: 13 teams \nTotal Duration per Team: 2 hours 10 minutes \n• Part 1: Practical UI Project – 2 hours \n• Part 2: Oral Examination – 10 minutes \n \n2. Exam Objectives \nThis oral exam aims to assess students’ ability to: \n• Design UI layouts using XAML in .NET MAUI \n• Correctly apply data binding techniques \n• Implement MVVM pattern using CommunityToolkit.Mvvm \n• Explain and justify technical decisions verbally \n• Demonstrate individual understanding within a team project \n \n3. Allowed Resources \n• Visual Studio 2022 or later \n• .NET MAUI project template \n• Internet access for documentation only \n• NuGet package: CommunityToolkit.Mvvm \n  No pre-written project code allowed \n \n4. Part 1 – Practical Project (2 Hours) \nGeneral Requirements (All Teams) \nEach team must build a single-screen MAUI application with: \n• UI designed in XAML \n• MVVM architecture \n• At least 4 different binding techniques",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "• No navigation between pages \n• No database or API \n \nMandatory Binding Techniques \nEach project must demonstrate: \n1. TwoWay Binding (Entry ↔ ViewModel) \n2. OneWay Binding (Display data) \n3. Command Binding (Button actions) \n4. ObservableCollection Binding (List update) \nAt least ONE advanced binding: \n• Converter \n• MultiBinding \n• RelativeSource \n• x:Reference \n \n5. Personalized Project Topics (14 Teams) \nEach team receives one unique UI scenario to prevent copying while keeping difficulty \nequivalent. \nTeam Assignments \nTeam Project Theme \n1 Grocery Shopping List \n2 Daily Habit Tracker \n3 Student Attendance UI \n4 Expense Tracker (UI only) \n5 Book Reading Tracker \n6 Workout Session Planner \n7 Movie Watchlist \n8 Meeting Agenda Manager \n9 Event Checklist",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Team Project Theme \n10 Smart Home Device Panel \n11 Plant Care Reminder UI \n12 Simple Note Organizer \n13 Classroom Equipment Checklist \nAll projects must follow the same technical constraints, only the UI content differs. \n \n6. Minimum Feature Set (Example) \nEach project should include: \n• Title header \n• Input section (Entry) \n• Action button(s) \n• List display (CollectionView) \n• Status indicator (Label / CheckBox / Switch) \n• Summary section (count, status, or description) \n \n7. Part 2 – Oral Examination (10 Minutes) \nStructure \n• 5 minutes: Project demonstration \n• 5 minutes: Oral questions (individual) \nBoth students must answer questions. \n \n8. Oral Question Bank (Examiner Chooses) \nUI & XAML (Basic) \n• Why did you choose Grid instead of StackLayout? \n• Explain the role of CollectionView in your UI. \nData Binding \n• Explain the difference between OneWay and TwoWay binding. \n• Why is ObservableCollection required? \nMVVM & Toolkit",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "• What problem does CommunityToolkit.Mvvm solve? \n• Explain [ObservableProperty] and [RelayCommand]. \nAdvanced Binding (If Used) \n• Why did you use a converter here? \n• Explain how MultiBinding works in your project. \n \n9. Individual Assessment Strategy \nTo ensure fairness: \n• Examiner asks different questions to each student \n• Each student must explain at least one binding used \n• Examiner may ask one student to modify a binding verbally \n \n10. Grading Rubric (20 Marks) \nPractical Project – 12 Marks \nCriteria Marks \nUI layout correctness 3 \nCorrect binding usage 4 \nMVVM structure 3 \nCode clarity & organization 2 \nOral Examination – 8 Marks \nCriteria Marks \nExplanation of bindings 3 \nMVVM understanding 2 \nIndividual contribution 2 \nCommunication clarity 1 \n \n11. Examiner Notes \n• Focus on understanding, not memorization \n• Penalize code-behind logic",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "• Encourage students to explain design decisions \n• Each team having a team leader, using GitHub to store the project, branch then merge \nfor the final submission \n• Each team must have a brainstorming for the project (visualation using any mindmap \napplication), checkin along with code.  \n \n12. Expected Learning Outcomes \nAfter the exam, students should be able to: \n• Design MAUI UI using XAML confidently \n• Apply data binding correctly \n• Explain MVVM principles verbally \n• Read and reason about XAML code \n \nEnd of Oral Exam Design",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 18:55:51",
    "avatar_path": null,
    "final_video_path": null
  },
  "7b71aa40-651c-41d0-827a-34f2c9917498": {
    "id": "7b71aa40-651c-41d0-827a-34f2c9917498",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/06072422-3657-4968-aeb0-da7fba4912c4/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 19:13:44",
    "avatar_path": null,
    "final_video_path": null
  },
  "6e24eafa-5c61-494b-aa01-1d5b55ade761": {
    "id": "6e24eafa-5c61-494b-aa01-1d5b55ade761",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/6e24eafa-5c61-494b-aa01-1d5b55ade761/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 19:28:10",
    "avatar_path": null,
    "final_video_path": null
  },
  "9fa47167-f1b8-4ad2-a84b-932d471a7221": {
    "id": "9fa47167-f1b8-4ad2-a84b-932d471a7221",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/9fa47167-f1b8-4ad2-a84b-932d471a7221/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "Chào mừng quý vị. Hôm nay chúng ta sẽ cùng tìm hiểu về vai trò cốt lõi của các mẫu thiết kế cấu trúc trong lập trình.\n\nCác mẫu thiết kế cấu trúc tập trung vào cách chúng ta kết hợp các lớp và đối tượng để tạo thành những cấu trúc lớn hơn, đồng thời đảm bảo rằng các cấu trúc này luôn linh hoạt, dễ tái sử dụng và dễ phát triển theo thời gian. Nói cách khác, chúng trả lời một câu hỏi then chốt: Làm thế nào để chúng ta tổ chức các lớp và đối tượng một cách hiệu quả, sao cho khi có thay đổi ở một phần của hệ thống, tác động lên các phần khác là tối thiểu nhất?\n\nĐể đạt được những mục tiêu đó, các mẫu thiết kế cấu trúc đảm nhiệm một số trách nhiệm chính.\n\nĐầu tiên, chúng giúp tách rời các thành phần. Điều này có nghĩa là giảm sự phụ thuộc trực tiếp giữa các lớp, làm cho hệ thống của chúng ta trở nên mạnh mẽ và dễ bảo trì hơn.\n\nThứ hai, chúng thúc đẩy việc tái sử dụng mã nguồn hiện có. Chúng ta có thể tích hợp các thành phần hệ thống cũ hoặc thư viện của bên thứ ba vào hệ thống của mình mà không cần phải sửa đổi mã gốc của chúng.\n\nThứ ba, các mẫu này hỗ trợ quản lý sự phức tạp. Bằng cách cung cấp các lớp trừu tượng đơn giản hơn, chúng ta có thể che giấu đi sự phức tạp bên trong của các hệ thống con, giúp dễ dàng làm việc hơn.\n\nVà cuối cùng, chúng cho phép chúng ta mở rộng hành vi mà không gây ra tình trạng \"bùng nổ kế thừa\". Thay vì tạo ra quá nhiều lớp con, chúng ta sẽ ưu tiên sử dụng phương pháp thành phần hóa hơn là kế thừa để đạt được sự linh hoạt và khả năng mở rộng mong muốn.",
        "edited_text": "\nCác mẫu thiết kế cấu trúc tập trung vào cách chúng ta kết hợp các lớp và đối tượng để tạo thành những cấu trúc lớn hơn, đồng thời đảm bảo rằng các cấu trúc này luôn linh hoạt, dễ tái sử dụng và dễ phát triển theo thời gian. Nói cách khác, chúng trả lời một câu hỏi then chốt: Làm thế nào để chúng ta tổ chức các lớp và đối tượng một cách hiệu quả, sao cho khi có thay đổi ở một phần của hệ thống, tác động lên các phần khác là tối thiểu nhất?\n\nĐể đạt được những mục tiêu đó, các mẫu thiết kế cấu trúc đảm nhiệm một số trách nhiệm chính.\n\nĐầu tiên, chúng giúp tách rời các thành phần. Điều này có nghĩa là giảm sự phụ thuộc trực tiếp giữa các lớp, làm cho hệ thống của chúng ta trở nên mạnh mẽ và dễ bảo trì hơn.\n\nThứ hai, chúng thúc đẩy việc tái sử dụng mã nguồn hiện có. Chúng ta có thể tích hợp các thành phần hệ thống cũ hoặc thư viện của bên thứ ba vào hệ thống của mình mà không cần phải sửa đổi mã gốc của chúng.\n\nThứ ba, các mẫu này hỗ trợ quản lý sự phức tạp. Bằng cách cung cấp các lớp trừu tượng đơn giản hơn, chúng ta có thể che giấu đi sự phức tạp bên trong của các hệ thống con, giúp dễ dàng làm việc hơn.\n\nVà cuối cùng, chúng cho phép chúng ta mở rộng hành vi mà không gây ra tình trạng \"bùng nổ kế thừa\". Thay vì tạo ra quá nhiều lớp con, chúng ta sẽ ưu tiên sử dụng phương pháp thành phần hóa hơn là kế thừa để đạt được sự linh hoạt và khả năng mở rộng mong muốn.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 19:35:03",
    "avatar_path": null,
    "final_video_path": null
  }
}