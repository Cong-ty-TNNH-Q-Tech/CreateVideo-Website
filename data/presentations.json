{
  "70849fb9-49fa-41d8-a4ff-d66d03529fde": {
    "id": "70849fb9-49fa-41d8-a4ff-d66d03529fde",
    "filename": "Maui_Xaml_Binding_Lab_Handout.pdf",
    "file_path": "static/uploads/presentations\\70849fb9-49fa-41d8-a4ff-d66d03529fde\\Maui_Xaml_Binding_Lab_Handout.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "LAB HANDOUT \nMAUI XAML Binding Practice with CommunityToolkit.Mvvm \n \nCourse / Module \nMobile Application Development (.NET MAUI) \nLab Title \nTask Manager – XAML Data Binding & MVVM Toolkit \nDuration \n3 hours (180 minutes) \nLab Type \nIndividual – Hands-on Practice \n \n1. Lab Objectives \nAfter completing this lab, students will be able to: \n• Explain the purpose of data binding in .NET MAUI \n• Apply MVVM pattern using CommunityToolkit.Mvvm \n• Correctly use common binding modes in XAML \n• Bind UI elements to ViewModel properties and commands \n• Use converters and MultiBinding in real UI scenarios \n \n2. Software & Tools \n• Visual Studio 2022 or later \n• .NET MAUI workload installed \n• NuGet package: \no CommunityToolkit.Mvvm",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "3. Problem Description \nYou are required to build a single-screen Task Manager application using .NET MAUI \n(XAML). \nThe application allows users to: - Enter a task name - Add the task to a list - Mark tasks as \ncompleted - View task statistics (total and completed) \n    Constraints - No navigation between pages - No database or API - No code-\nbehind logic for UI behavior - All interactions must be implemented using data \nbinding and commands \n \n4. User Interface Specification \nMain Screen Components \n1. Application title: MY TASKS \n2. Text input for new task \n3. Add button \n4. Task list (CollectionView) \n5. Checkbox for task completion \n6. Summary section displaying: \no Total tasks \no Completed tasks \n \n5. Required Binding Types \nYour solution must demonstrate the following bindings: \nNo Binding Type Required Usage \n1 OneWay Display task title \n2 TwoWay Entry ↔ ViewModel property \n3 OneWayToSource Selected task \n4 Command Add task action \n5 RelativeSource Access ViewModel from item template \n6 x:Reference UI-to-UI binding \n7 Converter Completed task text style \n8 MultiBinding Summary text \n9 ObservableCollection Auto-update task list \n10 INotifyPropertyChanged ViewModel updates",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "6. Data Model \nCreate a TaskItem model that contains: \n• Title (string) \n• IsCompleted (bool) \nThe model must inherit from ObservableObject. \n \n7. ViewModel Requirements \nCreate TasksViewModel with the following: \nProperties \n• NewTaskTitle (string) \n• Tasks (ObservableCollection) \n• SelectedTask (TaskItem) \n• TotalCount (int) \n• CompletedCount (int) \nCommands \n• AddTaskCommand \nUse [ObservableProperty] and [RelayCommand] attributes where applicable. \n \n8. XAML Requirements \n• Bind Entry.Text using TwoWay binding \n• Bind Button.Command to ViewModel command \n• Use CollectionView for task list \n• Bind CheckBox.IsChecked using TwoWay binding \n• Use a Value Converter to apply strikethrough to completed tasks \n• Use MultiBinding for summary text \n• Use x:Reference at least once \n \n9. Suggested Lab Steps \n1. Create a new .NET MAUI project",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "2. Install CommunityToolkit.Mvvm \n3. Create the model class \n4. Create the ViewModel \n5. Design the UI in XAML \n6. Apply required bindings \n7. Test UI behavior \n \n10. Assessment Rubric (10 Marks) \nCriteria Marks \nCorrect MVVM structure 2 \nProper use of binding modes 3 \nCommand implementation 2 \nConverter & MultiBinding 2 \nUI completeness & clarity 1 \n \n11. Submission Requirements \nStudents must submit: \n• Source code folder or Git repository \n• Screenshot of running application \n \n12. Notes \n• Code-behind should be minimal or empty \n• Focus on binding correctness, not UI aesthetics \n• Naming conventions and clean structure are required \n \nEnd of Lab",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-24 14:38:59",
    "avatar_path": null,
    "final_video_path": null
  },
  "a972a9ff-29c4-42e0-8b3e-d4bc4f54e3a4": {
    "id": "a972a9ff-29c4-42e0-8b3e-d4bc4f54e3a4",
    "filename": "Maui_Xaml_Binding_Lab_Handout.pdf",
    "file_path": "static/uploads/presentations\\a972a9ff-29c4-42e0-8b3e-d4bc4f54e3a4\\Maui_Xaml_Binding_Lab_Handout.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "LAB HANDOUT \nMAUI XAML Binding Practice with CommunityToolkit.Mvvm \n \nCourse / Module \nMobile Application Development (.NET MAUI) \nLab Title \nTask Manager – XAML Data Binding & MVVM Toolkit \nDuration \n3 hours (180 minutes) \nLab Type \nIndividual – Hands-on Practice \n \n1. Lab Objectives \nAfter completing this lab, students will be able to: \n• Explain the purpose of data binding in .NET MAUI \n• Apply MVVM pattern using CommunityToolkit.Mvvm \n• Correctly use common binding modes in XAML \n• Bind UI elements to ViewModel properties and commands \n• Use converters and MultiBinding in real UI scenarios \n \n2. Software & Tools \n• Visual Studio 2022 or later \n• .NET MAUI workload installed \n• NuGet package: \no CommunityToolkit.Mvvm",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "3. Problem Description \nYou are required to build a single-screen Task Manager application using .NET MAUI \n(XAML). \nThe application allows users to: - Enter a task name - Add the task to a list - Mark tasks as \ncompleted - View task statistics (total and completed) \n    Constraints - No navigation between pages - No database or API - No code-\nbehind logic for UI behavior - All interactions must be implemented using data \nbinding and commands \n \n4. User Interface Specification \nMain Screen Components \n1. Application title: MY TASKS \n2. Text input for new task \n3. Add button \n4. Task list (CollectionView) \n5. Checkbox for task completion \n6. Summary section displaying: \no Total tasks \no Completed tasks \n \n5. Required Binding Types \nYour solution must demonstrate the following bindings: \nNo Binding Type Required Usage \n1 OneWay Display task title \n2 TwoWay Entry ↔ ViewModel property \n3 OneWayToSource Selected task \n4 Command Add task action \n5 RelativeSource Access ViewModel from item template \n6 x:Reference UI-to-UI binding \n7 Converter Completed task text style \n8 MultiBinding Summary text \n9 ObservableCollection Auto-update task list \n10 INotifyPropertyChanged ViewModel updates",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "6. Data Model \nCreate a TaskItem model that contains: \n• Title (string) \n• IsCompleted (bool) \nThe model must inherit from ObservableObject. \n \n7. ViewModel Requirements \nCreate TasksViewModel with the following: \nProperties \n• NewTaskTitle (string) \n• Tasks (ObservableCollection) \n• SelectedTask (TaskItem) \n• TotalCount (int) \n• CompletedCount (int) \nCommands \n• AddTaskCommand \nUse [ObservableProperty] and [RelayCommand] attributes where applicable. \n \n8. XAML Requirements \n• Bind Entry.Text using TwoWay binding \n• Bind Button.Command to ViewModel command \n• Use CollectionView for task list \n• Bind CheckBox.IsChecked using TwoWay binding \n• Use a Value Converter to apply strikethrough to completed tasks \n• Use MultiBinding for summary text \n• Use x:Reference at least once \n \n9. Suggested Lab Steps \n1. Create a new .NET MAUI project",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "2. Install CommunityToolkit.Mvvm \n3. Create the model class \n4. Create the ViewModel \n5. Design the UI in XAML \n6. Apply required bindings \n7. Test UI behavior \n \n10. Assessment Rubric (10 Marks) \nCriteria Marks \nCorrect MVVM structure 2 \nProper use of binding modes 3 \nCommand implementation 2 \nConverter & MultiBinding 2 \nUI completeness & clarity 1 \n \n11. Submission Requirements \nStudents must submit: \n• Source code folder or Git repository \n• Screenshot of running application \n \n12. Notes \n• Code-behind should be minimal or empty \n• Focus on binding correctness, not UI aesthetics \n• Naming conventions and clean structure are required \n \nEnd of Lab",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-24 14:39:22",
    "avatar_path": null,
    "final_video_path": null
  },
  "59d41985-84f2-4769-bd06-53ab2395ebf9": {
    "id": "59d41985-84f2-4769-bd06-53ab2395ebf9",
    "filename": "Maui_Xaml_Binding_Lab_Handout.pdf",
    "file_path": "static/uploads/presentations\\59d41985-84f2-4769-bd06-53ab2395ebf9\\Maui_Xaml_Binding_Lab_Handout.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "LAB HANDOUT \nMAUI XAML Binding Practice with CommunityToolkit.Mvvm \n \nCourse / Module \nMobile Application Development (.NET MAUI) \nLab Title \nTask Manager – XAML Data Binding & MVVM Toolkit \nDuration \n3 hours (180 minutes) \nLab Type \nIndividual – Hands-on Practice \n \n1. Lab Objectives \nAfter completing this lab, students will be able to: \n• Explain the purpose of data binding in .NET MAUI \n• Apply MVVM pattern using CommunityToolkit.Mvvm \n• Correctly use common binding modes in XAML \n• Bind UI elements to ViewModel properties and commands \n• Use converters and MultiBinding in real UI scenarios \n \n2. Software & Tools \n• Visual Studio 2022 or later \n• .NET MAUI workload installed \n• NuGet package: \no CommunityToolkit.Mvvm",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "3. Problem Description \nYou are required to build a single-screen Task Manager application using .NET MAUI \n(XAML). \nThe application allows users to: - Enter a task name - Add the task to a list - Mark tasks as \ncompleted - View task statistics (total and completed) \n    Constraints - No navigation between pages - No database or API - No code-\nbehind logic for UI behavior - All interactions must be implemented using data \nbinding and commands \n \n4. User Interface Specification \nMain Screen Components \n1. Application title: MY TASKS \n2. Text input for new task \n3. Add button \n4. Task list (CollectionView) \n5. Checkbox for task completion \n6. Summary section displaying: \no Total tasks \no Completed tasks \n \n5. Required Binding Types \nYour solution must demonstrate the following bindings: \nNo Binding Type Required Usage \n1 OneWay Display task title \n2 TwoWay Entry ↔ ViewModel property \n3 OneWayToSource Selected task \n4 Command Add task action \n5 RelativeSource Access ViewModel from item template \n6 x:Reference UI-to-UI binding \n7 Converter Completed task text style \n8 MultiBinding Summary text \n9 ObservableCollection Auto-update task list \n10 INotifyPropertyChanged ViewModel updates",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "6. Data Model \nCreate a TaskItem model that contains: \n• Title (string) \n• IsCompleted (bool) \nThe model must inherit from ObservableObject. \n \n7. ViewModel Requirements \nCreate TasksViewModel with the following: \nProperties \n• NewTaskTitle (string) \n• Tasks (ObservableCollection) \n• SelectedTask (TaskItem) \n• TotalCount (int) \n• CompletedCount (int) \nCommands \n• AddTaskCommand \nUse [ObservableProperty] and [RelayCommand] attributes where applicable. \n \n8. XAML Requirements \n• Bind Entry.Text using TwoWay binding \n• Bind Button.Command to ViewModel command \n• Use CollectionView for task list \n• Bind CheckBox.IsChecked using TwoWay binding \n• Use a Value Converter to apply strikethrough to completed tasks \n• Use MultiBinding for summary text \n• Use x:Reference at least once \n \n9. Suggested Lab Steps \n1. Create a new .NET MAUI project",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "2. Install CommunityToolkit.Mvvm \n3. Create the model class \n4. Create the ViewModel \n5. Design the UI in XAML \n6. Apply required bindings \n7. Test UI behavior \n \n10. Assessment Rubric (10 Marks) \nCriteria Marks \nCorrect MVVM structure 2 \nProper use of binding modes 3 \nCommand implementation 2 \nConverter & MultiBinding 2 \nUI completeness & clarity 1 \n \n11. Submission Requirements \nStudents must submit: \n• Source code folder or Git repository \n• Screenshot of running application \n \n12. Notes \n• Code-behind should be minimal or empty \n• Focus on binding correctness, not UI aesthetics \n• Naming conventions and clean structure are required \n \nEnd of Lab",
        "notes": "",
        "total_slides": 4,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-24 15:03:57",
    "avatar_path": null,
    "final_video_path": null
  },
  "c98460a9-7aa0-4c5e-837a-5286874379ad": {
    "id": "c98460a9-7aa0-4c5e-837a-5286874379ad",
    "filename": "Maui_Xaml_Binding_Lab_Handout.pdf",
    "file_path": "static/uploads/presentations\\c98460a9-7aa0-4c5e-837a-5286874379ad\\Maui_Xaml_Binding_Lab_Handout.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "LAB HANDOUT \nMAUI XAML Binding Practice with CommunityToolkit.Mvvm \n \nCourse / Module \nMobile Application Development (.NET MAUI) \nLab Title \nTask Manager – XAML Data Binding & MVVM Toolkit \nDuration \n3 hours (180 minutes) \nLab Type \nIndividual – Hands-on Practice \n \n1. Lab Objectives \nAfter completing this lab, students will be able to: \n• Explain the purpose of data binding in .NET MAUI \n• Apply MVVM pattern using CommunityToolkit.Mvvm \n• Correctly use common binding modes in XAML \n• Bind UI elements to ViewModel properties and commands \n• Use converters and MultiBinding in real UI scenarios \n \n2. Software & Tools \n• Visual Studio 2022 or later \n• .NET MAUI workload installed \n• NuGet package: \no CommunityToolkit.Mvvm",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Chào mừng các bạn đến với buổi thực hành hôm nay! Trong khuôn khổ môn Phát triển Ứng dụng Di động với .NET MAUI, chúng ta sẽ đi sâu vào một phần cực kỳ quan trọng và thiết yếu khi xây dựng các ứng dụng di động hiện đại: đó là Data Binding và mô hình MVVM.\n\nBuổi lab của chúng ta có tên là \"Task Manager – XAML Data Binding & MVVM Toolkit\". Đúng như tên gọi, chúng ta sẽ cùng nhau xây dựng một ứng dụng quản lý tác vụ cơ bản, nơi mà mọi logic và dữ liệu đều được quản lý một cách hiệu quả thông qua các kỹ thuật binding và kiến trúc MVVM. Đây là một buổi thực hành cá nhân kéo dài 3 tiếng, tập trung hoàn toàn vào thực hành trực tiếp, giúp các bạn có cái nhìn sâu sắc và kỹ năng thực tiễn.\n\nVậy sau 3 giờ thực hành này, chúng ta sẽ đạt được những gì?\n\nĐầu tiên, các bạn sẽ hiểu rõ **mục đích thực sự của Data Binding** trong .NET MAUI. Tại sao chúng ta cần nó? Nó giúp tách biệt UI và logic, làm cho code của chúng ta sạch hơn, dễ bảo trì hơn, và quan trọng nhất là tạo ra các ứng dụng phản hồi mượt mà hơn với dữ liệu.\n\nTiếp theo, chúng ta sẽ áp dụng **mô hình MVVM** – Model-View-ViewModel – một kiến trúc đã quá quen thuộc và hiệu quả trong phát triển ứng dụng UI. Đặc biệt, chúng ta sẽ sử dụng **CommunityToolkit.Mvvm**. Đây là một thư viện NuGet rất mạnh mẽ, giúp chúng ta triển khai MVVM một cách dễ dàng và hiệu quả hơn rất nhiều, giảm bớt boilerplate code.\n\nCác bạn cũng sẽ học cách sử dụng các **chế độ binding phổ biến trong XAML** một cách chính xác, từ OneWay, TwoWay cho đến OneTime. Chúng ta sẽ thực hành liên kết các phần tử UI như TextBox, Button với các thuộc tính và lệnh (Commands) trong ViewModel.\n\nVà để làm cho ứng dụng của chúng ta linh hoạt hơn, chúng ta sẽ khám phá cách dùng các **converters** để biến đổi dữ liệu, hoặc sử dụng **MultiBinding** để kết hợp nhiều nguồn dữ liệu khác nhau vào một UI element duy nhất. Tất cả đều là những tình huống thực tế mà bạn sẽ gặp trong quá trình phát triển ứng dụng.\n\nVề mặt công cụ, để buổi lab diễn ra suôn sẻ, các bạn chỉ cần đảm bảo máy tính của mình đã cài đặt Visual Studio 2022 trở lên, có workload .NET MAUI và đã thêm gói NuGet CommunityToolkit.Mvvm vào project của mình.\n\nHy vọng với buổi thực hành này, các bạn sẽ không chỉ nắm vững lý thuyết mà còn có thể tự tin áp dụng Data Binding và MVVM vào các dự án MAUI của mình. Đây là những kỹ năng nền tảng cực kỳ giá trị để xây dựng các ứng dụng di động hiện đại. Bây giờ, chúng ta hãy cùng bắt đầu nhé!",
        "edited_text": "Chào mừng các bạn đến với buổi thực hành hôm nay! Trong khuôn khổ môn Phát triển Ứng dụng Di động với .NET MAUI, chúng ta sẽ đi sâu vào một phần cực kỳ quan trọng và thiết yếu khi xây dựng các ứng dụng di động hiện đại: đó là Data Binding và mô hình MVVM.\n\nBuổi lab của chúng ta có tên là \"Task Manager – XAML Data Binding & MVVM Toolkit\". Đúng như tên gọi, chúng ta sẽ cùng nhau xây dựng một ứng dụng quản lý tác vụ cơ bản, nơi mà mọi logic và dữ liệu đều được quản lý một cách hiệu quả thông qua các kỹ thuật binding và kiến trúc MVVM. Đây là một buổi thực hành cá nhân kéo dài 3 tiếng, tập trung hoàn toàn vào thực hành trực tiếp, giúp các bạn có cái nhìn sâu sắc và kỹ năng thực tiễn.\n\nVậy sau 3 giờ thực hành này, chúng ta sẽ đạt được những gì?\n\nĐầu tiên, các bạn sẽ hiểu rõ **mục đích thực sự của Data Binding** trong .NET MAUI. Tại sao chúng ta cần nó? Nó giúp tách biệt UI và logic, làm cho code của chúng ta sạch hơn, dễ bảo trì hơn, và quan trọng nhất là tạo ra các ứng dụng phản hồi mượt mà hơn với dữ liệu.\n\nTiếp theo, chúng ta sẽ áp dụng **mô hình MVVM** – Model-View-ViewModel – một kiến trúc đã quá quen thuộc và hiệu quả trong phát triển ứng dụng UI. Đặc biệt, chúng ta sẽ sử dụng **CommunityToolkit.Mvvm**. Đây là một thư viện NuGet rất mạnh mẽ, giúp chúng ta triển khai MVVM một cách dễ dàng và hiệu quả hơn rất nhiều, giảm bớt boilerplate code.\n\nCác bạn cũng sẽ học cách sử dụng các **chế độ binding phổ biến trong XAML** một cách chính xác, từ OneWay, TwoWay cho đến OneTime. Chúng ta sẽ thực hành liên kết các phần tử UI như TextBox, Button với các thuộc tính và lệnh (Commands) trong ViewModel.\n\nVà để làm cho ứng dụng của chúng ta linh hoạt hơn, chúng ta sẽ khám phá cách dùng các **converters** để biến đổi dữ liệu, hoặc sử dụng **MultiBinding** để kết hợp nhiều nguồn dữ liệu khác nhau vào một UI element duy nhất. Tất cả đều là những tình huống thực tế mà bạn sẽ gặp trong quá trình phát triển ứng dụng.\n\nVề mặt công cụ, để buổi lab diễn ra suôn sẻ, các bạn chỉ cần đảm bảo máy tính của mình đã cài đặt Visual Studio 2022 trở lên, có workload .NET MAUI và đã thêm gói NuGet CommunityToolkit.Mvvm vào project của mình.\n\nHy vọng với buổi thực hành này, các bạn sẽ không chỉ nắm vững lý thuyết mà còn có thể tự tin áp dụng Data Binding và MVVM vào các dự án MAUI của mình. Đây là những kỹ năng nền tảng cực kỳ giá trị để xây dựng các ứng dụng di động hiện đại. Bây giờ, chúng ta hãy cùng bắt đầu nhé!",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "3. Problem Description \nYou are required to build a single-screen Task Manager application using .NET MAUI \n(XAML). \nThe application allows users to: - Enter a task name - Add the task to a list - Mark tasks as \ncompleted - View task statistics (total and completed) \n    Constraints - No navigation between pages - No database or API - No code-\nbehind logic for UI behavior - All interactions must be implemented using data \nbinding and commands \n \n4. User Interface Specification \nMain Screen Components \n1. Application title: MY TASKS \n2. Text input for new task \n3. Add button \n4. Task list (CollectionView) \n5. Checkbox for task completion \n6. Summary section displaying: \no Total tasks \no Completed tasks \n \n5. Required Binding Types \nYour solution must demonstrate the following bindings: \nNo Binding Type Required Usage \n1 OneWay Display task title \n2 TwoWay Entry ↔ ViewModel property \n3 OneWayToSource Selected task \n4 Command Add task action \n5 RelativeSource Access ViewModel from item template \n6 x:Reference UI-to-UI binding \n7 Converter Completed task text style \n8 MultiBinding Summary text \n9 ObservableCollection Auto-update task list \n10 INotifyPropertyChanged ViewModel updates",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Chào mọi người, hôm nay chúng ta sẽ cùng tìm hiểu về một dự án thú vị: xây dựng ứng dụng quản lý tác vụ (Task Manager) sử dụng .NET MAUI.\n\nMục tiêu của chúng ta là tạo ra một ứng dụng chỉ trên một màn hình duy nhất, nơi người dùng có thể thực hiện mọi thao tác quản lý công việc của mình. Cụ thể, người dùng có thể dễ dàng nhập tên một công việc mới, thêm nó vào danh sách, đánh dấu khi công việc đó hoàn thành, và theo dõi các số liệu thống kê cơ bản như tổng số công việc và số công việc đã hoàn thành.\n\nTuy nhiên, điểm thú vị và cũng là thử thách lớn nhất nằm ở các ràng buộc của dự án này. Đầu tiên, như đã nói, chúng ta không có chuyển trang, mọi thứ diễn ra trên một màn hình. Thứ hai, không sử dụng database hay API bên ngoài – tất cả dữ liệu sẽ được xử lý trong bộ nhớ của ứng dụng. Và quan trọng nhất, để đảm bảo tính minh bạch và dễ bảo trì, chúng ta *không được phép* viết bất kỳ logic xử lý UI nào trong phần code-behind của XAML. Thay vào đó, tất cả các tương tác người dùng phải được triển khai thông qua cơ chế data binding và commands.\n\nĐể đáp ứng các yêu cầu này, giao diện người dùng của chúng ta được thiết kế rất trực quan và đơn giản. Màn hình chính sẽ có tiêu đề rõ ràng là \"MY TASKS\". Phía trên cùng là một ô nhập liệu để người dùng gõ tên công việc mới, và ngay bên cạnh là nút \"Thêm\" để đưa công việc đó vào danh sách. Phần trung tâm sẽ là danh sách các công việc, hiển thị dưới dạng CollectionView. Mỗi công việc trong danh sách sẽ đi kèm một checkbox để người dùng dễ dàng đánh dấu hoàn thành. Cuối cùng, ở phần dưới cùng của màn hình, chúng ta sẽ có một khu vực tóm tắt, hiển thị tổng số công việc và số lượng công việc đã hoàn thành, giúp người dùng nắm bắt tình hình chung một cách nhanh chóng.\n\nĐể hiện thực hóa tất cả các tương tác này mà không cần dùng code-behind, chúng ta sẽ tận dụng triệt để các kiểu Data Binding khác nhau trong .NET MAUI. Ví dụ, kiểu `OneWay` sẽ giúp hiển thị tiêu đề công việc một chiều từ ViewModel ra UI. Kiểu `TwoWay` sẽ cực kỳ hữu ích cho ô nhập liệu, đảm bảo dữ liệu luôn được đồng bộ hai chiều giữa giao diện và ViewModel. Các nút bấm như \"Thêm\" sẽ được xử lý bằng `Command` binding, giúp tách rời logic hành động khỏi UI.\n\nTrong danh sách công việc, chúng ta sẽ cần đến `RelativeSource` để truy cập ViewModel từ bên trong item template, hoặc `x:Reference` để liên kết các thành phần UI với nhau trực tiếp. Để làm cho phần tóm tắt trở nên sống động, chúng ta sẽ dùng `MultiBinding` để kết hợp nhiều giá trị thành một chuỗi hiển thị duy nhất, và `Converter` để thay đổi phong cách hiển thị của văn bản, ví dụ như gạch ngang những công việc đã hoàn thành. Cuối cùng, để danh sách công việc tự động cập nhật mỗi khi có thay đổi, chúng ta sẽ sử dụng `ObservableCollection`, và ViewModel của chúng ta sẽ triển khai interface `INotifyPropertyChanged` để thông báo cho UI biết khi có bất kỳ thuộc tính nào thay đổi.\n\nTóm lại, mặc dù chỉ là một ứng dụng đơn màn hình, dự án này yêu cầu chúng ta phải có sự hiểu biết sâu sắc về các cơ chế Data Binding và MVVM trong .NET MAUI để xây dựng một giải pháp sạch sẽ, hiệu quả và dễ bảo trì.",
        "edited_text": "Chào mọi người, hôm nay chúng ta sẽ cùng tìm hiểu về một dự án thú vị: xây dựng ứng dụng quản lý tác vụ (Task Manager) sử dụng .NET MAUI.\n\nMục tiêu của chúng ta là tạo ra một ứng dụng chỉ trên một màn hình duy nhất, nơi người dùng có thể thực hiện mọi thao tác quản lý công việc của mình. Cụ thể, người dùng có thể dễ dàng nhập tên một công việc mới, thêm nó vào danh sách, đánh dấu khi công việc đó hoàn thành, và theo dõi các số liệu thống kê cơ bản như tổng số công việc và số công việc đã hoàn thành.\n\nTuy nhiên, điểm thú vị và cũng là thử thách lớn nhất nằm ở các ràng buộc của dự án này. Đầu tiên, như đã nói, chúng ta không có chuyển trang, mọi thứ diễn ra trên một màn hình. Thứ hai, không sử dụng database hay API bên ngoài – tất cả dữ liệu sẽ được xử lý trong bộ nhớ của ứng dụng. Và quan trọng nhất, để đảm bảo tính minh bạch và dễ bảo trì, chúng ta *không được phép* viết bất kỳ logic xử lý UI nào trong phần code-behind của XAML. Thay vào đó, tất cả các tương tác người dùng phải được triển khai thông qua cơ chế data binding và commands.\n\nĐể đáp ứng các yêu cầu này, giao diện người dùng của chúng ta được thiết kế rất trực quan và đơn giản. Màn hình chính sẽ có tiêu đề rõ ràng là \"MY TASKS\". Phía trên cùng là một ô nhập liệu để người dùng gõ tên công việc mới, và ngay bên cạnh là nút \"Thêm\" để đưa công việc đó vào danh sách. Phần trung tâm sẽ là danh sách các công việc, hiển thị dưới dạng CollectionView. Mỗi công việc trong danh sách sẽ đi kèm một checkbox để người dùng dễ dàng đánh dấu hoàn thành. Cuối cùng, ở phần dưới cùng của màn hình, chúng ta sẽ có một khu vực tóm tắt, hiển thị tổng số công việc và số lượng công việc đã hoàn thành, giúp người dùng nắm bắt tình hình chung một cách nhanh chóng.\n\nĐể hiện thực hóa tất cả các tương tác này mà không cần dùng code-behind, chúng ta sẽ tận dụng triệt để các kiểu Data Binding khác nhau trong .NET MAUI. Ví dụ, kiểu `OneWay` sẽ giúp hiển thị tiêu đề công việc một chiều từ ViewModel ra UI. Kiểu `TwoWay` sẽ cực kỳ hữu ích cho ô nhập liệu, đảm bảo dữ liệu luôn được đồng bộ hai chiều giữa giao diện và ViewModel. Các nút bấm như \"Thêm\" sẽ được xử lý bằng `Command` binding, giúp tách rời logic hành động khỏi UI.\n\nTrong danh sách công việc, chúng ta sẽ cần đến `RelativeSource` để truy cập ViewModel từ bên trong item template, hoặc `x:Reference` để liên kết các thành phần UI với nhau trực tiếp. Để làm cho phần tóm tắt trở nên sống động, chúng ta sẽ dùng `MultiBinding` để kết hợp nhiều giá trị thành một chuỗi hiển thị duy nhất, và `Converter` để thay đổi phong cách hiển thị của văn bản, ví dụ như gạch ngang những công việc đã hoàn thành. Cuối cùng, để danh sách công việc tự động cập nhật mỗi khi có thay đổi, chúng ta sẽ sử dụng `ObservableCollection`, và ViewModel của chúng ta sẽ triển khai interface `INotifyPropertyChanged` để thông báo cho UI biết khi có bất kỳ thuộc tính nào thay đổi.\n\nTóm lại, mặc dù chỉ là một ứng dụng đơn màn hình, dự án này yêu cầu chúng ta phải có sự hiểu biết sâu sắc về các cơ chế Data Binding và MVVM trong .NET MAUI để xây dựng một giải pháp sạch sẽ, hiệu quả và dễ bảo trì.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "6. Data Model \nCreate a TaskItem model that contains: \n• Title (string) \n• IsCompleted (bool) \nThe model must inherit from ObservableObject. \n \n7. ViewModel Requirements \nCreate TasksViewModel with the following: \nProperties \n• NewTaskTitle (string) \n• Tasks (ObservableCollection) \n• SelectedTask (TaskItem) \n• TotalCount (int) \n• CompletedCount (int) \nCommands \n• AddTaskCommand \nUse [ObservableProperty] and [RelayCommand] attributes where applicable. \n \n8. XAML Requirements \n• Bind Entry.Text using TwoWay binding \n• Bind Button.Command to ViewModel command \n• Use CollectionView for task list \n• Bind CheckBox.IsChecked using TwoWay binding \n• Use a Value Converter to apply strikethrough to completed tasks \n• Use MultiBinding for summary text \n• Use x:Reference at least once \n \n9. Suggested Lab Steps \n1. Create a new .NET MAUI project",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Chào mừng quý vị và các bạn,\n\nVâng, tiếp theo đây, chúng ta sẽ đi sâu hơn vào các yêu cầu kỹ thuật để xây dựng ứng dụng quản lý công việc của mình nhé. Đây là những khối cấu trúc quan trọng sẽ định hình cách ứng dụng của chúng ta hoạt động và tương tác.\n\nĐầu tiên là phần **Data Model**, hay còn gọi là mô hình dữ liệu. Chúng ta sẽ tạo một mô hình đơn giản tên là `TaskItem` để đại diện cho một công việc. Mỗi `TaskItem` sẽ có hai thuộc tính chính: `Title` – là một chuỗi để lưu tên công việc, và `IsCompleted` – một kiểu boolean để biết công việc đã hoàn thành hay chưa. Điều quan trọng ở đây là mô hình này phải kế thừa từ `ObservableObject`. Tại sao lại vậy? Bởi vì khi trạng thái của một công việc thay đổi – ví dụ, bạn đánh dấu nó là hoàn thành – thì giao diện người dùng cần phải tự động cập nhật mà không cần chúng ta phải viết quá nhiều code thủ công. `ObservableObject` chính là công cụ giúp chúng ta làm điều đó một cách hiệu quả.\n\nTiếp theo là trái tim của ứng dụng: **ViewModel** của chúng ta, cụ thể là `TasksViewModel`. ViewModel này sẽ chứa các thuộc tính để quản lý dữ liệu và trạng thái của giao diện. Chúng ta sẽ có `NewTaskTitle` để nhận đầu vào từ người dùng khi họ muốn thêm công việc mới. Một `ObservableCollection` tên là `Tasks` sẽ lưu trữ danh sách các công việc. `ObservableCollection` rất quan trọng vì nó sẽ tự động thông báo cho UI biết mỗi khi có công việc mới được thêm vào, xóa đi, hoặc thay đổi vị trí. Ngoài ra, chúng ta còn có `SelectedTask` để theo dõi công việc đang được chọn, và hai thuộc tính `TotalCount`, `CompletedCount` để hiển thị tóm tắt tổng số công việc và số công việc đã hoàn thành. Về các **Commands** (lệnh), chúng ta sẽ có `AddTaskCommand` để xử lý logic khi người dùng bấm nút thêm công việc. Để đơn giản hóa việc viết code MVVM, chúng ta sẽ tận dụng các thuộc tính `[ObservableProperty]` và `[RelayCommand]` từ MAUI Community Toolkit. Chúng giúp giảm bớt lượng code 'lặp lại' mà vẫn đảm bảo tính năng thông báo thay đổi và thực thi lệnh một cách hiệu quả.\n\nBây giờ đến phần giao diện, hay còn gọi là **XAML Requirements**. Đây là nơi chúng ta kết nối UI với ViewModel. Chúng ta sẽ sử dụng TwoWay binding cho `Entry.Text` để đảm bảo dữ liệu nhập vào từ ô văn bản có thể đi vào ViewModel và ngược lại. Tương tự, `CheckBox.IsChecked` cũng sẽ dùng TwoWay binding để cập nhật trạng thái hoàn thành của công việc. Để hiển thị danh sách công việc, chúng ta sẽ dùng `CollectionView`, một control hiện đại và mạnh mẽ hơn ListView truyền thống. Một điểm nhấn thú vị là chúng ta sẽ dùng một **Value Converter** để tạo hiệu ứng gạch ngang cho các công việc đã hoàn thành, giúp người dùng dễ dàng nhận biết. Và để hiển thị văn bản tóm tắt như \"Tổng số: X, Đã hoàn thành: Y\", chúng ta sẽ cần đến **MultiBinding** để kết hợp nhiều thuộc tính từ ViewModel vào một chuỗi văn bản duy nhất. Cuối cùng, chúng ta cũng sẽ áp dụng `x:Reference` ít nhất một lần để thực hành việc tham chiếu giữa các control trong XAML.\n\nTất nhiên, để bắt đầu tất cả những điều này, bước đầu tiên rất đơn giản: chỉ cần **tạo một dự án .NET MAUI mới**. Đó là nền tảng để chúng ta bắt đầu xây dựng mọi thứ.\n\nĐó là tổng quan về các yêu cầu chính cho mô hình dữ liệu, ViewModel và giao diện người dùng. Khi kết hợp các yếu tố này lại, chúng ta sẽ có một ứng dụng quản lý công việc hoạt động mượt mà và hiệu quả.",
        "edited_text": "Chào mừng quý vị và các bạn,\n\nVâng, tiếp theo đây, chúng ta sẽ đi sâu hơn vào các yêu cầu kỹ thuật để xây dựng ứng dụng quản lý công việc của mình nhé. Đây là những khối cấu trúc quan trọng sẽ định hình cách ứng dụng của chúng ta hoạt động và tương tác.\n\nĐầu tiên là phần **Data Model**, hay còn gọi là mô hình dữ liệu. Chúng ta sẽ tạo một mô hình đơn giản tên là `TaskItem` để đại diện cho một công việc. Mỗi `TaskItem` sẽ có hai thuộc tính chính: `Title` – là một chuỗi để lưu tên công việc, và `IsCompleted` – một kiểu boolean để biết công việc đã hoàn thành hay chưa. Điều quan trọng ở đây là mô hình này phải kế thừa từ `ObservableObject`. Tại sao lại vậy? Bởi vì khi trạng thái của một công việc thay đổi – ví dụ, bạn đánh dấu nó là hoàn thành – thì giao diện người dùng cần phải tự động cập nhật mà không cần chúng ta phải viết quá nhiều code thủ công. `ObservableObject` chính là công cụ giúp chúng ta làm điều đó một cách hiệu quả.\n\nTiếp theo là trái tim của ứng dụng: **ViewModel** của chúng ta, cụ thể là `TasksViewModel`. ViewModel này sẽ chứa các thuộc tính để quản lý dữ liệu và trạng thái của giao diện. Chúng ta sẽ có `NewTaskTitle` để nhận đầu vào từ người dùng khi họ muốn thêm công việc mới. Một `ObservableCollection` tên là `Tasks` sẽ lưu trữ danh sách các công việc. `ObservableCollection` rất quan trọng vì nó sẽ tự động thông báo cho UI biết mỗi khi có công việc mới được thêm vào, xóa đi, hoặc thay đổi vị trí. Ngoài ra, chúng ta còn có `SelectedTask` để theo dõi công việc đang được chọn, và hai thuộc tính `TotalCount`, `CompletedCount` để hiển thị tóm tắt tổng số công việc và số công việc đã hoàn thành. Về các **Commands** (lệnh), chúng ta sẽ có `AddTaskCommand` để xử lý logic khi người dùng bấm nút thêm công việc. Để đơn giản hóa việc viết code MVVM, chúng ta sẽ tận dụng các thuộc tính `[ObservableProperty]` và `[RelayCommand]` từ MAUI Community Toolkit. Chúng giúp giảm bớt lượng code 'lặp lại' mà vẫn đảm bảo tính năng thông báo thay đổi và thực thi lệnh một cách hiệu quả.\n\nBây giờ đến phần giao diện, hay còn gọi là **XAML Requirements**. Đây là nơi chúng ta kết nối UI với ViewModel. Chúng ta sẽ sử dụng TwoWay binding cho `Entry.Text` để đảm bảo dữ liệu nhập vào từ ô văn bản có thể đi vào ViewModel và ngược lại. Tương tự, `CheckBox.IsChecked` cũng sẽ dùng TwoWay binding để cập nhật trạng thái hoàn thành của công việc. Để hiển thị danh sách công việc, chúng ta sẽ dùng `CollectionView`, một control hiện đại và mạnh mẽ hơn ListView truyền thống. Một điểm nhấn thú vị là chúng ta sẽ dùng một **Value Converter** để tạo hiệu ứng gạch ngang cho các công việc đã hoàn thành, giúp người dùng dễ dàng nhận biết. Và để hiển thị văn bản tóm tắt như \"Tổng số: X, Đã hoàn thành: Y\", chúng ta sẽ cần đến **MultiBinding** để kết hợp nhiều thuộc tính từ ViewModel vào một chuỗi văn bản duy nhất. Cuối cùng, chúng ta cũng sẽ áp dụng `x:Reference` ít nhất một lần để thực hành việc tham chiếu giữa các control trong XAML.\n\nTất nhiên, để bắt đầu tất cả những điều này, bước đầu tiên rất đơn giản: chỉ cần **tạo một dự án .NET MAUI mới**. Đó là nền tảng để chúng ta bắt đầu xây dựng mọi thứ.\n\nĐó là tổng quan về các yêu cầu chính cho mô hình dữ liệu, ViewModel và giao diện người dùng. Khi kết hợp các yếu tố này lại, chúng ta sẽ có một ứng dụng quản lý công việc hoạt động mượt mà và hiệu quả.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "2. Install CommunityToolkit.Mvvm \n3. Create the model class \n4. Create the ViewModel \n5. Design the UI in XAML \n6. Apply required bindings \n7. Test UI behavior \n \n10. Assessment Rubric (10 Marks) \nCriteria Marks \nCorrect MVVM structure 2 \nProper use of binding modes 3 \nCommand implementation 2 \nConverter & MultiBinding 2 \nUI completeness & clarity 1 \n \n11. Submission Requirements \nStudents must submit: \n• Source code folder or Git repository \n• Screenshot of running application \n \n12. Notes \n• Code-behind should be minimal or empty \n• Focus on binding correctness, not UI aesthetics \n• Naming conventions and clean structure are required \n \nEnd of Lab",
        "notes": "",
        "total_slides": 4,
        "generated_text": "Chào mừng các bạn đến với buổi hướng dẫn bài lab hôm nay! Chúng ta sẽ cùng nhau điểm qua các bước thực hiện, cũng như những tiêu chí quan trọng để hoàn thành bài tập một cách tốt nhất.\n\nĐầu tiên, để bắt đầu dự án, các bạn hãy **cài đặt thư viện CommunityToolkit.Mvvm** – đây sẽ là nền tảng giúp chúng ta triển khai mô hình MVVM một cách hiệu quả.\n\nTiếp theo, chúng ta sẽ lần lượt **tạo các lớp Model và ViewModel**. Hãy nhớ rằng Model dùng để biểu diễn dữ liệu, còn ViewModel sẽ là nơi chứa logic nghiệp vụ và phơi bày dữ liệu cho giao diện người dùng. Sau khi có Model và ViewModel, các bạn sẽ **thiết kế giao diện người dùng (UI) trong XAML**. Đây là lúc để biến ý tưởng của mình thành hình ảnh.\n\nVà một trong những bước quan trọng nhất chính là **áp dụng các binding cần thiết**. Việc này sẽ giúp UI và ViewModel của chúng ta 'nói chuyện' với nhau, đảm bảo dữ liệu luôn được đồng bộ. Cuối cùng, đừng quên **kiểm tra kỹ lưỡng hành vi của UI** để đảm bảo mọi chức năng đều hoạt động đúng như mong đợi.\n\nBây giờ, hãy nói một chút về cách bài lab này sẽ được đánh giá. Chúng ta có tổng cộng 10 điểm, và đây là những tiêu chí cụ thể:\n\nĐầu tiên là **cấu trúc MVVM chính xác (2 điểm)**. Điều này rất quan trọng vì nó thể hiện sự hiểu biết của các bạn về việc tách biệt các mối quan tâm trong ứng dụng. Kế đến, **việc sử dụng đúng các chế độ binding (3 điểm)** chiếm tỷ trọng cao nhất. Hãy cân nhắc kỹ xem khi nào thì dùng OneWay, TwoWay hay OneTime để đảm bảo luồng dữ liệu hiệu quả.\n\nTiếp theo, **cách các bạn triển khai Command (2 điểm)** cũng sẽ được chấm điểm. Command giúp chúng ta xử lý các hành động từ UI mà không cần can thiệp vào code-behind. Ngoài ra, **việc sử dụng Converter và MultiBinding (2 điểm)** cũng là một điểm cộng lớn, cho thấy các bạn có thể xử lý các tình huống binding phức tạp hơn. Và cuối cùng, **tính đầy đủ và rõ ràng của UI (1 điểm)**. Không cần quá cầu kỳ về mặt thẩm mỹ, nhưng UI cần phải thể hiện đủ các thành phần chức năng được yêu cầu.\n\nVề yêu cầu nộp bài, các bạn cần gửi hai thứ: Thứ nhất là **toàn bộ thư mục mã nguồn hoặc link đến kho Git repository** của các bạn. Và thứ hai là một **ảnh chụp màn hình (screenshot) của ứng dụng đang chạy** để chúng tôi dễ dàng kiểm tra kết quả.\n\nCuối cùng, một vài lưu ý nhỏ nhưng rất quan trọng để bài làm của các bạn đạt chất lượng cao:\n\nHãy cố gắng giữ cho **code-behind của các bạn ở mức tối thiểu hoặc hoàn toàn trống**. Đây là một trong những mục tiêu chính khi chúng ta dùng MVVM. Thứ hai, hãy **tập trung vào tính đúng đắn của binding chứ không phải yếu tố thẩm mỹ của UI**. Điều quan trọng là chức năng hoạt động. Và đừng quên, việc **tuân thủ các quy ước đặt tên và giữ cho cấu trúc dự án gọn gàng, sạch sẽ** luôn được đánh giá cao, vì nó thể hiện sự chuyên nghiệp trong cách làm việc.\n\nĐó là toàn bộ những hướng dẫn và lưu ý cho bài lab này. Chúc các bạn làm bài thật tốt và nếu có bất kỳ thắc mắc nào, đừng ngần ngại hỏi nhé!",
        "edited_text": "Chào mừng các bạn đến với buổi hướng dẫn bài lab hôm nay! Chúng ta sẽ cùng nhau điểm qua các bước thực hiện, cũng như những tiêu chí quan trọng để hoàn thành bài tập một cách tốt nhất.\n\nĐầu tiên, để bắt đầu dự án, các bạn hãy **cài đặt thư viện CommunityToolkit.Mvvm** – đây sẽ là nền tảng giúp chúng ta triển khai mô hình MVVM một cách hiệu quả.\n\nTiếp theo, chúng ta sẽ lần lượt **tạo các lớp Model và ViewModel**. Hãy nhớ rằng Model dùng để biểu diễn dữ liệu, còn ViewModel sẽ là nơi chứa logic nghiệp vụ và phơi bày dữ liệu cho giao diện người dùng. Sau khi có Model và ViewModel, các bạn sẽ **thiết kế giao diện người dùng (UI) trong XAML**. Đây là lúc để biến ý tưởng của mình thành hình ảnh.\n\nVà một trong những bước quan trọng nhất chính là **áp dụng các binding cần thiết**. Việc này sẽ giúp UI và ViewModel của chúng ta 'nói chuyện' với nhau, đảm bảo dữ liệu luôn được đồng bộ. Cuối cùng, đừng quên **kiểm tra kỹ lưỡng hành vi của UI** để đảm bảo mọi chức năng đều hoạt động đúng như mong đợi.\n\nBây giờ, hãy nói một chút về cách bài lab này sẽ được đánh giá. Chúng ta có tổng cộng 10 điểm, và đây là những tiêu chí cụ thể:\n\nĐầu tiên là **cấu trúc MVVM chính xác (2 điểm)**. Điều này rất quan trọng vì nó thể hiện sự hiểu biết của các bạn về việc tách biệt các mối quan tâm trong ứng dụng. Kế đến, **việc sử dụng đúng các chế độ binding (3 điểm)** chiếm tỷ trọng cao nhất. Hãy cân nhắc kỹ xem khi nào thì dùng OneWay, TwoWay hay OneTime để đảm bảo luồng dữ liệu hiệu quả.\n\nTiếp theo, **cách các bạn triển khai Command (2 điểm)** cũng sẽ được chấm điểm. Command giúp chúng ta xử lý các hành động từ UI mà không cần can thiệp vào code-behind. Ngoài ra, **việc sử dụng Converter và MultiBinding (2 điểm)** cũng là một điểm cộng lớn, cho thấy các bạn có thể xử lý các tình huống binding phức tạp hơn. Và cuối cùng, **tính đầy đủ và rõ ràng của UI (1 điểm)**. Không cần quá cầu kỳ về mặt thẩm mỹ, nhưng UI cần phải thể hiện đủ các thành phần chức năng được yêu cầu.\n\nVề yêu cầu nộp bài, các bạn cần gửi hai thứ: Thứ nhất là **toàn bộ thư mục mã nguồn hoặc link đến kho Git repository** của các bạn. Và thứ hai là một **ảnh chụp màn hình (screenshot) của ứng dụng đang chạy** để chúng tôi dễ dàng kiểm tra kết quả.\n\nCuối cùng, một vài lưu ý nhỏ nhưng rất quan trọng để bài làm của các bạn đạt chất lượng cao:\n\nHãy cố gắng giữ cho **code-behind của các bạn ở mức tối thiểu hoặc hoàn toàn trống**. Đây là một trong những mục tiêu chính khi chúng ta dùng MVVM. Thứ hai, hãy **tập trung vào tính đúng đắn của binding chứ không phải yếu tố thẩm mỹ của UI**. Điều quan trọng là chức năng hoạt động. Và đừng quên, việc **tuân thủ các quy ước đặt tên và giữ cho cấu trúc dự án gọn gàng, sạch sẽ** luôn được đánh giá cao, vì nó thể hiện sự chuyên nghiệp trong cách làm việc.\n\nĐó là toàn bộ những hướng dẫn và lưu ý cho bài lab này. Chúc các bạn làm bài thật tốt và nếu có bất kỳ thắc mắc nào, đừng ngần ngại hỏi nhé!",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-24 15:06:27",
    "avatar_path": null,
    "final_video_path": null
  },
  "3e609cb1-e938-4b15-ba5b-e4145086a81e": {
    "id": "3e609cb1-e938-4b15-ba5b-e4145086a81e",
    "filename": "CHUONG_6_DAN_TOC.pptx",
    "file_path": "static/uploads/presentations\\5f39ee09-b261-4fb4-a88d-ee11f075067e\\CHUONG_6_DAN_TOC.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Chương 6\u000bVẤN ĐỀ DÂN TỘC VÀ TÔN GIÁO \nTRONG THỜI KỲ QUÁ ĐỘ \nLÊN CHỦ NGHĨA XÃ HỘI\nGiảng viên: ThS. Đặng Thị Kim Dung",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "1. Dân tộc trong thời kỳ quá độ lên chủ nghĩa xã hội",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "NỘI DUNG BÀI",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Dân tộc quốc gia\n(Nation)",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "ĐẶC TRƯNG CỦA DÂN TỘC",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "ĐẶC TRƯNG \u000bCỦA DÂN TỘC\nKHÔNG GIAN SINH TỒN\nVỊ TRÍ ĐỊA LÝ CỦA DÂN TỘC\nTHỂ HIỆN \nCHỦ QUYỀN CỦA MỘT DÂN TỘC",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "ĐẶC TRƯNG \u000bCỦA DÂN TỘC\nMối quan hệ kinh tế là nền tảng cho sự vững chắc của cộng đồng dân tộc",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "ĐẶC TRƯNG \u000bCỦA DÂN TỘC",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Bản sắc riêng của từng dân tộc\nVăn hóa của các cộng đồng\n tộc người trong một quốc gia\nĐẶC TRƯNG \u000bCỦA DÂN TỘC",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Đây là yếu tố phân biệt dân tộc – quốc gia và dân tộc – tộc người\nNhà nước là đặc trưng cho thể chế chính trị của dân tộc\nĐẶC TRƯNG \u000bCỦA DÂN TỘC",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Khái niệm dân tộc\nDân tộc tộc người (ethnie)",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Đặc trưng Dân tộc – tộc người",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "1.2. Chủ nghĩa Mác – Lênin về vấn đề dân tộc\n1.2.1. Hai xu hướng khách quan của sự phát triển quan hệ dân tộc\n1.2.2. Cương lĩnh dân tộc của chủ nghĩa Mác - Lênin",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Xu hướng thứ nhất\u000bCộng đồng dân cư muốn tách ra \u000bhình thành cộng đồng dân tộc độc lập\nNguyên nhân\nThức tỉnh, trưởng thành về ý thức dân tộc\nQuyền sống của mình\nCác cộng đồng dân cư tách ra thành lập các dân tộc độc lập",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Xu hướng thứ nhất\u000bCộng đồng dân cư muốn tách ra hình thành cộng đồng dân tộc độc lập",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Xu hướng thứ hai\u000bCác dân tộc trong từng quốc gia, dân tộc ở nhiều quốc gia liên hiệp lại\nNguyên nhân\nChủ nghĩa đế quốc đi \nxâm lược các nước thuộc địa",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "NATO (4/4/1949)\nKhối quấn sự Bắc Đại Tây Dương",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Xu hướng thứ hai\u000bCác dân tộc trong từng quốc gia, dân tộc ở nhiều quốc gia liên hiệp lại\nNguyên nhân\nChủ nghĩa đế quốc đi \nxâm lược các nước thuộc địa\nDo sự phát triển của lực lượng sản xuất",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "BIỂU HIỆN CỦA HAI XU HƯỚNG KHÁCH QUAN TRONG PHÁT TRIỂN QUAN HỆ DÂN TỘC TRONG GIAI ĐOẠN HIỆN NAY\nTHẢO LUẬN",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Đôngtimore tách khỏi Inđônêxia 5/2002\nNam Ossetia tách khỏi Gruzia sau sự kiện 8/2008",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Kôsôvô\ntách khỏi Sécbia\n17/2/2008\nNgười dân Kôsôvô \nhân hoan nhân ngày độc lập",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Biểu hiện xu hướng liên hiệp lại giữa \ncác dân tộc trong giai đoạn hiện nay",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "EU\nLiên minh Châu Âu\nASEAN – Hiệp hội các quốc gia ĐNÁ\nUAE\nTiểu vương quốc Ả rập thống nhất",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "1.2.3. Cương lĩnh dân tộc của chủ nghĩa Mác - Lênin",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Quyền thiêng liêng \ncủa các \ndân tộc",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Bình đẳng giữa các dân tộc trong một quốc gia",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "BÌNH ĐẲNG TRONG HIẾN PHÁP VÀ THỰC TIỄN",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Bình đẳng giữa các \nquốc gia\nChống chủ nghĩa \nphân biệt chủng tộc,\n bá quyền",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "HIỆN NAY CÁC\n QUỐC GIA DÂN TỘC TRÊN THẾ GIỚI ĐÃ BÌNH ĐẲNG CHƯA? TẠI SAO?",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Trung Quốc với mưu đồ chiếm biển Đông\nẢnh chụp trên cao cho thấy Trung Quốc đang đẩy mạnh xây dựng trên đảo Phú Lâm thuộc quần đảo Hoàng Sa",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "“Bảo đảm lợi ích tối cao của quốc gia – dân tộc, trên cơ sở các nguyên tắc cơ bản của luật pháp quốc tế, bình đẳng và cùng có lợi, thực hiện nhất quán đường lối đối ngoại độc lập, tự chủ, hòa bình, hợp tác và phát triển”\nĐảng cộng sản Việt Nam: Văn kiện đại hội đại biểu toàn quốc lần thứ XII, HN, 2016, tr.153.",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 36,
        "content": "",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 37,
        "content": "Quyền làm chủ        \n        Quyền tự quyết định con đường phát triển                     \n        Quyền tự do phân lập và quyền tự nguyện liên hiệp",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 38,
        "content": "Sau thất bại mô hình CNXH ở các nước Đông Âu và Liên Xô năm 1991\nĐặt ra yêu cầu gì\n đối với việc lựa chọn \ncon đường phát triển ở Việt Nam \nvà các nước XHCN?",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 39,
        "content": "Đường lối đổi mới từ năm 1986",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 40,
        "content": "Kinh tế thị trường định hướng XHCN\nTăng trưởng kinh tế",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 41,
        "content": "",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 42,
        "content": "Phân tích \u000bvụ việc\u000b Kích động thành lập “Vương quốc Mông” \u000bở Mường Nhé, \u000bĐiện Biên",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 43,
        "content": "CÁC DÂN TỘC \nĐƯỢC QUYỀN TỰ QUYẾT\nQUYỀN ĐƯỢC PHÂN LẬP VÀ \nLIÊN HIỆP \nTHAM GIA \nTỔ CHỨC QUỐC TẾ\nĐỨNG TRÊN QUAN ĐIỂM CNDVLS \nVÀ LẬP TRƯỜNG GIAI CẤP \nCÔNG NHÂN",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 44,
        "content": "Liên hiệp công nhân tất cả các dân tộc\nPhản ánh sự thống nhất giữa giải phóng dân tộc, giải phóng giai cấp\nPhản ánh sự gắn bó tinh thần của CN yêu nước và CN quốc tế chân chinh\nLà cơ sở để đoan kết các tầng lớp nhân dân lao động",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 45,
        "content": "Giá trị lịch sử của Cương lĩnh và việc tiếp thu, vận dụng ở Việt Nam\n- Nêu rõ chính sách của Quốc tế Cộng sản về vấn đề dân tộc và thuộc địa.\n- Động lực to lớn với phong trào giải phóng dân tộc ở các nước thuộc địa.\n- Chủ tịch Hồ Chí Minh đã tiếp thu, vận dụng sáng tạo để giải quyết đúng đắn quan hệ giai cấp - dân tộc, dân tộc, quốc tế ở nước ta.",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 46,
        "content": "1.3. Dân tộc và quan hệ dân tộc ở Việt Nam\n1.3.1. Đặc điểm dân tộc Việt Nam",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 47,
        "content": "1.3.2. Quan điểm, chính sách của Đảng và Nhà nước ta về vấn đề dân tộc và công tác dân tộc trong thời kỳ mới\nNội dung đối nội của chính sách dân tộc\n+ Bình đẳng giữa các dân tộc\n+ Đoàn kết các dân tộc.\n+ Tương trợ nhau cùng phát triển.\nNội dung đối ngoại của chính sách dân tộc\n+ Thực hiện quan hệ dân tộc trên tinh thần độc lập tự chủ, mở rộng, đa phương hóa các quan hệ quốc tế. Việt Nam sẵn sàng là bạn, là đối tác tin cậy của các nước trong cộng đồng quốc tế, phấn đấu vì hòa bình, độc lập và phát triển.",
        "notes": "",
        "total_slides": 47,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-28 15:10:35",
    "avatar_path": null,
    "final_video_path": null
  },
  "866a9b9c-e768-44e1-8b8a-dd471dae5022": {
    "id": "866a9b9c-e768-44e1-8b8a-dd471dae5022",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/8f62a5c6-4a0b-4263-b11e-1c05afec02d9/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 15:28:24",
    "avatar_path": null,
    "final_video_path": null
  },
  "d6ad2e2b-458f-405c-a70d-a8951dfd8ceb": {
    "id": "d6ad2e2b-458f-405c-a70d-a8951dfd8ceb",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/ae125ccc-47db-4ed3-9d9b-3df330694f71/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 16:05:45",
    "avatar_path": null,
    "final_video_path": null
  },
  "78131c65-e6af-4757-a4a9-cba2f48f79b0": {
    "id": "78131c65-e6af-4757-a4a9-cba2f48f79b0",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/cf04d0b3-a4f0-43f2-b3b9-24e2efbfc0ab/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 16:06:07",
    "avatar_path": null,
    "final_video_path": null
  },
  "12ec0b2e-10bc-482c-b9a4-63705091a1b5": {
    "id": "12ec0b2e-10bc-482c-b9a4-63705091a1b5",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/57a06e11-9365-4800-98cd-34524f6a169d/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 18:29:54",
    "avatar_path": null,
    "final_video_path": null
  },
  "ad0a346d-d3f9-4b7c-84a7-dafb9e52919e": {
    "id": "ad0a346d-d3f9-4b7c-84a7-dafb9e52919e",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/4c84b539-6d71-4504-a651-5769c30daf68/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 18:48:11",
    "avatar_path": null,
    "final_video_path": null
  },
  "f7e5affb-d423-479a-8960-160ff3bcc24c": {
    "id": "f7e5affb-d423-479a-8960-160ff3bcc24c",
    "filename": "ORAL_EXAM_DESIGN.pdf",
    "file_path": "static/uploads/presentations/8ebb5afa-1f16-487e-a3e5-00a12af66a9c/ORAL_EXAM_DESIGN.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "ORAL EXAM DESIGN \n.NET MAUI – XAML UI & Data Binding (CommunityToolkit.Mvvm) \n \n1. Exam Overview \nExam Type: Practical + Oral Examination \nFormat: Team-based (2 students / team) \nNumber of Teams: 13 teams \nTotal Duration per Team: 2 hours 10 minutes \n• Part 1: Practical UI Project – 2 hours \n• Part 2: Oral Examination – 10 minutes \n \n2. Exam Objectives \nThis oral exam aims to assess students’ ability to: \n• Design UI layouts using XAML in .NET MAUI \n• Correctly apply data binding techniques \n• Implement MVVM pattern using CommunityToolkit.Mvvm \n• Explain and justify technical decisions verbally \n• Demonstrate individual understanding within a team project \n \n3. Allowed Resources \n• Visual Studio 2022 or later \n• .NET MAUI project template \n• Internet access for documentation only \n• NuGet package: CommunityToolkit.Mvvm \n  No pre-written project code allowed \n \n4. Part 1 – Practical Project (2 Hours) \nGeneral Requirements (All Teams) \nEach team must build a single-screen MAUI application with: \n• UI designed in XAML \n• MVVM architecture \n• At least 4 different binding techniques",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "• No navigation between pages \n• No database or API \n \nMandatory Binding Techniques \nEach project must demonstrate: \n1. TwoWay Binding (Entry ↔ ViewModel) \n2. OneWay Binding (Display data) \n3. Command Binding (Button actions) \n4. ObservableCollection Binding (List update) \nAt least ONE advanced binding: \n• Converter \n• MultiBinding \n• RelativeSource \n• x:Reference \n \n5. Personalized Project Topics (14 Teams) \nEach team receives one unique UI scenario to prevent copying while keeping difficulty \nequivalent. \nTeam Assignments \nTeam Project Theme \n1 Grocery Shopping List \n2 Daily Habit Tracker \n3 Student Attendance UI \n4 Expense Tracker (UI only) \n5 Book Reading Tracker \n6 Workout Session Planner \n7 Movie Watchlist \n8 Meeting Agenda Manager \n9 Event Checklist",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Team Project Theme \n10 Smart Home Device Panel \n11 Plant Care Reminder UI \n12 Simple Note Organizer \n13 Classroom Equipment Checklist \nAll projects must follow the same technical constraints, only the UI content differs. \n \n6. Minimum Feature Set (Example) \nEach project should include: \n• Title header \n• Input section (Entry) \n• Action button(s) \n• List display (CollectionView) \n• Status indicator (Label / CheckBox / Switch) \n• Summary section (count, status, or description) \n \n7. Part 2 – Oral Examination (10 Minutes) \nStructure \n• 5 minutes: Project demonstration \n• 5 minutes: Oral questions (individual) \nBoth students must answer questions. \n \n8. Oral Question Bank (Examiner Chooses) \nUI & XAML (Basic) \n• Why did you choose Grid instead of StackLayout? \n• Explain the role of CollectionView in your UI. \nData Binding \n• Explain the difference between OneWay and TwoWay binding. \n• Why is ObservableCollection required? \nMVVM & Toolkit",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "• What problem does CommunityToolkit.Mvvm solve? \n• Explain [ObservableProperty] and [RelayCommand]. \nAdvanced Binding (If Used) \n• Why did you use a converter here? \n• Explain how MultiBinding works in your project. \n \n9. Individual Assessment Strategy \nTo ensure fairness: \n• Examiner asks different questions to each student \n• Each student must explain at least one binding used \n• Examiner may ask one student to modify a binding verbally \n \n10. Grading Rubric (20 Marks) \nPractical Project – 12 Marks \nCriteria Marks \nUI layout correctness 3 \nCorrect binding usage 4 \nMVVM structure 3 \nCode clarity & organization 2 \nOral Examination – 8 Marks \nCriteria Marks \nExplanation of bindings 3 \nMVVM understanding 2 \nIndividual contribution 2 \nCommunication clarity 1 \n \n11. Examiner Notes \n• Focus on understanding, not memorization \n• Penalize code-behind logic",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "• Encourage students to explain design decisions \n• Each team having a team leader, using GitHub to store the project, branch then merge \nfor the final submission \n• Each team must have a brainstorming for the project (visualation using any mindmap \napplication), checkin along with code.  \n \n12. Expected Learning Outcomes \nAfter the exam, students should be able to: \n• Design MAUI UI using XAML confidently \n• Apply data binding correctly \n• Explain MVVM principles verbally \n• Read and reason about XAML code \n \nEnd of Oral Exam Design",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 18:55:51",
    "avatar_path": null,
    "final_video_path": null
  },
  "7b71aa40-651c-41d0-827a-34f2c9917498": {
    "id": "7b71aa40-651c-41d0-827a-34f2c9917498",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/06072422-3657-4968-aeb0-da7fba4912c4/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 19:13:44",
    "avatar_path": null,
    "final_video_path": null
  },
  "6e24eafa-5c61-494b-aa01-1d5b55ade761": {
    "id": "6e24eafa-5c61-494b-aa01-1d5b55ade761",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/6e24eafa-5c61-494b-aa01-1d5b55ade761/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 19:28:10",
    "avatar_path": null,
    "final_video_path": null
  },
  "9fa47167-f1b8-4ad2-a84b-932d471a7221": {
    "id": "9fa47167-f1b8-4ad2-a84b-932d471a7221",
    "filename": "2.c._GoF_Design_Patterns_-_Structural.pptx",
    "file_path": "static/uploads/presentations/9fa47167-f1b8-4ad2-a84b-932d471a7221/2.c._GoF_Design_Patterns_-_Structural.pptx",
    "type": ".pptx",
    "slides": [
      {
        "slide_num": 1,
        "content": "Structural Design Patterns\nGof design patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "Overview\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Core Role\nStructural design patterns focus on how classes and objects are composed to form larger structures while keeping those structures flexible, reusable, and easy to evolve.\nThey answer the question: How should we organize classes and objects so that changes in one part of the system have minimal impact on others?\nKey Responsibilities\nDecouple components: Reduce direct dependencies between classes.\nReuse existing code: Integrate legacy or third-party components without modification.\nManage complexity: Provide simpler abstractions over complex subsystems.\nExtend behavior without inheritance explosion: Favor composition over inheritance.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "Chào mừng quý vị. Hôm nay chúng ta sẽ cùng tìm hiểu về vai trò cốt lõi của các mẫu thiết kế cấu trúc trong lập trình.\n\nCác mẫu thiết kế cấu trúc tập trung vào cách chúng ta kết hợp các lớp và đối tượng để tạo thành những cấu trúc lớn hơn, đồng thời đảm bảo rằng các cấu trúc này luôn linh hoạt, dễ tái sử dụng và dễ phát triển theo thời gian. Nói cách khác, chúng trả lời một câu hỏi then chốt: Làm thế nào để chúng ta tổ chức các lớp và đối tượng một cách hiệu quả, sao cho khi có thay đổi ở một phần của hệ thống, tác động lên các phần khác là tối thiểu nhất?\n\nĐể đạt được những mục tiêu đó, các mẫu thiết kế cấu trúc đảm nhiệm một số trách nhiệm chính.\n\nĐầu tiên, chúng giúp tách rời các thành phần. Điều này có nghĩa là giảm sự phụ thuộc trực tiếp giữa các lớp, làm cho hệ thống của chúng ta trở nên mạnh mẽ và dễ bảo trì hơn.\n\nThứ hai, chúng thúc đẩy việc tái sử dụng mã nguồn hiện có. Chúng ta có thể tích hợp các thành phần hệ thống cũ hoặc thư viện của bên thứ ba vào hệ thống của mình mà không cần phải sửa đổi mã gốc của chúng.\n\nThứ ba, các mẫu này hỗ trợ quản lý sự phức tạp. Bằng cách cung cấp các lớp trừu tượng đơn giản hơn, chúng ta có thể che giấu đi sự phức tạp bên trong của các hệ thống con, giúp dễ dàng làm việc hơn.\n\nVà cuối cùng, chúng cho phép chúng ta mở rộng hành vi mà không gây ra tình trạng \"bùng nổ kế thừa\". Thay vì tạo ra quá nhiều lớp con, chúng ta sẽ ưu tiên sử dụng phương pháp thành phần hóa hơn là kế thừa để đạt được sự linh hoạt và khả năng mở rộng mong muốn.",
        "edited_text": "\nCác mẫu thiết kế cấu trúc tập trung vào cách chúng ta kết hợp các lớp và đối tượng để tạo thành những cấu trúc lớn hơn, đồng thời đảm bảo rằng các cấu trúc này luôn linh hoạt, dễ tái sử dụng và dễ phát triển theo thời gian. Nói cách khác, chúng trả lời một câu hỏi then chốt: Làm thế nào để chúng ta tổ chức các lớp và đối tượng một cách hiệu quả, sao cho khi có thay đổi ở một phần của hệ thống, tác động lên các phần khác là tối thiểu nhất?\n\nĐể đạt được những mục tiêu đó, các mẫu thiết kế cấu trúc đảm nhiệm một số trách nhiệm chính.\n\nĐầu tiên, chúng giúp tách rời các thành phần. Điều này có nghĩa là giảm sự phụ thuộc trực tiếp giữa các lớp, làm cho hệ thống của chúng ta trở nên mạnh mẽ và dễ bảo trì hơn.\n\nThứ hai, chúng thúc đẩy việc tái sử dụng mã nguồn hiện có. Chúng ta có thể tích hợp các thành phần hệ thống cũ hoặc thư viện của bên thứ ba vào hệ thống của mình mà không cần phải sửa đổi mã gốc của chúng.\n\nThứ ba, các mẫu này hỗ trợ quản lý sự phức tạp. Bằng cách cung cấp các lớp trừu tượng đơn giản hơn, chúng ta có thể che giấu đi sự phức tạp bên trong của các hệ thống con, giúp dễ dàng làm việc hơn.\n\nVà cuối cùng, chúng cho phép chúng ta mở rộng hành vi mà không gây ra tình trạng \"bùng nổ kế thừa\". Thay vì tạo ra quá nhiều lớp con, chúng ta sẽ ưu tiên sử dụng phương pháp thành phần hóa hơn là kế thừa để đạt được sự linh hoạt và khả năng mở rộng mong muốn.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "Problems and Impact\nTypical Problems They Address\nA class interface does not match what the client expects.\nA subsystem is too complex to be used directly.\nObjects need to be combined into tree-like structures.\nFunctionality must be added dynamically without modifying existing code.\nTypical Impact on Design\nMore stable class structures\nClearer layer boundaries\nImproved maintainability and testability\nStrong alignment with SOLID principles, especially:\nOpen–Closed Principle (OCP)\nDependency Inversion Principle (DIP)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "Quick Classification View",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 6,
        "content": "",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 7,
        "content": "Popularity Ranking of Structural Patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 8,
        "content": "Important Insight",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 9,
        "content": "Summary\nStructural patterns help students:\n Think in terms of architecture and layering\n Understand composition over inheritance\n Structural thinking → How the system is built\n How should objects be connected?",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 10,
        "content": "Decorator pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 11,
        "content": "Intent\nDecorator lets you add responsibilities/behavior to an object dynamically (at runtime) by wrapping it in another object that implements the same interface.\nIt answers: How can we extend behavior without modifying existing code (OCP), and without creating many subclasses?\nSymptoms:\nYou need combinations like: Logging + Caching + Validation + Retry + Metrics\nIf you use inheritance, you quickly get a “class explosion”: LoggingService, CachingService, LoggingCachingService, CachingRetryService, etc.\nWhy Decorator is better:\nEach feature is a small wrapper (single responsibility).\nYou can compose features in any order: Retry(Logging(Caching(RealService)))",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 12,
        "content": "Decorator vs SRP\nDecorator itself does not violate SRP, but overusing or misusing decorators absolutely can.\nThe Decorator pattern was designed to support SRP, not break it.\nProper usage:\nLoggingDecorator → changes when logging rules change\nCachingDecorator → changes when caching strategy changes\nValidationDecorator → changes when validation rules change\nEach decorator:\nHas one concern\nWraps another object\nDelegates everything else\nWhere SRP gets violated\nAnti-pattern 1: “Multi-purpose decorator”\nMultiple independent reasons to change\nBecomes a “mini god class”\nHard to test and reason about\nAnti-pattern 2: Decorator that owns business logic\nBusiness rules ≠ cross-cutting concern\nDomain changes force decorator changes\nDecorator becomes a hidden domain service",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 13,
        "content": "Decorator responsibilities\nGood decorator responsibilities:\nLogging\nCaching\nRetry\nTimeout\nAuthorization checks\nMetrics / tracing\nBad decorator responsibilities:\nBusiness decision rules\nDomain state transitions\nWorkflow orchestration\nEntity invariants\nIf a decorator starts making business decisions, it’s no longer a decorator.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 14,
        "content": "Bridge pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 15,
        "content": "Intent\nBridge decouples an abstraction from its implementation so that the two can vary independently.\nTypical dimensions:\n What the object is (abstraction hierarchy)\n How it is implemented (implementation hierarchy)\nImagine you have:\nDimension A — “What”: Notifications\nBasic Notification\nUrgent Notification\nDimension B — “How”: Channels\nEmail\nSMS\nPush",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 16,
        "content": "Problem - Solution\nWithout Bridge, you might create:\nBasicEmailNotification\nBasicSmsNotification\nBasicPushNotification\nUrgentEmailNotification\nUrgentSmsNotification\nUrgentPushNotification\nIf both dimensions grow, the number of classes grows as A × B (multiplicative explosion)\nBridge turns this into:\nA small hierarchy for abstraction\nA small hierarchy for implementation\nConnected via composition (a “bridge” reference)\nThe combination of “how” and “what” is decided by client code, instead of “hard wired class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 17,
        "content": "Bridge in modern .NET\nYou often see Bridge thinking in:\nStorage abstraction vs providers\u000bIStorage + AzureBlobStorage, S3Storage, LocalStorage\nRendering abstraction vs engines\u000bIChart + SvgRenderer, CanvasRenderer\nMessaging abstraction vs transports\u000bIMessageBus + RabbitMqTransport, KafkaTransport, InMemoryTransport\nDI can help wire them, but Bridge is about designing for two dimensions of change.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 18,
        "content": "Composite pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 19,
        "content": "Intent and Core Idea\nIntent\nCompose objects into tree structures to represent part–whole hierarchies.\nAllow clients to treat individual objects and compositions of objects uniformly.\nComposite is about treating “one” and “many” the same way.\nCore Idea\nBoth simple objects and complex objects share the same interface.\nA complex object contains a collection of objects that follow that same interface.\nOperations are applied recursively through the structure.\nProblem It Solves\nYou have a hierarchical structure (tree-like).\nYou want client code to ignore whether it is working with:\na single object (leaf)\nor a group of objects (composite)\nWithout this pattern, client code would need many conditional checks.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 20,
        "content": "Key Participants\nComponent\nDefines the common interface for all objects in the structure.\nDeclares operations that apply to both simple and complex objects.\nLeaf\nRepresents an individual object.\nImplements the component interface directly.\nHas no children.\nComposite\nRepresents a group of components.\nStores child components.\nImplements operations by delegating them to its children.\nClient\nWorks only with the component interface.\nDoes not need to distinguish between leaf and composite.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 21,
        "content": "Structural Characteristics\nStructural Characteristics\nForms a recursive tree structure.\nParent and child objects are of the same abstract type.\nSupports unlimited nesting depth.\nEmphasizes uniformity over strict type distinction.\nHow Operations Work\nClient calls an operation on a component.\nIf the component is a leaf:\nThe operation executes directly.\nIf the component is a composite:\nThe operation is forwarded to each child.\nResults may be aggregated or combined.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 22,
        "content": "Typical Use Cases\nFile systems (files and folders).\nGUI components (buttons, panels, windows).\nOrganization structures (employees, departments).\nProduct bundles and individual products.\nMathematical expressions (numbers and operators).",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 23,
        "content": "Benefits and Trade-offs\nBenefits\nSimplifies client code.\nEncourages open-ended extensibility.\nNaturally models recursive hierarchies.\nAligns well with polymorphism.\nReduces conditional logic.\nTrade-offs and Limitations\nCan make the design too general.\nDifficult to enforce constraints on what children a composite can have.\nLeaves and composites may be forced to support operations they do not logically need.\nDebugging recursive behavior can be harder.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 24,
        "content": "Facade pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 25,
        "content": "Intent\nProvide a single, simplified interface to a complex subsystem so clients can use it easily without needing to understand internal details.\nFacade is the architectural idea of organizing multiple collaborating operations—aimed at a specific goal—into a single class that exposes a high-level interface, while preserving OCP and DIP.\nFacade provides a single, high-level interface to a set of related operations, encapsulating a use-case-level workflow while keeping clients decoupled from subsystem complexity.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 26,
        "content": "What Facade really groups\nFacade is not just grouping random methods.\nIt groups:\n A workflow (a sequence of steps)\n A use case (a business or application-level intention)\n Coordination logic, not domain logic\nExample intentions:\nRegister a student to a course\nPlace an order\nProcess a payment\nPublish a report\nThis is why Facade methods are usually:\nCoarse-grained\nVerb-oriented\nUse-case driven",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 27,
        "content": "Facade is not “just a Service class”",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 28,
        "content": "Adapter pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 29,
        "content": "Intent\nAdapter converts the interface of a class into another interface that a client expects.\nIt answers: How can I reuse an existing/third-party/legacy class when its API doesn’t match what my code needs—without modifying that class?\nCommon triggers\nYou integrate a third-party library but its method names/parameters/types don’t match your domain.\nYou have legacy code that you cannot change.\nYou want your application to depend on a stable interface while allowing multiple providers.\nTypical symptoms\nLots of mapping code scattered across clients (client has to remember how to call the library).\nClients become coupled to vendor/SDK types.\nSwitching providers later becomes painful.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 30,
        "content": "Examples\nYour app wants a clean interface:\nIPaymentGateway.Charge(decimal amount, string currency, string customerId)\nThe legacy SDK instead provides:\nMakePayment(int cents, string isoCurrency, string accountRef)\nReturns a vendor-specific LegacyResult\nWe create an Adapter to translate between them.\nReal-world .NET uses\nWrapping an external SDK behind your own interface:\nIEmailSender over SendGrid/MailKit\nIStorage over S3/Azure Blob/Local FS\nIPaymentGateway over Stripe/PayPal\nMapping external DTOs to domain models (sometimes this is a “mapping adapter”)",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 31,
        "content": "Structure (conceptual)\nTarget: the interface your application expects (e.g., IPaymentGateway)\nClient: uses the Target interface\nAdaptee: existing/third-party class with incompatible API (e.g., LegacyPaySdk)\nAdapter: implements Target and wraps Adaptee, translating calls/data",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 32,
        "content": "Proxy Pattern\nStructural patterns",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 33,
        "content": "Intent\nProxy provides a stand-in (surrogate) object that controls access to a real object.\nIt answers: How can I add access control, lazy loading, caching, remote communication, or logging around an object without changing the object and while keeping the same interface for clients?\nKey point:\nClient talks to the Proxy\nProxy talks to the Real Subject\nBoth share the same interface",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 34,
        "content": "Common proxy purposes\nVirtual Proxy (Lazy Loading)\u000bDelay creation/loading of an expensive object until it’s actually needed.\nProtection Proxy (Access Control / Authorization)\u000bCheck permissions before allowing operations.\nRemote Proxy\u000bRepresent an object located in another process/server.\nCaching Proxy\u000bCache results to avoid repeated expensive calls.\nLogging/Monitoring Proxy\u000bRecord calls, timings, failures.\nNote: caching/logging here can also be done using Decorator; the difference is intent (Proxy is “control access”, Decorator is “add responsibility”). In real systems, they can look similar.",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 35,
        "content": "Proxy structure\nSubject: interface (e.g., IReportService)\nRealSubject: actual implementation (e.g., ReportService)\nProxy: implements the same interface and holds a reference to RealSubject, controlling access",
        "notes": "",
        "total_slides": 35,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-30 19:35:03",
    "avatar_path": null,
    "final_video_path": null
  },
  "ae072861-7035-46b7-bdcc-0ede241b9f4d": {
    "id": "ae072861-7035-46b7-bdcc-0ede241b9f4d",
    "filename": "ORAL_EXAM_DESIGN.pdf",
    "file_path": "static/uploads/presentations/ae072861-7035-46b7-bdcc-0ede241b9f4d/ORAL_EXAM_DESIGN.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "ORAL EXAM DESIGN \n.NET MAUI – XAML UI & Data Binding (CommunityToolkit.Mvvm) \n \n1. Exam Overview \nExam Type: Practical + Oral Examination \nFormat: Team-based (2 students / team) \nNumber of Teams: 13 teams \nTotal Duration per Team: 2 hours 10 minutes \n• Part 1: Practical UI Project – 2 hours \n• Part 2: Oral Examination – 10 minutes \n \n2. Exam Objectives \nThis oral exam aims to assess students’ ability to: \n• Design UI layouts using XAML in .NET MAUI \n• Correctly apply data binding techniques \n• Implement MVVM pattern using CommunityToolkit.Mvvm \n• Explain and justify technical decisions verbally \n• Demonstrate individual understanding within a team project \n \n3. Allowed Resources \n• Visual Studio 2022 or later \n• .NET MAUI project template \n• Internet access for documentation only \n• NuGet package: CommunityToolkit.Mvvm \n  No pre-written project code allowed \n \n4. Part 1 – Practical Project (2 Hours) \nGeneral Requirements (All Teams) \nEach team must build a single-screen MAUI application with: \n• UI designed in XAML \n• MVVM architecture \n• At least 4 different binding techniques",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Xin chào quý vị và các bạn. Hôm nay, chúng ta sẽ cùng tìm hiểu về thiết kế bài thi vấn đáp môn .NET MAUI, tập trung vào việc xây dựng giao diện người dùng bằng XAML và kỹ thuật ràng buộc dữ liệu, đặc biệt là việc sử dụng CommunityToolkit.Mvvm.\n\nĐầu tiên, hãy cùng nhìn vào tổng quan về bài thi. Đây là một bài kiểm tra kết hợp giữa thực hành và vấn đáp. Bài thi sẽ được tổ chức theo hình thức làm việc nhóm, mỗi nhóm gồm hai sinh viên. Chúng ta sẽ có tổng cộng mười ba nhóm tham gia. Tổng thời lượng cho mỗi đội là hai giờ mười phút, được chia thành hai phần rõ rệt. Phần một là dự án giao diện người dùng thực hành, kéo dài hai giờ đồng hồ. Tiếp theo, phần hai sẽ là phần vấn đáp, diễn ra trong mười phút.\n\nVậy, mục tiêu của bài thi vấn đáp này là gì? Chúng tôi mong muốn đánh giá khả năng của sinh viên trong việc thiết kế bố cục giao diện người dùng bằng XAML trong .NET MAUI. Đồng thời, bài thi cũng kiểm tra việc các bạn áp dụng đúng các kỹ thuật ràng buộc dữ liệu, triển khai mô hình MVVM sử dụng CommunityToolkit.Mvvm. Hơn nữa, sinh viên cần có khả năng giải thích và bảo vệ các quyết định kỹ thuật của mình một cách rõ ràng bằng lời nói, và quan trọng nhất là thể hiện sự hiểu biết cá nhân trong khuôn khổ một dự án nhóm.\n\nVề tài nguyên được phép sử dụng trong quá trình thi, các bạn có thể dùng Visual Studio 2022 hoặc phiên bản mới hơn, cùng với mẫu dự án .NET MAUI. Đáng chú ý là quyền truy cập internet chỉ được phép để tra cứu tài liệu, không dùng cho bất kỳ mục đích nào khác. Các bạn cũng được phép sử dụng gói NuGet CommunityToolkit.Mvvm. Tuy nhiên, xin lưu ý rằng không được sử dụng bất kỳ mã nguồn dự án nào đã được viết sẵn từ trước.\n\nCuối cùng, hãy đi sâu hơn vào phần một – dự án thực hành kéo dài hai giờ. Các yêu cầu chung cho tất cả các nhóm là mỗi nhóm phải xây dựng một ứng dụng MAUI chỉ với một màn hình. Ứng dụng này cần có giao diện người dùng được thiết kế bằng XAML, tuân thủ kiến trúc MVVM và phải áp dụng ít nhất bốn kỹ thuật ràng buộc dữ liệu khác nhau.\n\nĐó là những thông tin tổng quan về thiết kế bài thi vấn đáp. Chúc các bạn ôn tập tốt và đạt kết quả cao.",
        "edited_text": "Xin chào quý vị và các bạn. Hôm nay, chúng ta sẽ cùng tìm hiểu về thiết kế bài thi vấn đáp môn .NET MAUI, tập trung vào việc xây dựng giao diện người dùng bằng XAML và kỹ thuật ràng buộc dữ liệu, đặc biệt là việc sử dụng CommunityToolkit.Mvvm.\n\nĐầu tiên, hãy cùng nhìn vào tổng quan về bài thi. Đây là một bài kiểm tra kết hợp giữa thực hành và vấn đáp. Bài thi sẽ được tổ chức theo hình thức làm việc nhóm, mỗi nhóm gồm hai sinh viên. Chúng ta sẽ có tổng cộng mười ba nhóm tham gia. Tổng thời lượng cho mỗi đội là hai giờ mười phút, được chia thành hai phần rõ rệt. Phần một là dự án giao diện người dùng thực hành, kéo dài hai giờ đồng hồ. Tiếp theo, phần hai sẽ là phần vấn đáp, diễn ra trong mười phút.\n\nVậy, mục tiêu của bài thi vấn đáp này là gì? Chúng tôi mong muốn đánh giá khả năng của sinh viên trong việc thiết kế bố cục giao diện người dùng bằng XAML trong .NET MAUI. Đồng thời, bài thi cũng kiểm tra việc các bạn áp dụng đúng các kỹ thuật ràng buộc dữ liệu, triển khai mô hình MVVM sử dụng CommunityToolkit.Mvvm. Hơn nữa, sinh viên cần có khả năng giải thích và bảo vệ các quyết định kỹ thuật của mình một cách rõ ràng bằng lời nói, và quan trọng nhất là thể hiện sự hiểu biết cá nhân trong khuôn khổ một dự án nhóm.\n\nVề tài nguyên được phép sử dụng trong quá trình thi, các bạn có thể dùng Visual Studio 2022 hoặc phiên bản mới hơn, cùng với mẫu dự án .NET MAUI. Đáng chú ý là quyền truy cập internet chỉ được phép để tra cứu tài liệu, không dùng cho bất kỳ mục đích nào khác. Các bạn cũng được phép sử dụng gói NuGet CommunityToolkit.Mvvm. Tuy nhiên, xin lưu ý rằng không được sử dụng bất kỳ mã nguồn dự án nào đã được viết sẵn từ trước.\n\nCuối cùng, hãy đi sâu hơn vào phần một – dự án thực hành kéo dài hai giờ. Các yêu cầu chung cho tất cả các nhóm là mỗi nhóm phải xây dựng một ứng dụng MAUI chỉ với một màn hình. Ứng dụng này cần có giao diện người dùng được thiết kế bằng XAML, tuân thủ kiến trúc MVVM và phải áp dụng ít nhất bốn kỹ thuật ràng buộc dữ liệu khác nhau.\n\nĐó là những thông tin tổng quan về thiết kế bài thi vấn đáp. Chúc các bạn ôn tập tốt và đạt kết quả cao.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "• No navigation between pages \n• No database or API \n \nMandatory Binding Techniques \nEach project must demonstrate: \n1. TwoWay Binding (Entry ↔ ViewModel) \n2. OneWay Binding (Display data) \n3. Command Binding (Button actions) \n4. ObservableCollection Binding (List update) \nAt least ONE advanced binding: \n• Converter \n• MultiBinding \n• RelativeSource \n• x:Reference \n \n5. Personalized Project Topics (14 Teams) \nEach team receives one unique UI scenario to prevent copying while keeping difficulty \nequivalent. \nTeam Assignments \nTeam Project Theme \n1 Grocery Shopping List \n2 Daily Habit Tracker \n3 Student Attendance UI \n4 Expense Tracker (UI only) \n5 Book Reading Tracker \n6 Workout Session Planner \n7 Movie Watchlist \n8 Meeting Agenda Manager \n9 Event Checklist",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Team Project Theme \n10 Smart Home Device Panel \n11 Plant Care Reminder UI \n12 Simple Note Organizer \n13 Classroom Equipment Checklist \nAll projects must follow the same technical constraints, only the UI content differs. \n \n6. Minimum Feature Set (Example) \nEach project should include: \n• Title header \n• Input section (Entry) \n• Action button(s) \n• List display (CollectionView) \n• Status indicator (Label / CheckBox / Switch) \n• Summary section (count, status, or description) \n \n7. Part 2 – Oral Examination (10 Minutes) \nStructure \n• 5 minutes: Project demonstration \n• 5 minutes: Oral questions (individual) \nBoth students must answer questions. \n \n8. Oral Question Bank (Examiner Chooses) \nUI & XAML (Basic) \n• Why did you choose Grid instead of StackLayout? \n• Explain the role of CollectionView in your UI. \nData Binding \n• Explain the difference between OneWay and TwoWay binding. \n• Why is ObservableCollection required? \nMVVM & Toolkit",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "• What problem does CommunityToolkit.Mvvm solve? \n• Explain [ObservableProperty] and [RelayCommand]. \nAdvanced Binding (If Used) \n• Why did you use a converter here? \n• Explain how MultiBinding works in your project. \n \n9. Individual Assessment Strategy \nTo ensure fairness: \n• Examiner asks different questions to each student \n• Each student must explain at least one binding used \n• Examiner may ask one student to modify a binding verbally \n \n10. Grading Rubric (20 Marks) \nPractical Project – 12 Marks \nCriteria Marks \nUI layout correctness 3 \nCorrect binding usage 4 \nMVVM structure 3 \nCode clarity & organization 2 \nOral Examination – 8 Marks \nCriteria Marks \nExplanation of bindings 3 \nMVVM understanding 2 \nIndividual contribution 2 \nCommunication clarity 1 \n \n11. Examiner Notes \n• Focus on understanding, not memorization \n• Penalize code-behind logic",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "• Encourage students to explain design decisions \n• Each team having a team leader, using GitHub to store the project, branch then merge \nfor the final submission \n• Each team must have a brainstorming for the project (visualation using any mindmap \napplication), checkin along with code.  \n \n12. Expected Learning Outcomes \nAfter the exam, students should be able to: \n• Design MAUI UI using XAML confidently \n• Apply data binding correctly \n• Explain MVVM principles verbally \n• Read and reason about XAML code \n \nEnd of Oral Exam Design",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-31 14:30:28",
    "avatar_path": null,
    "final_video_path": null
  },
  "88d59cdb-47ab-4d71-a2bb-d451197f728b": {
    "id": "88d59cdb-47ab-4d71-a2bb-d451197f728b",
    "filename": "ORAL_EXAM_DESIGN.pdf",
    "file_path": "static/uploads/presentations/88d59cdb-47ab-4d71-a2bb-d451197f728b/ORAL_EXAM_DESIGN.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "ORAL EXAM DESIGN \n.NET MAUI – XAML UI & Data Binding (CommunityToolkit.Mvvm) \n \n1. Exam Overview \nExam Type: Practical + Oral Examination \nFormat: Team-based (2 students / team) \nNumber of Teams: 13 teams \nTotal Duration per Team: 2 hours 10 minutes \n• Part 1: Practical UI Project – 2 hours \n• Part 2: Oral Examination – 10 minutes \n \n2. Exam Objectives \nThis oral exam aims to assess students’ ability to: \n• Design UI layouts using XAML in .NET MAUI \n• Correctly apply data binding techniques \n• Implement MVVM pattern using CommunityToolkit.Mvvm \n• Explain and justify technical decisions verbally \n• Demonstrate individual understanding within a team project \n \n3. Allowed Resources \n• Visual Studio 2022 or later \n• .NET MAUI project template \n• Internet access for documentation only \n• NuGet package: CommunityToolkit.Mvvm \n  No pre-written project code allowed \n \n4. Part 1 – Practical Project (2 Hours) \nGeneral Requirements (All Teams) \nEach team must build a single-screen MAUI application with: \n• UI designed in XAML \n• MVVM architecture \n• At least 4 different binding techniques",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning, everyone. Today, we're going to dive into the design and specifics of your upcoming oral examination. This assessment focuses squarely on your skills in .NET MAUI, particularly with XAML user interfaces and robust data binding, leveraging the Community Toolkit MVVM for architectural patterns.\n\nFirst, let's cover the exam overview. This will be a combined practical and oral examination, structured as a team-based project. Each team will consist of two students, and we anticipate a total of thirteen teams participating. The entire examination for each team is allocated two hours and ten minutes. This time is distinctly divided into two parts: a two-hour practical UI project, followed immediately by a ten-minute oral examination segment where you will present your work.\n\nMoving on to the objectives, this oral exam is designed to comprehensively assess several key abilities. We want to see your proficiency in designing user interface layouts using XAML within the .NET MAUI framework, your correct application of various data binding techniques, and your implementation of the MVVM pattern utilizing the Community Toolkit MVVM. Furthermore, you'll need to verbally explain and justify your technical decisions, and importantly, demonstrate your individual understanding even within the context of a team project.\n\nRegarding allowed resources, you'll have access to Visual Studio 2022 or a later version, the standard .NET MAUI project template, and internet access strictly for documentation purposes. You are also permitted to use the NuGet package Community Toolkit MVVM. A crucial point to remember is that no pre-written project code is allowed; you will be starting from a blank slate.\n\nFinally, let's detail Part One, the two-hour practical project. For this segment, every team must build a single-screen MAUI application. This application must feature a user interface designed entirely in XAML, adhere strictly to the MVVM architecture, and critically, incorporate at least four different data binding techniques. This ensures a comprehensive demonstration of your practical skills in a focused manner.",
        "edited_text": "Good morning, everyone. Today, we're going to dive into the design and specifics of your upcoming oral examination. This assessment focuses squarely on your skills in .NET MAUI, particularly with XAML user interfaces and robust data binding, leveraging the Community Toolkit MVVM for architectural patterns.\n\nFirst, let's cover the exam overview. This will be a combined practical and oral examination, structured as a team-based project. Each team will consist of two students, and we anticipate a total of thirteen teams participating. The entire examination for each team is allocated two hours and ten minutes. This time is distinctly divided into two parts: a two-hour practical UI project, followed immediately by a ten-minute oral examination segment where you will present your work.\n\nMoving on to the objectives, this oral exam is designed to comprehensively assess several key abilities. We want to see your proficiency in designing user interface layouts using XAML within the .NET MAUI framework, your correct application of various data binding techniques, and your implementation of the MVVM pattern utilizing the Community Toolkit MVVM. Furthermore, you'll need to verbally explain and justify your technical decisions, and importantly, demonstrate your individual understanding even within the context of a team project.\n\nRegarding allowed resources, you'll have access to Visual Studio 2022 or a later version, the standard .NET MAUI project template, and internet access strictly for documentation purposes. You are also permitted to use the NuGet package Community Toolkit MVVM. A crucial point to remember is that no pre-written project code is allowed; you will be starting from a blank slate.\n\nFinally, let's detail Part One, the two-hour practical project. For this segment, every team must build a single-screen MAUI application. This application must feature a user interface designed entirely in XAML, adhere strictly to the MVVM architecture, and critically, incorporate at least four different data binding techniques. This ensures a comprehensive demonstration of your practical skills in a focused manner.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "• No navigation between pages \n• No database or API \n \nMandatory Binding Techniques \nEach project must demonstrate: \n1. TwoWay Binding (Entry ↔ ViewModel) \n2. OneWay Binding (Display data) \n3. Command Binding (Button actions) \n4. ObservableCollection Binding (List update) \nAt least ONE advanced binding: \n• Converter \n• MultiBinding \n• RelativeSource \n• x:Reference \n \n5. Personalized Project Topics (14 Teams) \nEach team receives one unique UI scenario to prevent copying while keeping difficulty \nequivalent. \nTeam Assignments \nTeam Project Theme \n1 Grocery Shopping List \n2 Daily Habit Tracker \n3 Student Attendance UI \n4 Expense Tracker (UI only) \n5 Book Reading Tracker \n6 Workout Session Planner \n7 Movie Watchlist \n8 Meeting Agenda Manager \n9 Event Checklist",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Team Project Theme \n10 Smart Home Device Panel \n11 Plant Care Reminder UI \n12 Simple Note Organizer \n13 Classroom Equipment Checklist \nAll projects must follow the same technical constraints, only the UI content differs. \n \n6. Minimum Feature Set (Example) \nEach project should include: \n• Title header \n• Input section (Entry) \n• Action button(s) \n• List display (CollectionView) \n• Status indicator (Label / CheckBox / Switch) \n• Summary section (count, status, or description) \n \n7. Part 2 – Oral Examination (10 Minutes) \nStructure \n• 5 minutes: Project demonstration \n• 5 minutes: Oral questions (individual) \nBoth students must answer questions. \n \n8. Oral Question Bank (Examiner Chooses) \nUI & XAML (Basic) \n• Why did you choose Grid instead of StackLayout? \n• Explain the role of CollectionView in your UI. \nData Binding \n• Explain the difference between OneWay and TwoWay binding. \n• Why is ObservableCollection required? \nMVVM & Toolkit",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "• What problem does CommunityToolkit.Mvvm solve? \n• Explain [ObservableProperty] and [RelayCommand]. \nAdvanced Binding (If Used) \n• Why did you use a converter here? \n• Explain how MultiBinding works in your project. \n \n9. Individual Assessment Strategy \nTo ensure fairness: \n• Examiner asks different questions to each student \n• Each student must explain at least one binding used \n• Examiner may ask one student to modify a binding verbally \n \n10. Grading Rubric (20 Marks) \nPractical Project – 12 Marks \nCriteria Marks \nUI layout correctness 3 \nCorrect binding usage 4 \nMVVM structure 3 \nCode clarity & organization 2 \nOral Examination – 8 Marks \nCriteria Marks \nExplanation of bindings 3 \nMVVM understanding 2 \nIndividual contribution 2 \nCommunication clarity 1 \n \n11. Examiner Notes \n• Focus on understanding, not memorization \n• Penalize code-behind logic",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "• Encourage students to explain design decisions \n• Each team having a team leader, using GitHub to store the project, branch then merge \nfor the final submission \n• Each team must have a brainstorming for the project (visualation using any mindmap \napplication), checkin along with code.  \n \n12. Expected Learning Outcomes \nAfter the exam, students should be able to: \n• Design MAUI UI using XAML confidently \n• Apply data binding correctly \n• Explain MVVM principles verbally \n• Read and reason about XAML code \n \nEnd of Oral Exam Design",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-31 14:51:19",
    "avatar_path": null,
    "final_video_path": null
  },
  "d92dd1ca-3f62-4aa8-a204-22fa7d274e00": {
    "id": "d92dd1ca-3f62-4aa8-a204-22fa7d274e00",
    "filename": "ORAL_EXAM_DESIGN.pdf",
    "file_path": "static/uploads/presentations/d92dd1ca-3f62-4aa8-a204-22fa7d274e00/ORAL_EXAM_DESIGN.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "ORAL EXAM DESIGN \n.NET MAUI – XAML UI & Data Binding (CommunityToolkit.Mvvm) \n \n1. Exam Overview \nExam Type: Practical + Oral Examination \nFormat: Team-based (2 students / team) \nNumber of Teams: 13 teams \nTotal Duration per Team: 2 hours 10 minutes \n• Part 1: Practical UI Project – 2 hours \n• Part 2: Oral Examination – 10 minutes \n \n2. Exam Objectives \nThis oral exam aims to assess students’ ability to: \n• Design UI layouts using XAML in .NET MAUI \n• Correctly apply data binding techniques \n• Implement MVVM pattern using CommunityToolkit.Mvvm \n• Explain and justify technical decisions verbally \n• Demonstrate individual understanding within a team project \n \n3. Allowed Resources \n• Visual Studio 2022 or later \n• .NET MAUI project template \n• Internet access for documentation only \n• NuGet package: CommunityToolkit.Mvvm \n  No pre-written project code allowed \n \n4. Part 1 – Practical Project (2 Hours) \nGeneral Requirements (All Teams) \nEach team must build a single-screen MAUI application with: \n• UI designed in XAML \n• MVVM architecture \n• At least 4 different binding techniques",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning, everyone. Let's walk through the design of our upcoming oral exam, specifically focusing on .NET MAUI, XAML UI, and data binding with the Community Toolkit MVVM.\n\nFirst, an overview of the exam itself. This will be a combined practical and oral examination, conducted in a team-based format with two students per team. We anticipate having thirteen teams in total. The entire examination process for each team will last two hours and ten minutes. This is broken down into two main parts: a two-hour practical UI project, followed by a concise ten-minute oral examination.\n\nNow, let's clarify the exam objectives. This oral assessment is designed to evaluate your ability to effectively design user interface layouts using XAML within .NET MAUI. We also want to see that you can correctly apply various data binding techniques. Furthermore, a key objective is your ability to implement the MVVM pattern using the Community Toolkit MVVM library. Crucially, we're looking for your capacity to explain and justify your technical decisions verbally, and to demonstrate individual understanding even within a team project setting.\n\nRegarding allowed resources, you will have access to Visual Studio 2022 or later, the standard .NET MAUI project template, and internet access strictly for documentation purposes. You may also use the NuGet package for Community Toolkit MVVM. Please be aware that no pre-written project code is allowed; all development must occur during the exam period.\n\nFinally, let's detail Part One, the two-hour practical project. The general requirement for all teams is to build a single-screen MAUI application. This application must feature a user interface designed entirely in XAML, adhere to an MVVM architecture, and incorporate at least four different data binding techniques.",
        "edited_text": "Good morning, everyone. Let's walk through the design of our upcoming oral exam, specifically focusing on .NET MAUI, XAML UI, and data binding with the Community Toolkit MVVM.\n\nFirst, an overview of the exam itself. This will be a combined practical and oral examination, conducted in a team-based format with two students per team. We anticipate having thirteen teams in total. The entire examination process for each team will last two hours and ten minutes. This is broken down into two main parts: a two-hour practical UI project, followed by a concise ten-minute oral examination.\n\nNow, let's clarify the exam objectives. This oral assessment is designed to evaluate your ability to effectively design user interface layouts using XAML within .NET MAUI. We also want to see that you can correctly apply various data binding techniques. Furthermore, a key objective is your ability to implement the MVVM pattern using the Community Toolkit MVVM library. Crucially, we're looking for your capacity to explain and justify your technical decisions verbally, and to demonstrate individual understanding even within a team project setting.\n\nRegarding allowed resources, you will have access to Visual Studio 2022 or later, the standard .NET MAUI project template, and internet access strictly for documentation purposes. You may also use the NuGet package for Community Toolkit MVVM. Please be aware that no pre-written project code is allowed; all development must occur during the exam period.\n\nFinally, let's detail Part One, the two-hour practical project. The general requirement for all teams is to build a single-screen MAUI application. This application must feature a user interface designed entirely in XAML, adhere to an MVVM architecture, and incorporate at least four different data binding techniques.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "• No navigation between pages \n• No database or API \n \nMandatory Binding Techniques \nEach project must demonstrate: \n1. TwoWay Binding (Entry ↔ ViewModel) \n2. OneWay Binding (Display data) \n3. Command Binding (Button actions) \n4. ObservableCollection Binding (List update) \nAt least ONE advanced binding: \n• Converter \n• MultiBinding \n• RelativeSource \n• x:Reference \n \n5. Personalized Project Topics (14 Teams) \nEach team receives one unique UI scenario to prevent copying while keeping difficulty \nequivalent. \nTeam Assignments \nTeam Project Theme \n1 Grocery Shopping List \n2 Daily Habit Tracker \n3 Student Attendance UI \n4 Expense Tracker (UI only) \n5 Book Reading Tracker \n6 Workout Session Planner \n7 Movie Watchlist \n8 Meeting Agenda Manager \n9 Event Checklist",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Team Project Theme \n10 Smart Home Device Panel \n11 Plant Care Reminder UI \n12 Simple Note Organizer \n13 Classroom Equipment Checklist \nAll projects must follow the same technical constraints, only the UI content differs. \n \n6. Minimum Feature Set (Example) \nEach project should include: \n• Title header \n• Input section (Entry) \n• Action button(s) \n• List display (CollectionView) \n• Status indicator (Label / CheckBox / Switch) \n• Summary section (count, status, or description) \n \n7. Part 2 – Oral Examination (10 Minutes) \nStructure \n• 5 minutes: Project demonstration \n• 5 minutes: Oral questions (individual) \nBoth students must answer questions. \n \n8. Oral Question Bank (Examiner Chooses) \nUI & XAML (Basic) \n• Why did you choose Grid instead of StackLayout? \n• Explain the role of CollectionView in your UI. \nData Binding \n• Explain the difference between OneWay and TwoWay binding. \n• Why is ObservableCollection required? \nMVVM & Toolkit",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "• What problem does CommunityToolkit.Mvvm solve? \n• Explain [ObservableProperty] and [RelayCommand]. \nAdvanced Binding (If Used) \n• Why did you use a converter here? \n• Explain how MultiBinding works in your project. \n \n9. Individual Assessment Strategy \nTo ensure fairness: \n• Examiner asks different questions to each student \n• Each student must explain at least one binding used \n• Examiner may ask one student to modify a binding verbally \n \n10. Grading Rubric (20 Marks) \nPractical Project – 12 Marks \nCriteria Marks \nUI layout correctness 3 \nCorrect binding usage 4 \nMVVM structure 3 \nCode clarity & organization 2 \nOral Examination – 8 Marks \nCriteria Marks \nExplanation of bindings 3 \nMVVM understanding 2 \nIndividual contribution 2 \nCommunication clarity 1 \n \n11. Examiner Notes \n• Focus on understanding, not memorization \n• Penalize code-behind logic",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "• Encourage students to explain design decisions \n• Each team having a team leader, using GitHub to store the project, branch then merge \nfor the final submission \n• Each team must have a brainstorming for the project (visualation using any mindmap \napplication), checkin along with code.  \n \n12. Expected Learning Outcomes \nAfter the exam, students should be able to: \n• Design MAUI UI using XAML confidently \n• Apply data binding correctly \n• Explain MVVM principles verbally \n• Read and reason about XAML code \n \nEnd of Oral Exam Design",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-31 15:54:58",
    "avatar_path": null,
    "final_video_path": null
  },
  "981fb7cf-ba25-4b1b-be5f-6031d4e66105": {
    "id": "981fb7cf-ba25-4b1b-be5f-6031d4e66105",
    "filename": "ORAL_EXAM_DESIGN.pdf",
    "file_path": "static/uploads/presentations/981fb7cf-ba25-4b1b-be5f-6031d4e66105/ORAL_EXAM_DESIGN.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "ORAL EXAM DESIGN \n.NET MAUI – XAML UI & Data Binding (CommunityToolkit.Mvvm) \n \n1. Exam Overview \nExam Type: Practical + Oral Examination \nFormat: Team-based (2 students / team) \nNumber of Teams: 13 teams \nTotal Duration per Team: 2 hours 10 minutes \n• Part 1: Practical UI Project – 2 hours \n• Part 2: Oral Examination – 10 minutes \n \n2. Exam Objectives \nThis oral exam aims to assess students’ ability to: \n• Design UI layouts using XAML in .NET MAUI \n• Correctly apply data binding techniques \n• Implement MVVM pattern using CommunityToolkit.Mvvm \n• Explain and justify technical decisions verbally \n• Demonstrate individual understanding within a team project \n \n3. Allowed Resources \n• Visual Studio 2022 or later \n• .NET MAUI project template \n• Internet access for documentation only \n• NuGet package: CommunityToolkit.Mvvm \n  No pre-written project code allowed \n \n4. Part 1 – Practical Project (2 Hours) \nGeneral Requirements (All Teams) \nEach team must build a single-screen MAUI application with: \n• UI designed in XAML \n• MVVM architecture \n• At least 4 different binding techniques",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning, everyone. Today, we're going to discuss the structure and design of our upcoming oral examination, which focuses on .NET MAUI, XAML UI, and data binding using the Community Toolkit dot MVVM.\n\nFirst, let's go over the exam overview. This assessment is a combined practical and oral examination. You'll be working in teams of two students, and we have a total of thirteen teams participating. Each team will have a total duration of two hours and ten minutes for the entire assessment. This time is split into two distinct parts: a two-hour practical UI project, followed by a ten-minute oral examination.\n\nMoving on to the exam objectives, this oral exam is specifically designed to assess several key abilities. We aim to evaluate your skills in designing user interface layouts using XAML within .NET MAUI, correctly applying various data binding techniques, and implementing the MVVM pattern effectively with the Community Toolkit dot MVVM. Furthermore, we'll be looking at your capacity to verbally explain and justify your technical decisions, and importantly, how you demonstrate your individual understanding within the context of a team project.\n\nRegarding allowed resources, you'll be permitted to use Visual Studio 2022 or later, along with the standard .NET MAUI project template. Internet access is allowed strictly for documentation purposes only. You will also need the NuGet package for Community Toolkit dot MVVM. A critical point to remember is that no pre-written project code is allowed; you must start from scratch.\n\nFinally, let's detail Part 1, the practical project, which spans two hours. The general requirement for all teams is to build a single-screen MAUI application. This application must feature a user interface designed entirely in XAML, adhere to the MVVM architecture, and demonstrate the use of at least four different binding techniques.",
        "edited_text": "Good morning, everyone. Today, we're going to discuss the structure and design of our upcoming oral examination, which focuses on .NET MAUI, XAML UI, and data binding using the Community Toolkit dot MVVM.\n\nFirst, let's go over the exam overview. This assessment is a combined practical and oral examination. You'll be working in teams of two students, and we have a total of thirteen teams participating. Each team will have a total duration of two hours and ten minutes for the entire assessment. This time is split into two distinct parts: a two-hour practical UI project, followed by a ten-minute oral examination.\n\nMoving on to the exam objectives, this oral exam is specifically designed to assess several key abilities. We aim to evaluate your skills in designing user interface layouts using XAML within .NET MAUI, correctly applying various data binding techniques, and implementing the MVVM pattern effectively with the Community Toolkit dot MVVM. Furthermore, we'll be looking at your capacity to verbally explain and justify your technical decisions, and importantly, how you demonstrate your individual understanding within the context of a team project.\n\nRegarding allowed resources, you'll be permitted to use Visual Studio 2022 or later, along with the standard .NET MAUI project template. Internet access is allowed strictly for documentation purposes only. You will also need the NuGet package for Community Toolkit dot MVVM. A critical point to remember is that no pre-written project code is allowed; you must start from scratch.\n\nFinally, let's detail Part 1, the practical project, which spans two hours. The general requirement for all teams is to build a single-screen MAUI application. This application must feature a user interface designed entirely in XAML, adhere to the MVVM architecture, and demonstrate the use of at least four different binding techniques.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "• No navigation between pages \n• No database or API \n \nMandatory Binding Techniques \nEach project must demonstrate: \n1. TwoWay Binding (Entry ↔ ViewModel) \n2. OneWay Binding (Display data) \n3. Command Binding (Button actions) \n4. ObservableCollection Binding (List update) \nAt least ONE advanced binding: \n• Converter \n• MultiBinding \n• RelativeSource \n• x:Reference \n \n5. Personalized Project Topics (14 Teams) \nEach team receives one unique UI scenario to prevent copying while keeping difficulty \nequivalent. \nTeam Assignments \nTeam Project Theme \n1 Grocery Shopping List \n2 Daily Habit Tracker \n3 Student Attendance UI \n4 Expense Tracker (UI only) \n5 Book Reading Tracker \n6 Workout Session Planner \n7 Movie Watchlist \n8 Meeting Agenda Manager \n9 Event Checklist",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Alright, let's go over the project requirements and expectations.\n\nFirst, it is important to understand the scope of these projects. To ensure our focus remains squarely on core UI development and binding techniques, please note that your solutions will not involve navigation between multiple pages. Furthermore, there is no need to integrate with a database or external API. All data will be handled in-memory, allowing us to concentrate purely on the front-end logic and presentation.\n\nNow, let's talk about the mandatory binding techniques that each project must demonstrate. These are fundamental to building responsive and maintainable user interfaces. You will need to implement Two-Way Binding, which allows data to flow seamlessly between your UI entry fields and your ViewModel. One-Way Binding is also required for effectively displaying data from your source. Next, Command Binding will be essential for handling button actions and other interactive elements, connecting user interactions directly to your ViewModel's logic. And finally, Observable Collection Binding is crucial for managing and dynamically updating lists or collections of data in your UI.\n\nBeyond these core requirements, each project must also incorporate at least one advanced binding technique. You have several options to choose from: you could use a Converter to transform data for display, implement Multi-Binding to combine multiple sources into a single target, leverage Relative Source for contextual binding, or utilize X Reference to bind to named elements within your XAML.\n\nTo ensure fairness and encourage unique solutions across all fourteen teams, each group will receive a personalized project topic. This approach prevents direct copying while maintaining an equivalent level of difficulty for everyone. Here are just a few examples of the diverse UI scenarios you might encounter: Team One could be working on a Grocery Shopping List; Team Two might tackle a Daily Habit Tracker; Team Three, a Student Attendance UI; Team Four, an Expense Tracker, focusing purely on the UI aspect; and Team Five, a Book Reading Tracker. There are many more unique topics designed to challenge and engage each team.",
        "edited_text": "Alright, let's go over the project requirements and expectations.\n\nFirst, it is important to understand the scope of these projects. To ensure our focus remains squarely on core UI development and binding techniques, please note that your solutions will not involve navigation between multiple pages. Furthermore, there is no need to integrate with a database or external API. All data will be handled in-memory, allowing us to concentrate purely on the front-end logic and presentation.\n\nNow, let's talk about the mandatory binding techniques that each project must demonstrate. These are fundamental to building responsive and maintainable user interfaces. You will need to implement Two-Way Binding, which allows data to flow seamlessly between your UI entry fields and your ViewModel. One-Way Binding is also required for effectively displaying data from your source. Next, Command Binding will be essential for handling button actions and other interactive elements, connecting user interactions directly to your ViewModel's logic. And finally, Observable Collection Binding is crucial for managing and dynamically updating lists or collections of data in your UI.\n\nBeyond these core requirements, each project must also incorporate at least one advanced binding technique. You have several options to choose from: you could use a Converter to transform data for display, implement Multi-Binding to combine multiple sources into a single target, leverage Relative Source for contextual binding, or utilize X Reference to bind to named elements within your XAML.\n\nTo ensure fairness and encourage unique solutions across all fourteen teams, each group will receive a personalized project topic. This approach prevents direct copying while maintaining an equivalent level of difficulty for everyone. Here are just a few examples of the diverse UI scenarios you might encounter: Team One could be working on a Grocery Shopping List; Team Two might tackle a Daily Habit Tracker; Team Three, a Student Attendance UI; Team Four, an Expense Tracker, focusing purely on the UI aspect; and Team Five, a Book Reading Tracker. There are many more unique topics designed to challenge and engage each team.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Team Project Theme \n10 Smart Home Device Panel \n11 Plant Care Reminder UI \n12 Simple Note Organizer \n13 Classroom Equipment Checklist \nAll projects must follow the same technical constraints, only the UI content differs. \n \n6. Minimum Feature Set (Example) \nEach project should include: \n• Title header \n• Input section (Entry) \n• Action button(s) \n• List display (CollectionView) \n• Status indicator (Label / CheckBox / Switch) \n• Summary section (count, status, or description) \n \n7. Part 2 – Oral Examination (10 Minutes) \nStructure \n• 5 minutes: Project demonstration \n• 5 minutes: Oral questions (individual) \nBoth students must answer questions. \n \n8. Oral Question Bank (Examiner Chooses) \nUI & XAML (Basic) \n• Why did you choose Grid instead of StackLayout? \n• Explain the role of CollectionView in your UI. \nData Binding \n• Explain the difference between OneWay and TwoWay binding. \n• Why is ObservableCollection required? \nMVVM & Toolkit",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Alright everyone, let's go over some important details regarding your team projects and the upcoming oral examination.\n\nFirst, let's look at the project themes. We have four distinct options available: a Smart Home Device Panel, a Plant Care Reminder user interface, a Simple Note Organizer, and a Classroom Equipment Checklist. While the specific user interface content will naturally differ for each of these themes, it's crucial to remember that all projects must adhere to the same underlying technical constraints. This ensures a consistent foundation across all your work, focusing on core development principles rather than just visual variety.\n\nMoving on to the minimum feature set. To ensure every project covers essential components and demonstrates core functionalities, each one is required to incorporate a defined minimum feature set. This includes a clear title header, an input section for data entry, and at least one action button. You'll also need a list display, typically implemented using a CollectionView, a status indicator such as a label, checkbox, or switch, and finally, a summary section that provides a count, status, or description relevant to your project's data. These elements form the core functionality we expect to see.\n\nNow, let's transition to the oral examination, which forms Part Two of this assessment. This will be a ten-minute session structured as follows: the first five minutes will be dedicated to your project demonstration, where you'll showcase your work. This will be followed by five minutes of individual oral questions. Please make a note that both students in a team are expected to actively participate and answer these questions.\n\nTo help you prepare effectively, here's an overview of the types of questions you might encounter during the oral examination. Examiners will choose from a bank of questions covering key areas. For instance, under UI and XAML basics, you could be asked why you chose Grid instead of StackLayout, or to explain the specific role of CollectionView in your user interface. In the Data Binding section, expect questions on the difference between OneWay and TwoWay binding, and why an ObservableCollection is a necessary component in certain scenarios. We will also cover topics related to MVVM and the Toolkit, so please ensure you're familiar with these concepts.",
        "edited_text": "Alright everyone, let's go over some important details regarding your team projects and the upcoming oral examination.\n\nFirst, let's look at the project themes. We have four distinct options available: a Smart Home Device Panel, a Plant Care Reminder user interface, a Simple Note Organizer, and a Classroom Equipment Checklist. While the specific user interface content will naturally differ for each of these themes, it's crucial to remember that all projects must adhere to the same underlying technical constraints. This ensures a consistent foundation across all your work, focusing on core development principles rather than just visual variety.\n\nMoving on to the minimum feature set. To ensure every project covers essential components and demonstrates core functionalities, each one is required to incorporate a defined minimum feature set. This includes a clear title header, an input section for data entry, and at least one action button. You'll also need a list display, typically implemented using a CollectionView, a status indicator such as a label, checkbox, or switch, and finally, a summary section that provides a count, status, or description relevant to your project's data. These elements form the core functionality we expect to see.\n\nNow, let's transition to the oral examination, which forms Part Two of this assessment. This will be a ten-minute session structured as follows: the first five minutes will be dedicated to your project demonstration, where you'll showcase your work. This will be followed by five minutes of individual oral questions. Please make a note that both students in a team are expected to actively participate and answer these questions.\n\nTo help you prepare effectively, here's an overview of the types of questions you might encounter during the oral examination. Examiners will choose from a bank of questions covering key areas. For instance, under UI and XAML basics, you could be asked why you chose Grid instead of StackLayout, or to explain the specific role of CollectionView in your user interface. In the Data Binding section, expect questions on the difference between OneWay and TwoWay binding, and why an ObservableCollection is a necessary component in certain scenarios. We will also cover topics related to MVVM and the Toolkit, so please ensure you're familiar with these concepts.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "• What problem does CommunityToolkit.Mvvm solve? \n• Explain [ObservableProperty] and [RelayCommand]. \nAdvanced Binding (If Used) \n• Why did you use a converter here? \n• Explain how MultiBinding works in your project. \n \n9. Individual Assessment Strategy \nTo ensure fairness: \n• Examiner asks different questions to each student \n• Each student must explain at least one binding used \n• Examiner may ask one student to modify a binding verbally \n \n10. Grading Rubric (20 Marks) \nPractical Project – 12 Marks \nCriteria Marks \nUI layout correctness 3 \nCorrect binding usage 4 \nMVVM structure 3 \nCode clarity & organization 2 \nOral Examination – 8 Marks \nCriteria Marks \nExplanation of bindings 3 \nMVVM understanding 2 \nIndividual contribution 2 \nCommunication clarity 1 \n \n11. Examiner Notes \n• Focus on understanding, not memorization \n• Penalize code-behind logic",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Let's delve into the specific areas we will be assessing, particularly concerning your use of the Community Toolkit MVVM. You should be prepared to articulate what specific problem the Community Toolkit MVVM aims to solve in application development. Following that, we expect you to clearly explain the purpose and usage of key components like Observable Property and Relay Command within your project. If you've employed advanced binding techniques, such as using converters, be ready to explain why you chose a converter in a particular instance. Similarly, if you've implemented Multi Binding, a thorough explanation of its functionality within your project will be expected.\n\nNow, regarding our individual assessment strategy, we've implemented measures to ensure fairness for everyone. The examiner will ask different questions to each student, ensuring we assess individual understanding rather than a shared group response. A mandatory requirement for every student is to explain at least one binding used within your project. Furthermore, to test your practical problem-solving skills, the examiner may ask a student to verbally modify a binding.\n\nLet's turn our attention to the grading rubric, which totals twenty marks. Twelve marks are allocated to the practical project itself. This includes three marks for UI layout correctness, four marks for the correct usage of bindings, three marks for adhering to a sound MVVM structure, and two marks for the overall clarity and organization of your code. The remaining eight marks are for the oral examination. Here, three marks are for your explanation of bindings, two marks for demonstrating your understanding of MVVM principles, another two marks for your individual contribution to the project, and finally, one mark for the clarity of your communication.\n\nFinally, a few important notes from the examiner. The primary focus of this assessment is on your understanding of the concepts, not on mere memorization. We want to see that you truly grasp the \"why\" behind your implementations. And crucially, you will be penalized for the presence of code-behind logic, as this directly contradicts the MVVM principles we expect you to apply.",
        "edited_text": "Let's delve into the specific areas we will be assessing, particularly concerning your use of the Community Toolkit MVVM. You should be prepared to articulate what specific problem the Community Toolkit MVVM aims to solve in application development. Following that, we expect you to clearly explain the purpose and usage of key components like Observable Property and Relay Command within your project. If you've employed advanced binding techniques, such as using converters, be ready to explain why you chose a converter in a particular instance. Similarly, if you've implemented Multi Binding, a thorough explanation of its functionality within your project will be expected.\n\nNow, regarding our individual assessment strategy, we've implemented measures to ensure fairness for everyone. The examiner will ask different questions to each student, ensuring we assess individual understanding rather than a shared group response. A mandatory requirement for every student is to explain at least one binding used within your project. Furthermore, to test your practical problem-solving skills, the examiner may ask a student to verbally modify a binding.\n\nLet's turn our attention to the grading rubric, which totals twenty marks. Twelve marks are allocated to the practical project itself. This includes three marks for UI layout correctness, four marks for the correct usage of bindings, three marks for adhering to a sound MVVM structure, and two marks for the overall clarity and organization of your code. The remaining eight marks are for the oral examination. Here, three marks are for your explanation of bindings, two marks for demonstrating your understanding of MVVM principles, another two marks for your individual contribution to the project, and finally, one mark for the clarity of your communication.\n\nFinally, a few important notes from the examiner. The primary focus of this assessment is on your understanding of the concepts, not on mere memorization. We want to see that you truly grasp the \"why\" behind your implementations. And crucially, you will be penalized for the presence of code-behind logic, as this directly contradicts the MVVM principles we expect you to apply.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "• Encourage students to explain design decisions \n• Each team having a team leader, using GitHub to store the project, branch then merge \nfor the final submission \n• Each team must have a brainstorming for the project (visualation using any mindmap \napplication), checkin along with code.  \n \n12. Expected Learning Outcomes \nAfter the exam, students should be able to: \n• Design MAUI UI using XAML confidently \n• Apply data binding correctly \n• Explain MVVM principles verbally \n• Read and reason about XAML code \n \nEnd of Oral Exam Design",
        "notes": "",
        "total_slides": 5,
        "generated_text": "To ensure a structured and effective project development process, we strongly encourage students to clearly explain their design decisions. This isn't just about showing your work, but about articulating the 'why' behind your choices, fostering critical thinking and communication skills.\n\nFor team dynamics, each group will designate a team leader to coordinate efforts. We expect professional version control practices to be followed, specifically using GitHub to store your project. This includes utilizing branching for individual work and then merging these branches for the final submission, mirroring industry standards for collaborative development.\n\nA crucial first step for every team is a thorough brainstorming session for their project. We recommend visualizing these ideas using any mind-mapping application. The output of this creative process should be documented and submitted alongside your code, demonstrating your initial thought process and planning.\n\nNow, let's turn our attention to the expected learning outcomes from this module. Upon successful completion, students should confidently be able to design MAUI user interfaces using XAML. This includes creating intuitive and responsive layouts. You will also demonstrate the ability to apply data binding correctly, a fundamental skill for building dynamic and maintainable applications. Furthermore, you will be able to articulate and explain MVVM principles verbally, showcasing your understanding of this essential architectural pattern. Finally, you will develop the skill to read and reason effectively about existing XAML code, which is vital for debugging, collaboration, and understanding complex UI structures.\n\nThis concludes the overview of our oral exam design and project guidelines. Thank you.",
        "edited_text": "To ensure a structured and effective project development process, we strongly encourage students to clearly explain their design decisions. This isn't just about showing your work, but about articulating the 'why' behind your choices, fostering critical thinking and communication skills.\n\nFor team dynamics, each group will designate a team leader to coordinate efforts. We expect professional version control practices to be followed, specifically using GitHub to store your project. This includes utilizing branching for individual work and then merging these branches for the final submission, mirroring industry standards for collaborative development.\n\nA crucial first step for every team is a thorough brainstorming session for their project. We recommend visualizing these ideas using any mind-mapping application. The output of this creative process should be documented and submitted alongside your code, demonstrating your initial thought process and planning.\n\nNow, let's turn our attention to the expected learning outcomes from this module. Upon successful completion, students should confidently be able to design MAUI user interfaces using XAML. This includes creating intuitive and responsive layouts. You will also demonstrate the ability to apply data binding correctly, a fundamental skill for building dynamic and maintainable applications. Furthermore, you will be able to articulate and explain MVVM principles verbally, showcasing your understanding of this essential architectural pattern. Finally, you will develop the skill to read and reason effectively about existing XAML code, which is vital for debugging, collaboration, and understanding complex UI structures.\n\nThis concludes the overview of our oral exam design and project guidelines. Thank you.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-31 16:13:36",
    "avatar_path": null,
    "final_video_path": null
  },
  "9b57f887-1786-4dae-988e-646ab414c030": {
    "id": "9b57f887-1786-4dae-988e-646ab414c030",
    "filename": "ORAL_EXAM_DESIGN.pdf",
    "file_path": "static/uploads/presentations/9b57f887-1786-4dae-988e-646ab414c030/ORAL_EXAM_DESIGN.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "ORAL EXAM DESIGN \n.NET MAUI – XAML UI & Data Binding (CommunityToolkit.Mvvm) \n \n1. Exam Overview \nExam Type: Practical + Oral Examination \nFormat: Team-based (2 students / team) \nNumber of Teams: 13 teams \nTotal Duration per Team: 2 hours 10 minutes \n• Part 1: Practical UI Project – 2 hours \n• Part 2: Oral Examination – 10 minutes \n \n2. Exam Objectives \nThis oral exam aims to assess students’ ability to: \n• Design UI layouts using XAML in .NET MAUI \n• Correctly apply data binding techniques \n• Implement MVVM pattern using CommunityToolkit.Mvvm \n• Explain and justify technical decisions verbally \n• Demonstrate individual understanding within a team project \n \n3. Allowed Resources \n• Visual Studio 2022 or later \n• .NET MAUI project template \n• Internet access for documentation only \n• NuGet package: CommunityToolkit.Mvvm \n  No pre-written project code allowed \n \n4. Part 1 – Practical Project (2 Hours) \nGeneral Requirements (All Teams) \nEach team must build a single-screen MAUI application with: \n• UI designed in XAML \n• MVVM architecture \n• At least 4 different binding techniques",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning, everyone. Today, we're going to walk through the design of your upcoming oral exam, which focuses specifically on .NET MAUI, XAML UI, and data binding, leveraging the Community Toolkit MVVM.\n\nFirst, let's cover the exam overview. This will be a practical plus oral examination, conducted in teams of two students. We have thirteen teams in total participating. Each team will have a total duration of two hours and ten minutes. This time is divided into two distinct parts: a two-hour practical UI project, followed by a ten-minute oral examination.\n\nNow, regarding the objectives of this oral exam. We aim to assess your ability to design user interface layouts using XAML within .NET MAUI, correctly apply various data binding techniques, and implement the MVVM pattern effectively, utilizing the Community Toolkit MVVM. Beyond technical implementation, you'll also be expected to verbally explain and justify your technical decisions, and importantly, demonstrate your individual understanding even within the context of a team project.\n\nLet's clarify the resources you're allowed to use during the exam. You may use Visual Studio 2022 or later, the standard .NET MAUI project template, and importantly, internet access is permitted strictly for documentation purposes only. You will also need the NuGet package for Community Toolkit MVVM. Please note, no pre-written project code is allowed; all development must be done during the exam.\n\nMoving on to Part One, the practical project, which spans two hours. The general requirements for all teams are to build a single-screen MAUI application. This application must feature a UI designed entirely in XAML, adhere to an MVVM architecture, and demonstrate the use of at least four different binding techniques.",
        "edited_text": "Good morning, everyone. Today, we're going to walk through the design of your upcoming oral exam, which focuses specifically on .NET MAUI, XAML UI, and data binding, leveraging the Community Toolkit MVVM.\n\nFirst, let's cover the exam overview. This will be a practical plus oral examination, conducted in teams of two students. We have thirteen teams in total participating. Each team will have a total duration of two hours and ten minutes. This time is divided into two distinct parts: a two-hour practical UI project, followed by a ten-minute oral examination.\n\nNow, regarding the objectives of this oral exam. We aim to assess your ability to design user interface layouts using XAML within .NET MAUI, correctly apply various data binding techniques, and implement the MVVM pattern effectively, utilizing the Community Toolkit MVVM. Beyond technical implementation, you'll also be expected to verbally explain and justify your technical decisions, and importantly, demonstrate your individual understanding even within the context of a team project.\n\nLet's clarify the resources you're allowed to use during the exam. You may use Visual Studio 2022 or later, the standard .NET MAUI project template, and importantly, internet access is permitted strictly for documentation purposes only. You will also need the NuGet package for Community Toolkit MVVM. Please note, no pre-written project code is allowed; all development must be done during the exam.\n\nMoving on to Part One, the practical project, which spans two hours. The general requirements for all teams are to build a single-screen MAUI application. This application must feature a UI designed entirely in XAML, adhere to an MVVM architecture, and demonstrate the use of at least four different binding techniques.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "• No navigation between pages \n• No database or API \n \nMandatory Binding Techniques \nEach project must demonstrate: \n1. TwoWay Binding (Entry ↔ ViewModel) \n2. OneWay Binding (Display data) \n3. Command Binding (Button actions) \n4. ObservableCollection Binding (List update) \nAt least ONE advanced binding: \n• Converter \n• MultiBinding \n• RelativeSource \n• x:Reference \n \n5. Personalized Project Topics (14 Teams) \nEach team receives one unique UI scenario to prevent copying while keeping difficulty \nequivalent. \nTeam Assignments \nTeam Project Theme \n1 Grocery Shopping List \n2 Daily Habit Tracker \n3 Student Attendance UI \n4 Expense Tracker (UI only) \n5 Book Reading Tracker \n6 Workout Session Planner \n7 Movie Watchlist \n8 Meeting Agenda Manager \n9 Event Checklist",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning everyone. Let's discuss some important guidelines and requirements for our upcoming projects.\n\nFirst, to keep our focus sharp and development streamlined, we'll be working within a single-page context, meaning no navigation between different screens or pages. Furthermore, to emphasize front-end UI skills, projects will not involve external databases or APIs. All data handling will be managed within the application itself.\n\nNow, let's move on to the mandatory binding techniques you must demonstrate in your projects. Each project needs to clearly show:\n\nFirst, Two-Way Binding, which is crucial for user input fields where data flows both from the UI to the view model and vice versa.\nSecond, One-Way Binding, perfect for efficiently displaying data that doesn't need to be edited directly by the user.\nThird, Command Binding, which is essential for handling button clicks and other interactive actions within your application.\nAnd fourth, Observable Collection Binding, which is vital for dynamically updating lists or collections of items as data changes.\n\nBeyond these core techniques, each project must also demonstrate proficiency in at least one advanced binding concept. You'll have the flexibility to choose from powerful options like Converters, Multi-binding, Relative Source, or x:Reference. This allows you to explore more sophisticated data presentation and manipulation.\n\nFinally, regarding project topics, we have fourteen teams, and each team will receive a personalized, unique UI scenario. This approach guarantees an equivalent level of difficulty across all projects while fostering individual creativity and preventing any copying. For instance, topics range from a Grocery Shopping List to a Daily Habit Tracker, a Student Attendance UI, or even a Movie Watchlist, ensuring a diverse and engaging set of challenges for everyone.",
        "edited_text": "Good morning everyone. Let's discuss some important guidelines and requirements for our upcoming projects.\n\nFirst, to keep our focus sharp and development streamlined, we'll be working within a single-page context, meaning no navigation between different screens or pages. Furthermore, to emphasize front-end UI skills, projects will not involve external databases or APIs. All data handling will be managed within the application itself.\n\nNow, let's move on to the mandatory binding techniques you must demonstrate in your projects. Each project needs to clearly show:\n\nFirst, Two-Way Binding, which is crucial for user input fields where data flows both from the UI to the view model and vice versa.\nSecond, One-Way Binding, perfect for efficiently displaying data that doesn't need to be edited directly by the user.\nThird, Command Binding, which is essential for handling button clicks and other interactive actions within your application.\nAnd fourth, Observable Collection Binding, which is vital for dynamically updating lists or collections of items as data changes.\n\nBeyond these core techniques, each project must also demonstrate proficiency in at least one advanced binding concept. You'll have the flexibility to choose from powerful options like Converters, Multi-binding, Relative Source, or x:Reference. This allows you to explore more sophisticated data presentation and manipulation.\n\nFinally, regarding project topics, we have fourteen teams, and each team will receive a personalized, unique UI scenario. This approach guarantees an equivalent level of difficulty across all projects while fostering individual creativity and preventing any copying. For instance, topics range from a Grocery Shopping List to a Daily Habit Tracker, a Student Attendance UI, or even a Movie Watchlist, ensuring a diverse and engaging set of challenges for everyone.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Team Project Theme \n10 Smart Home Device Panel \n11 Plant Care Reminder UI \n12 Simple Note Organizer \n13 Classroom Equipment Checklist \nAll projects must follow the same technical constraints, only the UI content differs. \n \n6. Minimum Feature Set (Example) \nEach project should include: \n• Title header \n• Input section (Entry) \n• Action button(s) \n• List display (CollectionView) \n• Status indicator (Label / CheckBox / Switch) \n• Summary section (count, status, or description) \n \n7. Part 2 – Oral Examination (10 Minutes) \nStructure \n• 5 minutes: Project demonstration \n• 5 minutes: Oral questions (individual) \nBoth students must answer questions. \n \n8. Oral Question Bank (Examiner Chooses) \nUI & XAML (Basic) \n• Why did you choose Grid instead of StackLayout? \n• Explain the role of CollectionView in your UI. \nData Binding \n• Explain the difference between OneWay and TwoWay binding. \n• Why is ObservableCollection required? \nMVVM & Toolkit",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning everyone. Let's go over some important details for your upcoming team project. You have four distinct themes to choose from: a Smart Home Device Panel, a Plant Care Reminder user interface, a Simple Note Organizer, or a Classroom Equipment Checklist. While the specific UI content will differ based on your chosen theme, it's crucial to remember that all projects must adhere to the same underlying technical constraints.\n\nNow, regarding the minimum feature set, each project, regardless of its theme, must include several core components. This means every application should feature a clear title header, an input section for user entry, and at least one action button. You'll also need a list display, typically implemented using a CollectionView, a status indicator such as a label, checkbox, or switch, and a summary section that provides a count, status, or description.\n\nMoving on to Part Two, the oral examination. This segment will be ten minutes in total. The first five minutes are allocated for your project demonstration, where you'll showcase your application's functionality. This will be followed by five minutes of individual oral questions. It's very important to note that both students on the team must be prepared to answer these questions.\n\nTo help you prepare, here is a glimpse into the types of questions you might encounter, though the examiner will choose from a broader bank. We'll be looking at your understanding of UI and XAML basics. For instance, you might be asked to explain your design choices, such as why you opted for a Grid layout instead of a StackLayout, or to elaborate on the specific role of a CollectionView in your user interface. Data binding is another key area. Be ready to explain the difference between OneWay and TwoWay binding, and why an ObservableCollection is a necessary component in certain scenarios. Finally, expect questions related to MVVM and the Toolkit. Make sure you understand these architectural patterns and tools thoroughly.",
        "edited_text": "Good morning everyone. Let's go over some important details for your upcoming team project. You have four distinct themes to choose from: a Smart Home Device Panel, a Plant Care Reminder user interface, a Simple Note Organizer, or a Classroom Equipment Checklist. While the specific UI content will differ based on your chosen theme, it's crucial to remember that all projects must adhere to the same underlying technical constraints.\n\nNow, regarding the minimum feature set, each project, regardless of its theme, must include several core components. This means every application should feature a clear title header, an input section for user entry, and at least one action button. You'll also need a list display, typically implemented using a CollectionView, a status indicator such as a label, checkbox, or switch, and a summary section that provides a count, status, or description.\n\nMoving on to Part Two, the oral examination. This segment will be ten minutes in total. The first five minutes are allocated for your project demonstration, where you'll showcase your application's functionality. This will be followed by five minutes of individual oral questions. It's very important to note that both students on the team must be prepared to answer these questions.\n\nTo help you prepare, here is a glimpse into the types of questions you might encounter, though the examiner will choose from a broader bank. We'll be looking at your understanding of UI and XAML basics. For instance, you might be asked to explain your design choices, such as why you opted for a Grid layout instead of a StackLayout, or to elaborate on the specific role of a CollectionView in your user interface. Data binding is another key area. Be ready to explain the difference between OneWay and TwoWay binding, and why an ObservableCollection is a necessary component in certain scenarios. Finally, expect questions related to MVVM and the Toolkit. Make sure you understand these architectural patterns and tools thoroughly.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "• What problem does CommunityToolkit.Mvvm solve? \n• Explain [ObservableProperty] and [RelayCommand]. \nAdvanced Binding (If Used) \n• Why did you use a converter here? \n• Explain how MultiBinding works in your project. \n \n9. Individual Assessment Strategy \nTo ensure fairness: \n• Examiner asks different questions to each student \n• Each student must explain at least one binding used \n• Examiner may ask one student to modify a binding verbally \n \n10. Grading Rubric (20 Marks) \nPractical Project – 12 Marks \nCriteria Marks \nUI layout correctness 3 \nCorrect binding usage 4 \nMVVM structure 3 \nCode clarity & organization 2 \nOral Examination – 8 Marks \nCriteria Marks \nExplanation of bindings 3 \nMVVM understanding 2 \nIndividual contribution 2 \nCommunication clarity 1 \n \n11. Examiner Notes \n• Focus on understanding, not memorization \n• Penalize code-behind logic",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Let's begin by outlining some key discussion points. First, we'll explore the fundamental problem that CommunityToolkit dot M V V M is designed to address. Then, we'll delve into the specifics of key components like Observable Property and Relay Command, understanding their roles and how they function. If advanced binding techniques were employed, be prepared to explain your rationale. For instance, why did you opt to use a converter in a particular scenario? And if MultiBinding was utilized, please elaborate on its implementation within your project.\n\nMoving on to the individual assessment strategy, designed to ensure fairness and a comprehensive evaluation. The examiner will pose distinct questions to each student. Every student is expected to explain at least one binding they've implemented. Additionally, the examiner might ask a student to verbally describe how they would modify an existing binding.\n\nNext, let's clarify the grading rubric, which totals twenty marks. The practical project accounts for twelve of these marks. Three marks are allocated for the correctness of your user interface layout. Four marks are for the correct usage of bindings. Your M V V M structure will earn you three marks, and two marks are for code clarity and organization. The oral examination contributes the remaining eight marks. Three marks here are for your explanation of bindings. Two marks for your understanding of M V V M principles, another two marks for your individual contribution, and finally, one mark for the clarity of your communication.\n\nFinally, a few important notes for the examiner. The primary focus should be on assessing genuine understanding, rather than rote memorization. And it's crucial to penalize the use of logic within code-behind files, reinforcing best practices.",
        "edited_text": "Let's begin by outlining some key discussion points. First, we'll explore the fundamental problem that CommunityToolkit dot M V V M is designed to address. Then, we'll delve into the specifics of key components like Observable Property and Relay Command, understanding their roles and how they function. If advanced binding techniques were employed, be prepared to explain your rationale. For instance, why did you opt to use a converter in a particular scenario? And if MultiBinding was utilized, please elaborate on its implementation within your project.\n\nMoving on to the individual assessment strategy, designed to ensure fairness and a comprehensive evaluation. The examiner will pose distinct questions to each student. Every student is expected to explain at least one binding they've implemented. Additionally, the examiner might ask a student to verbally describe how they would modify an existing binding.\n\nNext, let's clarify the grading rubric, which totals twenty marks. The practical project accounts for twelve of these marks. Three marks are allocated for the correctness of your user interface layout. Four marks are for the correct usage of bindings. Your M V V M structure will earn you three marks, and two marks are for code clarity and organization. The oral examination contributes the remaining eight marks. Three marks here are for your explanation of bindings. Two marks for your understanding of M V V M principles, another two marks for your individual contribution, and finally, one mark for the clarity of your communication.\n\nFinally, a few important notes for the examiner. The primary focus should be on assessing genuine understanding, rather than rote memorization. And it's crucial to penalize the use of logic within code-behind files, reinforcing best practices.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "• Encourage students to explain design decisions \n• Each team having a team leader, using GitHub to store the project, branch then merge \nfor the final submission \n• Each team must have a brainstorming for the project (visualation using any mindmap \napplication), checkin along with code.  \n \n12. Expected Learning Outcomes \nAfter the exam, students should be able to: \n• Design MAUI UI using XAML confidently \n• Apply data binding correctly \n• Explain MVVM principles verbally \n• Read and reason about XAML code \n \nEnd of Oral Exam Design",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Let's delve into some crucial aspects of our project methodology and the expected learning outcomes from the upcoming oral examination.\n\nTo foster a deeper understanding and critical thinking, students will be encouraged to articulate and justify their design decisions. This isn't just about presenting work, but explaining the rationale and thought process behind every choice made.\n\nRegarding team dynamics and project management, each team will designate a team leader. This leader will guide the collaboration, which will primarily utilize GitHub for project storage. The workflow will involve standard branching and merging procedures, culminating in a final merge for the submission. This approach reinforces industry-standard version control practices and collaborative development skills.\n\nFurthermore, a vital initial step for every team is thorough brainstorming for the project. We expect a clear visualization of your project ideas, perhaps through a mind-mapping application, to be documented and checked in alongside your code. This ensures a well-thought-out foundation and a transparent development process from conception to completion.\n\nMoving on, let's look at the expected learning outcomes. After successfully completing this exam, students should confidently demonstrate several key abilities.\n\nFirstly, you should be able to design intuitive and functional MAUI user interfaces using XAML with confidence. This showcases your practical application skills in modern UI development.\n\nSecondly, the correct application of data binding is crucial, ensuring your applications are robust, responsive, and maintainable.\n\nThirdly, we expect you to be able to verbally explain the principles of the Model-View-ViewModel, or MVVM, architectural pattern. This demonstrates your theoretical understanding and ability to articulate complex software design concepts.\n\nAnd finally, a core skill is the ability to read and critically reason about XAML code. This involves not just understanding what the code does, but why it is structured a certain way and how it can be improved or maintained.\n\nThese are the core competencies we aim for you to achieve by the conclusion of this oral exam design. We look forward to seeing your progress and understanding.",
        "edited_text": "Let's delve into some crucial aspects of our project methodology and the expected learning outcomes from the upcoming oral examination.\n\nTo foster a deeper understanding and critical thinking, students will be encouraged to articulate and justify their design decisions. This isn't just about presenting work, but explaining the rationale and thought process behind every choice made.\n\nRegarding team dynamics and project management, each team will designate a team leader. This leader will guide the collaboration, which will primarily utilize GitHub for project storage. The workflow will involve standard branching and merging procedures, culminating in a final merge for the submission. This approach reinforces industry-standard version control practices and collaborative development skills.\n\nFurthermore, a vital initial step for every team is thorough brainstorming for the project. We expect a clear visualization of your project ideas, perhaps through a mind-mapping application, to be documented and checked in alongside your code. This ensures a well-thought-out foundation and a transparent development process from conception to completion.\n\nMoving on, let's look at the expected learning outcomes. After successfully completing this exam, students should confidently demonstrate several key abilities.\n\nFirstly, you should be able to design intuitive and functional MAUI user interfaces using XAML with confidence. This showcases your practical application skills in modern UI development.\n\nSecondly, the correct application of data binding is crucial, ensuring your applications are robust, responsive, and maintainable.\n\nThirdly, we expect you to be able to verbally explain the principles of the Model-View-ViewModel, or MVVM, architectural pattern. This demonstrates your theoretical understanding and ability to articulate complex software design concepts.\n\nAnd finally, a core skill is the ability to read and critically reason about XAML code. This involves not just understanding what the code does, but why it is structured a certain way and how it can be improved or maintained.\n\nThese are the core competencies we aim for you to achieve by the conclusion of this oral exam design. We look forward to seeing your progress and understanding.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-31 16:24:52",
    "avatar_path": null,
    "final_video_path": null
  },
  "d63adb86-5f32-41aa-ab03-682efa489599": {
    "id": "d63adb86-5f32-41aa-ab03-682efa489599",
    "filename": "ORAL_EXAM_DESIGN.pdf",
    "file_path": "static/uploads/presentations/d63adb86-5f32-41aa-ab03-682efa489599/ORAL_EXAM_DESIGN.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "ORAL EXAM DESIGN \n.NET MAUI – XAML UI & Data Binding (CommunityToolkit.Mvvm) \n \n1. Exam Overview \nExam Type: Practical + Oral Examination \nFormat: Team-based (2 students / team) \nNumber of Teams: 13 teams \nTotal Duration per Team: 2 hours 10 minutes \n• Part 1: Practical UI Project – 2 hours \n• Part 2: Oral Examination – 10 minutes \n \n2. Exam Objectives \nThis oral exam aims to assess students’ ability to: \n• Design UI layouts using XAML in .NET MAUI \n• Correctly apply data binding techniques \n• Implement MVVM pattern using CommunityToolkit.Mvvm \n• Explain and justify technical decisions verbally \n• Demonstrate individual understanding within a team project \n \n3. Allowed Resources \n• Visual Studio 2022 or later \n• .NET MAUI project template \n• Internet access for documentation only \n• NuGet package: CommunityToolkit.Mvvm \n  No pre-written project code allowed \n \n4. Part 1 – Practical Project (2 Hours) \nGeneral Requirements (All Teams) \nEach team must build a single-screen MAUI application with: \n• UI designed in XAML \n• MVVM architecture \n• At least 4 different binding techniques",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning, everyone. Today, I'd like to walk you through the design of our upcoming oral examination, specifically focusing on .NET MAUI, XAML UI, and Data Binding, utilizing the Community Toolkit MVVM.\n\nFirst, let's cover the exam overview. This assessment is a hybrid approach, combining a practical project with an oral examination. You'll be working in teams of two students, and we have a total of thirteen teams participating. Each team will have a dedicated two hours and ten minutes for the entire process. This duration is split into two distinct parts: a two-hour practical UI project, followed by a ten-minute oral examination.\n\nOur primary goal with this exam is to assess your proficiency in several key areas. We want to see your ability to design user interface layouts effectively using XAML within .NET MAUI, and to correctly apply various data binding techniques. Furthermore, we'll be evaluating your skill in implementing the MVVM pattern using the Community Toolkit MVVM. Beyond technical implementation, you'll also need to verbally explain and justify your technical decisions, and importantly, demonstrate your individual understanding within the context of your team's project.\n\nNow, regarding allowed resources. During the exam, you'll have access to Visual Studio 2022 or later, along with the standard .NET MAUI project template. Internet access is permitted strictly for documentation purposes only; no other web browsing is allowed. You may also use the NuGet package for Community Toolkit MVVM. A crucial point to remember is that no pre-written project code is allowed; all development must occur during the exam period.\n\nFinally, let's delve into Part 1: the practical project, which spans a full two hours. The general requirements for all teams are to build a single-screen MAUI application. This application must feature a UI designed entirely in XAML, adhere to the MVVM architectural pattern, and incorporate at least four different data binding techniques.\n\nThank you. I hope this clarifies the structure and expectations for your upcoming exam.",
        "edited_text": "Good morning, everyone. Today, I'd like to walk you through the design of our upcoming oral examination, specifically focusing on .NET MAUI, XAML UI, and Data Binding, utilizing the Community Toolkit MVVM.\n\nFirst, let's cover the exam overview. This assessment is a hybrid approach, combining a practical project with an oral examination. You'll be working in teams of two students, and we have a total of thirteen teams participating. Each team will have a dedicated two hours and ten minutes for the entire process. This duration is split into two distinct parts: a two-hour practical UI project, followed by a ten-minute oral examination.\n\nOur primary goal with this exam is to assess your proficiency in several key areas. We want to see your ability to design user interface layouts effectively using XAML within .NET MAUI, and to correctly apply various data binding techniques. Furthermore, we'll be evaluating your skill in implementing the MVVM pattern using the Community Toolkit MVVM. Beyond technical implementation, you'll also need to verbally explain and justify your technical decisions, and importantly, demonstrate your individual understanding within the context of your team's project.\n\nNow, regarding allowed resources. During the exam, you'll have access to Visual Studio 2022 or later, along with the standard .NET MAUI project template. Internet access is permitted strictly for documentation purposes only; no other web browsing is allowed. You may also use the NuGet package for Community Toolkit MVVM. A crucial point to remember is that no pre-written project code is allowed; all development must occur during the exam period.\n\nFinally, let's delve into Part 1: the practical project, which spans a full two hours. The general requirements for all teams are to build a single-screen MAUI application. This application must feature a UI designed entirely in XAML, adhere to the MVVM architectural pattern, and incorporate at least four different data binding techniques.\n\nThank you. I hope this clarifies the structure and expectations for your upcoming exam.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "• No navigation between pages \n• No database or API \n \nMandatory Binding Techniques \nEach project must demonstrate: \n1. TwoWay Binding (Entry ↔ ViewModel) \n2. OneWay Binding (Display data) \n3. Command Binding (Button actions) \n4. ObservableCollection Binding (List update) \nAt least ONE advanced binding: \n• Converter \n• MultiBinding \n• RelativeSource \n• x:Reference \n \n5. Personalized Project Topics (14 Teams) \nEach team receives one unique UI scenario to prevent copying while keeping difficulty \nequivalent. \nTeam Assignments \nTeam Project Theme \n1 Grocery Shopping List \n2 Daily Habit Tracker \n3 Student Attendance UI \n4 Expense Tracker (UI only) \n5 Book Reading Tracker \n6 Workout Session Planner \n7 Movie Watchlist \n8 Meeting Agenda Manager \n9 Event Checklist",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning, everyone. Let's discuss some important guidelines for our upcoming project. First, to clarify the scope, please note that this project will focus specifically on UI interactions. Therefore, there will be no navigation between different pages, nor will we be integrating with any external databases or APIs. This allows us to concentrate our efforts on mastering the core UI concepts.\n\nNow, regarding mandatory binding techniques, each project must clearly demonstrate proficiency in four key areas. You'll need to implement Two-Way Binding, which allows data synchronization between your entry fields and the ViewModel. We also require One-Way Binding for effectively displaying data to the user. Command Binding is essential for handling button actions and other interactive elements. And finally, Observable Collection Binding will be crucial for dynamically updating lists and collections within your UI.\n\nBeyond these core requirements, each project must also incorporate at least one advanced binding technique. You can choose from options such as a Converter, MultiBinding, RelativeSource, or x:Reference. This ensures you explore more sophisticated UI development patterns.\n\nTo ensure fairness and encourage individual innovation across our fourteen teams, each team will receive a unique UI scenario. This approach prevents direct copying while maintaining an equivalent level of difficulty for everyone. Let me give you a glimpse of some of the diverse project themes assigned. For example, Team 1 will be working on a Grocery Shopping List, while Team 2 has a Daily Habit Tracker. We also have a Student Attendance UI for Team 3, an Expense Tracker for Team 4, and a Book Reading Tracker for Team 5. Other themes include a Workout Session Planner, a Movie Watchlist, a Meeting Agenda Manager, and an Event Checklist. These varied topics will provide rich opportunities to apply your binding knowledge.",
        "edited_text": "Good morning, everyone. Let's discuss some important guidelines for our upcoming project. First, to clarify the scope, please note that this project will focus specifically on UI interactions. Therefore, there will be no navigation between different pages, nor will we be integrating with any external databases or APIs. This allows us to concentrate our efforts on mastering the core UI concepts.\n\nNow, regarding mandatory binding techniques, each project must clearly demonstrate proficiency in four key areas. You'll need to implement Two-Way Binding, which allows data synchronization between your entry fields and the ViewModel. We also require One-Way Binding for effectively displaying data to the user. Command Binding is essential for handling button actions and other interactive elements. And finally, Observable Collection Binding will be crucial for dynamically updating lists and collections within your UI.\n\nBeyond these core requirements, each project must also incorporate at least one advanced binding technique. You can choose from options such as a Converter, MultiBinding, RelativeSource, or x:Reference. This ensures you explore more sophisticated UI development patterns.\n\nTo ensure fairness and encourage individual innovation across our fourteen teams, each team will receive a unique UI scenario. This approach prevents direct copying while maintaining an equivalent level of difficulty for everyone. Let me give you a glimpse of some of the diverse project themes assigned. For example, Team 1 will be working on a Grocery Shopping List, while Team 2 has a Daily Habit Tracker. We also have a Student Attendance UI for Team 3, an Expense Tracker for Team 4, and a Book Reading Tracker for Team 5. Other themes include a Workout Session Planner, a Movie Watchlist, a Meeting Agenda Manager, and an Event Checklist. These varied topics will provide rich opportunities to apply your binding knowledge.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Team Project Theme \n10 Smart Home Device Panel \n11 Plant Care Reminder UI \n12 Simple Note Organizer \n13 Classroom Equipment Checklist \nAll projects must follow the same technical constraints, only the UI content differs. \n \n6. Minimum Feature Set (Example) \nEach project should include: \n• Title header \n• Input section (Entry) \n• Action button(s) \n• List display (CollectionView) \n• Status indicator (Label / CheckBox / Switch) \n• Summary section (count, status, or description) \n \n7. Part 2 – Oral Examination (10 Minutes) \nStructure \n• 5 minutes: Project demonstration \n• 5 minutes: Oral questions (individual) \nBoth students must answer questions. \n \n8. Oral Question Bank (Examiner Chooses) \nUI & XAML (Basic) \n• Why did you choose Grid instead of StackLayout? \n• Explain the role of CollectionView in your UI. \nData Binding \n• Explain the difference between OneWay and TwoWay binding. \n• Why is ObservableCollection required? \nMVVM & Toolkit",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Let's review some important details regarding your upcoming team project, covering the available themes, required features, and the structure of the oral examination.\n\nFirst, for your team project theme, you have several options. These include developing a Smart Home Device Panel, a Plant Care Reminder user interface, a Simple Note Organizer, or a Classroom Equipment Checklist. It's crucial to understand that while the specific user interface content will naturally differ across these projects, all of them must adhere to the exact same technical constraints.\n\nTo ensure consistency and a baseline level of functionality, each project is expected to incorporate a minimum set of features. This includes a clear title header, an input section for data entry, and one or more action buttons for user interaction. You will also need a list display, often implemented using a CollectionView, a status indicator such as a label, checkbox, or switch, and a summary section to provide a count, status, or description of the project's content.\n\nMoving on to the oral examination, this second part of your assessment will be ten minutes in total. It will be structured into two distinct five-minute segments. The first five minutes are dedicated to a demonstration of your project, showcasing its functionality. Following that, there will be five minutes for individual oral questions. Please note that both students from each team are expected to answer questions during this segment.\n\nTo help you prepare, we've provided an example question bank, from which the examiner will choose. Questions will cover topics such as UI and XAML basics; for instance, you might be asked why you chose Grid instead of StackLayout, or to explain the role of CollectionView in your UI. We'll also delve into data binding concepts, like the difference between OneWay and TwoWay binding, and why an ObservableCollection is required. Finally, be ready for questions related to MVVM and the Toolkit.\n\nThis covers the essential details for your team project and oral examination. Please review these points carefully as you prepare.",
        "edited_text": "Let's review some important details regarding your upcoming team project, covering the available themes, required features, and the structure of the oral examination.\n\nFirst, for your team project theme, you have several options. These include developing a Smart Home Device Panel, a Plant Care Reminder user interface, a Simple Note Organizer, or a Classroom Equipment Checklist. It's crucial to understand that while the specific user interface content will naturally differ across these projects, all of them must adhere to the exact same technical constraints.\n\nTo ensure consistency and a baseline level of functionality, each project is expected to incorporate a minimum set of features. This includes a clear title header, an input section for data entry, and one or more action buttons for user interaction. You will also need a list display, often implemented using a CollectionView, a status indicator such as a label, checkbox, or switch, and a summary section to provide a count, status, or description of the project's content.\n\nMoving on to the oral examination, this second part of your assessment will be ten minutes in total. It will be structured into two distinct five-minute segments. The first five minutes are dedicated to a demonstration of your project, showcasing its functionality. Following that, there will be five minutes for individual oral questions. Please note that both students from each team are expected to answer questions during this segment.\n\nTo help you prepare, we've provided an example question bank, from which the examiner will choose. Questions will cover topics such as UI and XAML basics; for instance, you might be asked why you chose Grid instead of StackLayout, or to explain the role of CollectionView in your UI. We'll also delve into data binding concepts, like the difference between OneWay and TwoWay binding, and why an ObservableCollection is required. Finally, be ready for questions related to MVVM and the Toolkit.\n\nThis covers the essential details for your team project and oral examination. Please review these points carefully as you prepare.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "• What problem does CommunityToolkit.Mvvm solve? \n• Explain [ObservableProperty] and [RelayCommand]. \nAdvanced Binding (If Used) \n• Why did you use a converter here? \n• Explain how MultiBinding works in your project. \n \n9. Individual Assessment Strategy \nTo ensure fairness: \n• Examiner asks different questions to each student \n• Each student must explain at least one binding used \n• Examiner may ask one student to modify a binding verbally \n \n10. Grading Rubric (20 Marks) \nPractical Project – 12 Marks \nCriteria Marks \nUI layout correctness 3 \nCorrect binding usage 4 \nMVVM structure 3 \nCode clarity & organization 2 \nOral Examination – 8 Marks \nCriteria Marks \nExplanation of bindings 3 \nMVVM understanding 2 \nIndividual contribution 2 \nCommunication clarity 1 \n \n11. Examiner Notes \n• Focus on understanding, not memorization \n• Penalize code-behind logic",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning everyone. Today, we're going to walk through some key areas and the assessment strategy for your project. First, we'll be exploring the core problem that Community Toolkit MVVM aims to solve, and we'll delve into the practical applications of ObservableProperty and RelayCommand. These are fundamental to building responsive and maintainable applications.\n\nMoving on to advanced binding techniques, if you've used them, be prepared to explain your choices. Specifically, we'll discuss why you might have opted for a converter in a particular scenario and how MultiBinding functions within your project. Understanding the 'why' behind your implementation is just as crucial as the 'how'.\n\nNow, let's look at the individual assessment strategy, designed to ensure fairness for everyone. The examiner will ask different questions to each student, tailoring the discussion to your specific project. Each of you must be ready to explain at least one binding you've used in your work. Furthermore, the examiner may ask one student to verbally modify a binding to assess your understanding and adaptability.\n\nRegarding the grading rubric, your project will be assessed out of a total of twenty marks. Twelve marks are allocated to the practical project itself. This breaks down as follows: three marks for UI layout correctness, four marks for correct binding usage, three marks for your MVVM structure, and two marks for the overall clarity and organization of your code. The remaining eight marks are for the oral examination. Here, three marks are for your explanation of bindings, two marks for your understanding of MVVM principles, two marks for your individual contribution to the project, and one mark for the clarity of your communication.\n\nFinally, a few important notes for the examiner, which are also good guidelines for you. The focus will always be on your understanding of the concepts, not on memorization. We want to see that you grasp the principles. Additionally, please be aware that code-behind logic will be penalized, as we are emphasizing adherence to the MVVM pattern.",
        "edited_text": "Good morning everyone. Today, we're going to walk through some key areas and the assessment strategy for your project. First, we'll be exploring the core problem that Community Toolkit MVVM aims to solve, and we'll delve into the practical applications of ObservableProperty and RelayCommand. These are fundamental to building responsive and maintainable applications.\n\nMoving on to advanced binding techniques, if you've used them, be prepared to explain your choices. Specifically, we'll discuss why you might have opted for a converter in a particular scenario and how MultiBinding functions within your project. Understanding the 'why' behind your implementation is just as crucial as the 'how'.\n\nNow, let's look at the individual assessment strategy, designed to ensure fairness for everyone. The examiner will ask different questions to each student, tailoring the discussion to your specific project. Each of you must be ready to explain at least one binding you've used in your work. Furthermore, the examiner may ask one student to verbally modify a binding to assess your understanding and adaptability.\n\nRegarding the grading rubric, your project will be assessed out of a total of twenty marks. Twelve marks are allocated to the practical project itself. This breaks down as follows: three marks for UI layout correctness, four marks for correct binding usage, three marks for your MVVM structure, and two marks for the overall clarity and organization of your code. The remaining eight marks are for the oral examination. Here, three marks are for your explanation of bindings, two marks for your understanding of MVVM principles, two marks for your individual contribution to the project, and one mark for the clarity of your communication.\n\nFinally, a few important notes for the examiner, which are also good guidelines for you. The focus will always be on your understanding of the concepts, not on memorization. We want to see that you grasp the principles. Additionally, please be aware that code-behind logic will be penalized, as we are emphasizing adherence to the MVVM pattern.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "• Encourage students to explain design decisions \n• Each team having a team leader, using GitHub to store the project, branch then merge \nfor the final submission \n• Each team must have a brainstorming for the project (visualation using any mindmap \napplication), checkin along with code.  \n \n12. Expected Learning Outcomes \nAfter the exam, students should be able to: \n• Design MAUI UI using XAML confidently \n• Apply data binding correctly \n• Explain MVVM principles verbally \n• Read and reason about XAML code \n \nEnd of Oral Exam Design",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning everyone. Let's delve into some key aspects of our project and the expected outcomes.\n\nTo foster a deeper understanding and critical thinking, students will be actively encouraged to articulate and justify their design decisions throughout the project. This is crucial for developing strong problem-solving skills.\n\nRegarding team dynamics and project management, each team will operate with a designated team leader. They will utilize industry-standard practices, leveraging GitHub to store their project, employing branching for individual work, and then merging for the final submission. This approach ensures effective collaboration and adherence to best practices in version control. Furthermore, every team is required to conduct a thorough brainstorming session for their project, visualizing their ideas using a mind map application. This initial planning documentation must be checked in along with their code, emphasizing the importance of a well-defined development process.\n\nMoving on, let's outline the expected learning outcomes from this examination. After completing the assessment, students should confidently be able to design MAUI user interfaces using XAML. They will also demonstrate the ability to apply data binding correctly within their applications. A key outcome is the capacity to explain MVVM principles verbally, showcasing a clear understanding of this architectural pattern. Finally, students will develop the critical skill of reading and reasoning effectively about XAML code, enabling them to comprehend and debug complex UI structures.\n\nThis concludes our overview of the oral exam design.",
        "edited_text": "Good morning everyone. Let's delve into some key aspects of our project and the expected outcomes.\n\nTo foster a deeper understanding and critical thinking, students will be actively encouraged to articulate and justify their design decisions throughout the project. This is crucial for developing strong problem-solving skills.\n\nRegarding team dynamics and project management, each team will operate with a designated team leader. They will utilize industry-standard practices, leveraging GitHub to store their project, employing branching for individual work, and then merging for the final submission. This approach ensures effective collaboration and adherence to best practices in version control. Furthermore, every team is required to conduct a thorough brainstorming session for their project, visualizing their ideas using a mind map application. This initial planning documentation must be checked in along with their code, emphasizing the importance of a well-defined development process.\n\nMoving on, let's outline the expected learning outcomes from this examination. After completing the assessment, students should confidently be able to design MAUI user interfaces using XAML. They will also demonstrate the ability to apply data binding correctly within their applications. A key outcome is the capacity to explain MVVM principles verbally, showcasing a clear understanding of this architectural pattern. Finally, students will develop the critical skill of reading and reasoning effectively about XAML code, enabling them to comprehend and debug complex UI structures.\n\nThis concludes our overview of the oral exam design.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-31 16:34:55",
    "avatar_path": null,
    "final_video_path": null
  },
  "60900d9f-bfcb-46d7-aa75-fa6593a2dcf3": {
    "id": "60900d9f-bfcb-46d7-aa75-fa6593a2dcf3",
    "filename": "ORAL_EXAM_DESIGN.pdf",
    "file_path": "static/uploads/presentations/60900d9f-bfcb-46d7-aa75-fa6593a2dcf3/ORAL_EXAM_DESIGN.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "ORAL EXAM DESIGN \n.NET MAUI – XAML UI & Data Binding (CommunityToolkit.Mvvm) \n \n1. Exam Overview \nExam Type: Practical + Oral Examination \nFormat: Team-based (2 students / team) \nNumber of Teams: 13 teams \nTotal Duration per Team: 2 hours 10 minutes \n• Part 1: Practical UI Project – 2 hours \n• Part 2: Oral Examination – 10 minutes \n \n2. Exam Objectives \nThis oral exam aims to assess students’ ability to: \n• Design UI layouts using XAML in .NET MAUI \n• Correctly apply data binding techniques \n• Implement MVVM pattern using CommunityToolkit.Mvvm \n• Explain and justify technical decisions verbally \n• Demonstrate individual understanding within a team project \n \n3. Allowed Resources \n• Visual Studio 2022 or later \n• .NET MAUI project template \n• Internet access for documentation only \n• NuGet package: CommunityToolkit.Mvvm \n  No pre-written project code allowed \n \n4. Part 1 – Practical Project (2 Hours) \nGeneral Requirements (All Teams) \nEach team must build a single-screen MAUI application with: \n• UI designed in XAML \n• MVVM architecture \n• At least 4 different binding techniques",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning, everyone. Today, we're going to walk through the design of your upcoming oral examination, focusing on .NET MAUI, XAML UI, and Data Binding, specifically using the Community Toolkit Dot MVVM.\n\nLet's start with an overview of the exam structure. This will be a combined practical and oral examination, conducted in teams of two students. We'll have thirteen teams participating. Each team will have a total of two hours and ten minutes. The bulk of this, two hours, is dedicated to the practical UI project, followed by a concise ten-minute oral examination where you'll present your work.\n\nMoving on to the objectives, this oral exam is designed to assess several key abilities. First, your proficiency in designing user interface layouts using XAML within the .NET MAUI framework. Second, your capability to correctly apply various data binding techniques. Third, we'll be looking at your implementation of the MVVM pattern, specifically utilizing the Community Toolkit Dot MVVM. Beyond the code, we also want to see your ability to verbally explain and justify your technical decisions, and importantly, how you demonstrate your individual understanding and contribution within your team project.\n\nRegarding resources, you are permitted to use Visual Studio 2022 or a later version, along with the standard .NET MAUI project template. Internet access will be provided strictly for documentation purposes only, meaning you can look up syntax or API references, but absolutely no pre-written project code or full solutions are allowed. You will also have access to the Community Toolkit Dot MVVM NuGet package.\n\nNow, let's look closer at Part 1, the two-hour practical project. Each team is required to build a single-screen MAUI application. This application must feature a user interface designed entirely in XAML, adhere to the MVVM architecture, and crucially, demonstrate the use of at least four different data binding techniques.\n\nThat concludes our overview of the oral exam design. Thank you.",
        "edited_text": "Good morning, everyone. Today, we're going to walk through the design of your upcoming oral examination, focusing on .NET MAUI, XAML UI, and Data Binding, specifically using the Community Toolkit Dot MVVM.\n\nLet's start with an overview of the exam structure. This will be a combined practical and oral examination, conducted in teams of two students. We'll have thirteen teams participating. Each team will have a total of two hours and ten minutes. The bulk of this, two hours, is dedicated to the practical UI project, followed by a concise ten-minute oral examination where you'll present your work.\n\nMoving on to the objectives, this oral exam is designed to assess several key abilities. First, your proficiency in designing user interface layouts using XAML within the .NET MAUI framework. Second, your capability to correctly apply various data binding techniques. Third, we'll be looking at your implementation of the MVVM pattern, specifically utilizing the Community Toolkit Dot MVVM. Beyond the code, we also want to see your ability to verbally explain and justify your technical decisions, and importantly, how you demonstrate your individual understanding and contribution within your team project.\n\nRegarding resources, you are permitted to use Visual Studio 2022 or a later version, along with the standard .NET MAUI project template. Internet access will be provided strictly for documentation purposes only, meaning you can look up syntax or API references, but absolutely no pre-written project code or full solutions are allowed. You will also have access to the Community Toolkit Dot MVVM NuGet package.\n\nNow, let's look closer at Part 1, the two-hour practical project. Each team is required to build a single-screen MAUI application. This application must feature a user interface designed entirely in XAML, adhere to the MVVM architecture, and crucially, demonstrate the use of at least four different data binding techniques.\n\nThat concludes our overview of the oral exam design. Thank you.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 2,
        "content": "• No navigation between pages \n• No database or API \n \nMandatory Binding Techniques \nEach project must demonstrate: \n1. TwoWay Binding (Entry ↔ ViewModel) \n2. OneWay Binding (Display data) \n3. Command Binding (Button actions) \n4. ObservableCollection Binding (List update) \nAt least ONE advanced binding: \n• Converter \n• MultiBinding \n• RelativeSource \n• x:Reference \n \n5. Personalized Project Topics (14 Teams) \nEach team receives one unique UI scenario to prevent copying while keeping difficulty \nequivalent. \nTeam Assignments \nTeam Project Theme \n1 Grocery Shopping List \n2 Daily Habit Tracker \n3 Student Attendance UI \n4 Expense Tracker (UI only) \n5 Book Reading Tracker \n6 Workout Session Planner \n7 Movie Watchlist \n8 Meeting Agenda Manager \n9 Event Checklist",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Alright everyone, let's discuss some important guidelines and requirements for our upcoming projects. First, it's crucial to understand a couple of fundamental constraints. For these projects, there will be no navigation between pages. We are focusing on single-page user interface designs. Additionally, you will not be interacting with any external databases or APIs; all data handling should be managed locally within your application.\n\nNow, let's move on to the mandatory binding techniques that each project must clearly demonstrate. You are required to implement Two-Way Binding, which is essential for ensuring data synchronization between your user interface entry fields and your ViewModel. Next, One-Way Binding must be used, primarily for effectively displaying data from your ViewModel to the UI. Command Binding is also mandatory to handle various button actions and user interactions within your application. And finally, for dynamic lists and collections, you must utilize Observable Collection Binding, ensuring that your user interface lists update automatically whenever the underlying data changes.\n\nBeyond these core techniques, each project must also incorporate at least one advanced binding method. You have several excellent options to choose from, including Converters, which are great for transforming data before display, MultiBinding, allowing you to combine multiple sources into a single target, RelativeSource binding for locating elements within the visual tree, or x:Reference for direct element referencing.\n\nTo ensure fairness and encourage individual creativity, we have personalized project topics for all fourteen teams. Each team will receive one unique UI scenario. This approach prevents direct copying while maintaining an equivalent level of difficulty across all assignments. For instance, some of the exciting project themes include creating a Grocery Shopping List, a Daily Habit Tracker, a Student Attendance UI, an Expense Tracker, a Book Reading Tracker, a Workout Session Planner, a Movie Watchlist, a Meeting Agenda Manager, or even an Event Checklist. These diverse topics will provide ample opportunity to apply all the required binding techniques effectively.",
        "edited_text": "Alright everyone, let's discuss some important guidelines and requirements for our upcoming projects. First, it's crucial to understand a couple of fundamental constraints. For these projects, there will be no navigation between pages. We are focusing on single-page user interface designs. Additionally, you will not be interacting with any external databases or APIs; all data handling should be managed locally within your application.\n\nNow, let's move on to the mandatory binding techniques that each project must clearly demonstrate. You are required to implement Two-Way Binding, which is essential for ensuring data synchronization between your user interface entry fields and your ViewModel. Next, One-Way Binding must be used, primarily for effectively displaying data from your ViewModel to the UI. Command Binding is also mandatory to handle various button actions and user interactions within your application. And finally, for dynamic lists and collections, you must utilize Observable Collection Binding, ensuring that your user interface lists update automatically whenever the underlying data changes.\n\nBeyond these core techniques, each project must also incorporate at least one advanced binding method. You have several excellent options to choose from, including Converters, which are great for transforming data before display, MultiBinding, allowing you to combine multiple sources into a single target, RelativeSource binding for locating elements within the visual tree, or x:Reference for direct element referencing.\n\nTo ensure fairness and encourage individual creativity, we have personalized project topics for all fourteen teams. Each team will receive one unique UI scenario. This approach prevents direct copying while maintaining an equivalent level of difficulty across all assignments. For instance, some of the exciting project themes include creating a Grocery Shopping List, a Daily Habit Tracker, a Student Attendance UI, an Expense Tracker, a Book Reading Tracker, a Workout Session Planner, a Movie Watchlist, a Meeting Agenda Manager, or even an Event Checklist. These diverse topics will provide ample opportunity to apply all the required binding techniques effectively.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Team Project Theme \n10 Smart Home Device Panel \n11 Plant Care Reminder UI \n12 Simple Note Organizer \n13 Classroom Equipment Checklist \nAll projects must follow the same technical constraints, only the UI content differs. \n \n6. Minimum Feature Set (Example) \nEach project should include: \n• Title header \n• Input section (Entry) \n• Action button(s) \n• List display (CollectionView) \n• Status indicator (Label / CheckBox / Switch) \n• Summary section (count, status, or description) \n \n7. Part 2 – Oral Examination (10 Minutes) \nStructure \n• 5 minutes: Project demonstration \n• 5 minutes: Oral questions (individual) \nBoth students must answer questions. \n \n8. Oral Question Bank (Examiner Chooses) \nUI & XAML (Basic) \n• Why did you choose Grid instead of StackLayout? \n• Explain the role of CollectionView in your UI. \nData Binding \n• Explain the difference between OneWay and TwoWay binding. \n• Why is ObservableCollection required? \nMVVM & Toolkit",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Alright team, let's go over some key details for your upcoming project.\n\nFirst, regarding the Team Project Theme, you have a selection of options to choose from. For example, you could develop a Smart Home Device Panel, a Plant Care Reminder user interface, a Simple Note Organizer, or a Classroom Equipment Checklist. It's important to remember that while the user interface content will differ across these projects, all of them must adhere to the same underlying technical constraints.\n\nMoving on to the Minimum Feature Set, each project is expected to include several core components. This includes a clear title header, an input section, typically an Entry field, for user interaction, and at least one action button. You'll also need a list display, which will likely be implemented using a CollectionView, and a status indicator, which could be a Label, CheckBox, or Switch. Finally, each project should incorporate a summary section, perhaps displaying a count, overall status, or a brief description.\n\nNow, let's talk about Part Two of the assessment, which is your Oral Examination. This will be a ten-minute session structured into two equal parts. The first five minutes will be dedicated to a demonstration of your project. Following this, the next five minutes will involve individual oral questions. Please note that both students in the team are expected to answer questions during this segment.\n\nTo give you an idea of the types of questions you might encounter, we have an Oral Question Bank from which the examiner will choose. In the UI and XAML basic category, you might be asked to explain your design choices, such as \"Why did you choose Grid instead of StackLayout?\" or \"Explain the role of CollectionView in your UI.\" When it comes to Data Binding, expect questions like \"Explain the difference between OneWay and TwoWay binding,\" or \"Why is ObservableCollection required?\" We also anticipate questions related to MVVM and the Toolkit, so be prepared in those areas as well.",
        "edited_text": "Alright team, let's go over some key details for your upcoming project.\n\nFirst, regarding the Team Project Theme, you have a selection of options to choose from. For example, you could develop a Smart Home Device Panel, a Plant Care Reminder user interface, a Simple Note Organizer, or a Classroom Equipment Checklist. It's important to remember that while the user interface content will differ across these projects, all of them must adhere to the same underlying technical constraints.\n\nMoving on to the Minimum Feature Set, each project is expected to include several core components. This includes a clear title header, an input section, typically an Entry field, for user interaction, and at least one action button. You'll also need a list display, which will likely be implemented using a CollectionView, and a status indicator, which could be a Label, CheckBox, or Switch. Finally, each project should incorporate a summary section, perhaps displaying a count, overall status, or a brief description.\n\nNow, let's talk about Part Two of the assessment, which is your Oral Examination. This will be a ten-minute session structured into two equal parts. The first five minutes will be dedicated to a demonstration of your project. Following this, the next five minutes will involve individual oral questions. Please note that both students in the team are expected to answer questions during this segment.\n\nTo give you an idea of the types of questions you might encounter, we have an Oral Question Bank from which the examiner will choose. In the UI and XAML basic category, you might be asked to explain your design choices, such as \"Why did you choose Grid instead of StackLayout?\" or \"Explain the role of CollectionView in your UI.\" When it comes to Data Binding, expect questions like \"Explain the difference between OneWay and TwoWay binding,\" or \"Why is ObservableCollection required?\" We also anticipate questions related to MVVM and the Toolkit, so be prepared in those areas as well.",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "• What problem does CommunityToolkit.Mvvm solve? \n• Explain [ObservableProperty] and [RelayCommand]. \nAdvanced Binding (If Used) \n• Why did you use a converter here? \n• Explain how MultiBinding works in your project. \n \n9. Individual Assessment Strategy \nTo ensure fairness: \n• Examiner asks different questions to each student \n• Each student must explain at least one binding used \n• Examiner may ask one student to modify a binding verbally \n \n10. Grading Rubric (20 Marks) \nPractical Project – 12 Marks \nCriteria Marks \nUI layout correctness 3 \nCorrect binding usage 4 \nMVVM structure 3 \nCode clarity & organization 2 \nOral Examination – 8 Marks \nCriteria Marks \nExplanation of bindings 3 \nMVVM understanding 2 \nIndividual contribution 2 \nCommunication clarity 1 \n \n11. Examiner Notes \n• Focus on understanding, not memorization \n• Penalize code-behind logic",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "• Encourage students to explain design decisions \n• Each team having a team leader, using GitHub to store the project, branch then merge \nfor the final submission \n• Each team must have a brainstorming for the project (visualation using any mindmap \napplication), checkin along with code.  \n \n12. Expected Learning Outcomes \nAfter the exam, students should be able to: \n• Design MAUI UI using XAML confidently \n• Apply data binding correctly \n• Explain MVVM principles verbally \n• Read and reason about XAML code \n \nEnd of Oral Exam Design",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-31 16:50:46",
    "avatar_path": null,
    "final_video_path": null
  },
  "47960495-fced-4cc0-9a85-0bef4a347b91": {
    "id": "47960495-fced-4cc0-9a85-0bef4a347b91",
    "filename": "ORAL_EXAM_DESIGN.pdf",
    "file_path": "static/uploads/presentations/47960495-fced-4cc0-9a85-0bef4a347b91/ORAL_EXAM_DESIGN.pdf",
    "type": ".pdf",
    "slides": [
      {
        "slide_num": 1,
        "content": "ORAL EXAM DESIGN \n.NET MAUI – XAML UI & Data Binding (CommunityToolkit.Mvvm) \n \n1. Exam Overview \nExam Type: Practical + Oral Examination \nFormat: Team-based (2 students / team) \nNumber of Teams: 13 teams \nTotal Duration per Team: 2 hours 10 minutes \n• Part 1: Practical UI Project – 2 hours \n• Part 2: Oral Examination – 10 minutes \n \n2. Exam Objectives \nThis oral exam aims to assess students’ ability to: \n• Design UI layouts using XAML in .NET MAUI \n• Correctly apply data binding techniques \n• Implement MVVM pattern using CommunityToolkit.Mvvm \n• Explain and justify technical decisions verbally \n• Demonstrate individual understanding within a team project \n \n3. Allowed Resources \n• Visual Studio 2022 or later \n• .NET MAUI project template \n• Internet access for documentation only \n• NuGet package: CommunityToolkit.Mvvm \n  No pre-written project code allowed \n \n4. Part 1 – Practical Project (2 Hours) \nGeneral Requirements (All Teams) \nEach team must build a single-screen MAUI application with: \n• UI designed in XAML \n• MVVM architecture \n• At least 4 different binding techniques",
        "notes": "",
        "total_slides": 5,
        "generated_text": "Good morning everyone. Today, we're going to walk through the design of our upcoming oral examination, focusing on .NET MAUI, XAML UI, and Data Binding with the Community Toolkit for MVVM.\n\nFirst, let's cover the exam overview. This will be a practical and oral examination, designed to assess both your hands-on skills and your understanding. It's a team-based format, with each team consisting of two students. We anticipate a total of thirteen teams participating. The total duration allocated per team is two hours and ten minutes. This time is divided into two parts: a two-hour practical UI project, followed by a concise ten-minute oral examination.\n\nMoving on to the core objectives. This oral exam aims to thoroughly assess your ability to design user interface layouts effectively using XAML within the .NET MAUI framework. You'll also be evaluated on your skill in correctly applying various data binding techniques. A key objective is your implementation of the MVVM pattern, specifically utilizing the Community Toolkit for MVVM. Furthermore, we want to see your capability to explain and justify your technical decisions verbally, and to demonstrate your individual understanding even within the context of a collaborative team project.\n\nRegarding the allowed resources for the exam, you will have access to Visual Studio 2022 or later, the standard .NET MAUI project template, and internet access strictly for documentation purposes only. You are also permitted to use the NuGet package for the Community Toolkit for MVVM. Please note, and this is crucial, no pre-written project code is allowed. You must start from scratch.\n\nFinally, for Part One, the two-hour practical project, here are the general requirements for all teams. Each team is tasked with building a single-screen MAUI application. This application must feature a user interface designed entirely in XAML, adhere to the MVVM architecture, and crucially, demonstrate the use of at least four different binding techniques.\n\nThank you.",
        "edited_text": "Good morning everyone. Today, we're going to walk through the design of our upcoming oral examination, focusing on .NET MAUI, XAML UI, and Data Binding with the Community Toolkit for MVVM.\n\nFirst, let's cover the exam overview. This will be a practical and oral examination, designed to assess both your hands-on skills and your understanding. It's a team-based format, with each team consisting of two students. We anticipate a total of thirteen teams participating. The total duration allocated per team is two hours and ten minutes. This time is divided into two parts: a two-hour practical UI project, followed by a concise ten-minute oral examination.\n\nMoving on to the core objectives. This oral exam aims to thoroughly assess your ability to design user interface layouts effectively using XAML within the .NET MAUI framework. You'll also be evaluated on your skill in correctly applying various data binding techniques. A key objective is your implementation of the MVVM pattern, specifically utilizing the Community Toolkit for MVVM. Furthermore, we want to see your capability to explain and justify your technical decisions verbally, and to demonstrate your individual understanding even within the context of a collaborative team project.\n\nRegarding the allowed resources for the exam, you will have access to Visual Studio 2022 or later, the standard .NET MAUI project template, and internet access strictly for documentation purposes only. You are also permitted to use the NuGet package for the Community Toolkit for MVVM. Please note, and this is crucial, no pre-written project code is allowed. You must start from scratch.\n\nFinally, for Part One, the two-hour practical project, here are the general requirements for all teams. Each team is tasked with building a single-screen MAUI application. This application must feature a user interface designed entirely in XAML, adhere to the MVVM architecture, and crucially, demonstrate the use of at least four different binding techniques.\n\nThank you.",
        "audio_path": null,
        "video_path": null,
        "status": "pending",
        "audio_url": "/static/audio/47960495-fced-4cc0-9a85-0bef4a347b91/slide_1.wav",
        "audio_file_path": "/app/app/../static/audio/47960495-fced-4cc0-9a85-0bef4a347b91/slide_1.wav"
      },
      {
        "slide_num": 2,
        "content": "• No navigation between pages \n• No database or API \n \nMandatory Binding Techniques \nEach project must demonstrate: \n1. TwoWay Binding (Entry ↔ ViewModel) \n2. OneWay Binding (Display data) \n3. Command Binding (Button actions) \n4. ObservableCollection Binding (List update) \nAt least ONE advanced binding: \n• Converter \n• MultiBinding \n• RelativeSource \n• x:Reference \n \n5. Personalized Project Topics (14 Teams) \nEach team receives one unique UI scenario to prevent copying while keeping difficulty \nequivalent. \nTeam Assignments \nTeam Project Theme \n1 Grocery Shopping List \n2 Daily Habit Tracker \n3 Student Attendance UI \n4 Expense Tracker (UI only) \n5 Book Reading Tracker \n6 Workout Session Planner \n7 Movie Watchlist \n8 Meeting Agenda Manager \n9 Event Checklist",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 3,
        "content": "Team Project Theme \n10 Smart Home Device Panel \n11 Plant Care Reminder UI \n12 Simple Note Organizer \n13 Classroom Equipment Checklist \nAll projects must follow the same technical constraints, only the UI content differs. \n \n6. Minimum Feature Set (Example) \nEach project should include: \n• Title header \n• Input section (Entry) \n• Action button(s) \n• List display (CollectionView) \n• Status indicator (Label / CheckBox / Switch) \n• Summary section (count, status, or description) \n \n7. Part 2 – Oral Examination (10 Minutes) \nStructure \n• 5 minutes: Project demonstration \n• 5 minutes: Oral questions (individual) \nBoth students must answer questions. \n \n8. Oral Question Bank (Examiner Chooses) \nUI & XAML (Basic) \n• Why did you choose Grid instead of StackLayout? \n• Explain the role of CollectionView in your UI. \nData Binding \n• Explain the difference between OneWay and TwoWay binding. \n• Why is ObservableCollection required? \nMVVM & Toolkit",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 4,
        "content": "• What problem does CommunityToolkit.Mvvm solve? \n• Explain [ObservableProperty] and [RelayCommand]. \nAdvanced Binding (If Used) \n• Why did you use a converter here? \n• Explain how MultiBinding works in your project. \n \n9. Individual Assessment Strategy \nTo ensure fairness: \n• Examiner asks different questions to each student \n• Each student must explain at least one binding used \n• Examiner may ask one student to modify a binding verbally \n \n10. Grading Rubric (20 Marks) \nPractical Project – 12 Marks \nCriteria Marks \nUI layout correctness 3 \nCorrect binding usage 4 \nMVVM structure 3 \nCode clarity & organization 2 \nOral Examination – 8 Marks \nCriteria Marks \nExplanation of bindings 3 \nMVVM understanding 2 \nIndividual contribution 2 \nCommunication clarity 1 \n \n11. Examiner Notes \n• Focus on understanding, not memorization \n• Penalize code-behind logic",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      },
      {
        "slide_num": 5,
        "content": "• Encourage students to explain design decisions \n• Each team having a team leader, using GitHub to store the project, branch then merge \nfor the final submission \n• Each team must have a brainstorming for the project (visualation using any mindmap \napplication), checkin along with code.  \n \n12. Expected Learning Outcomes \nAfter the exam, students should be able to: \n• Design MAUI UI using XAML confidently \n• Apply data binding correctly \n• Explain MVVM principles verbally \n• Read and reason about XAML code \n \nEnd of Oral Exam Design",
        "notes": "",
        "total_slides": 5,
        "generated_text": "",
        "edited_text": "",
        "audio_path": null,
        "video_path": null,
        "status": "pending"
      }
    ],
    "created_at": "2026-01-31 18:57:45",
    "avatar_path": null,
    "final_video_path": null
  }
}